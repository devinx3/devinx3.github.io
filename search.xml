<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Arthas 介绍</title>
    <url>/2023/09/30/Arthas/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://arthas.aliyun.com/images/arthas.png"></p>
<p>Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p>
<h2 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h2><h3 id="停止-arthas-服务端"><a href="#停止-arthas-服务端" class="headerlink" title="停止 arthas 服务端"></a>停止 arthas 服务端</h3><p><code>stop</code> 关闭 Arthas 服务端，所有 Arthas 客户端全部退出</p>
<h3 id="arthas-全局配置"><a href="#arthas-全局配置" class="headerlink" title="arthas 全局配置"></a>arthas 全局配置</h3><table>
<thead>
<tr>
<th>名称</th>
<th align="center">默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>json-format</td>
<td align="center">false</td>
<td>是否支持 json 化的输出</td>
</tr>
<tr>
<td>save-result</td>
<td align="center">false</td>
<td>是否打开执行结果存日志功能，打开之后所有命令的运行结果都将保存到<code>~/logs/arthas-cache/result.log</code>中</td>
</tr>
</tbody></table>
<p><code>options json-format</code> 获取指定 option 的值<br><code>options save-result true</code> 设置 option 的值</p>
<h3 id="搜索命令"><a href="#搜索命令" class="headerlink" title="搜索命令"></a>搜索命令</h3><h4 id="查询类"><a href="#查询类" class="headerlink" title="查询类"></a>查询类</h4><p><code>sc java.lang.Math -d | grep Loader </code> 查找当前 class 被那个classsLoader 加载, 以及 hash 值</p>
<h3 id="ongl-表达式"><a href="#ongl-表达式" class="headerlink" title="ongl 表达式"></a>ongl 表达式</h3><p><a href="%5Bhttps://commons.apache.org/proper/commons-ognl/language-guide.html%5D(https://commons.apache.org/proper/commons-ognl/language-guide.html)">OGNL 表达式官网</a><br><a href="https://github.com/alibaba/arthas/issues/71">arthas 特殊用法</a></p>
<h2 id="docker-快速使用"><a href="#docker-快速使用" class="headerlink" title="docker 快速使用"></a>docker 快速使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /arthas</span><br><span class="line">cd /arthas </span><br><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">资源清理</span></span><br><span class="line">rm -rf /arthas</span><br><span class="line">rm -rf ~/.arthas/</span><br><span class="line">rm -rf ~/logs/arthas</span><br></pre></td></tr></table></figure>

<h2 id="获取实例对象方式"><a href="#获取实例对象方式" class="headerlink" title="获取实例对象方式"></a>获取实例对象方式</h2><h3 id="使用-vmtool-获取-bean-对象"><a href="#使用-vmtool-获取-bean-对象" class="headerlink" title="使用 vmtool 获取 bean 对象"></a>使用 vmtool 获取 bean 对象</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmtool -x 1 \</span><br><span class="line">--action getInstances \</span><br><span class="line">--classLoaderClass &#x27;java.net.URLClassLoader&#x27; \</span><br><span class="line">--className org.springframework.context.ApplicationContext \</span><br><span class="line">--express &#x27;instances[0].getBean(&quot;orderHeaderMapper&quot;)&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="使用-ognl-表达式获取-bean-对象"><a href="#使用-ognl-表达式获取-bean-对象" class="headerlink" title="使用 ognl 表达式获取 bean 对象"></a>使用 ognl 表达式获取 bean 对象</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ognl -x 2 \</span><br><span class="line">-classLoaderClass &#x27;org.springframework.boot.loader.LaunchedURLClassLoader&#x27; \</span><br><span class="line">&#x27;#context=@packageName.ApplicationContextHelper@context,#beanObj=#context.getBean(&quot;orderHeaderMapper&quot;),&#123;#beanObj&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="使用-ognl-表达式获取-bean-对象-遍历单例缓存"><a href="#使用-ognl-表达式获取-bean-对象-遍历单例缓存" class="headerlink" title="使用 ognl 表达式获取 bean 对象(遍历单例缓存)"></a>使用 ognl 表达式获取 bean 对象(遍历单例缓存)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ognl -x 2 \</span><br><span class="line">-classLoaderClass &#x27;org.springframework.boot.loader.LaunchedURLClassLoader&#x27; \</span><br><span class="line">&#x27;#beanList=@packageName.ApplicationContextHelper@context.beanFactory.singletonObjects.entrySet().iterator.&#123;? #this.key ==&quot;orderHeaderMapper&quot;&#125;,&#123;#beanList[0].value&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="使用静态方法"><a href="#使用静态方法" class="headerlink" title="使用静态方法"></a>使用静态方法</h3><p><code>getstatic packageName.ApplicationContextHelper context &#39;#beanList=beanFactory.singletonObjects.entrySet().iterator.&#123;? #this.key ==&quot;orderHeaderMapper&quot;&#125;,&#123;#beanList[0].value&#125;&#39;</code></p>
<h2 id="idea-插件"><a href="#idea-插件" class="headerlink" title="idea 插件"></a>idea 插件</h2><h3 id="Arthas-idea（部分命令可视化）"><a href="#Arthas-idea（部分命令可视化）" class="headerlink" title="Arthas-idea（部分命令可视化）"></a>Arthas-idea（部分命令可视化）</h3><ul>
<li>Jetbrains 插件获取地址：<a href="https://plugins.jetbrains.com/plugin/13581-arthas-idea">https://plugins.jetbrains.com/plugin/13581-arthas-idea</a></li>
<li>使用文档：<a href="https://www.yuque.com/arthas-idea-plugin">https://www.yuque.com/arthas-idea-plugin</a></li>
<li>源码地址：<a href="https://github.com/WangJi92/arthas-idea-plugin">https://github.com/WangJi92/arthas-idea-plugin</a></li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://arthas.aliyun.com/doc/quick-start.html">arthas</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Arthas</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 映像与镜像仓库</title>
    <url>/2019/12/31/CentOS/</url>
    <content><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><table>
<thead>
<tr>
<th>映像(CentOS8的iso)</th>
<th>备注</th>
<th>镜像</th>
<th>镜像源网址</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://vault.centos.org/8.0.1905/isos/x86_64/">官方映像 ISO</a></td>
<td>包含老版本</td>
<td>-</td>
<td><a href="http://mirror.centos.org/">http://mirror.centos.org</a></td>
</tr>
<tr>
<td><a href="http://cloud.centos.org/centos/8/x86_64/images/">官方云镜像 ISO</a></td>
<td>没有老版本</td>
<td>-</td>
<td><a href="http://mirror.centos.org/">http://mirror.centos.org</a></td>
</tr>
<tr>
<td><a href="http://mirrors.huaweicloud.com/centos/8/isos/x86_64/">官方镜像列表</a></td>
<td></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><a href="http://mirrors.aliyun.com/centos/8/isos/x86_64/">阿里云 ISO</a></td>
<td></td>
<td><a href="http://maven.aliyun.com/centos/">阿里云</a></td>
<td><a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com</a></td>
</tr>
<tr>
<td><a href="http://repo.huaweicloud.com/centos/">华为</a></td>
<td></td>
<td><a href="https://repo.huaweicloud.com/centos/">华为</a></td>
<td><a href="https://repo.huaweicloud.com/">https://repo.huaweicloud.com</a></td>
</tr>
<tr>
<td><a href="http://mirrors.163.com/centos/8/isos/x86_64/">网易</a></td>
<td></td>
<td><a href="http://mirrors.163.com/centos/">网易</a></td>
<td><a href="http://mirrors.163.com/">http://mirrors.163.com</a></td>
</tr>
<tr>
<td><a href="https://mirrors.cloud.tencent.com/centos/8/isos/x86_64/">腾讯</a></td>
<td></td>
<td><a href="http://mirrors.cloud.tencent.com/centos/">腾讯</a></td>
<td><a href="http://mirrors.cloud.tencent.com/">http://mirrors.cloud.tencent.com</a></td>
</tr>
<tr>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/centos/8/isos/x86_64/">清华大学</a></td>
<td></td>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/centos/">清华大学</a></td>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn</a></td>
</tr>
<tr>
<td><a href="http://mirror.lzu.edu.cn/centos/">兰州大学</a></td>
<td></td>
<td><a href="http://mirror.lzu.edu.cn/centos/">兰州大学</a></td>
<td><a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn</a></td>
</tr>
<tr>
<td><a href="https://mirrors.ustc.edu.cn/centos/8/isos/x86_64/">中国科技大学</a></td>
<td></td>
<td><a href="https://mirrors.ustc.edu.cn/centos/">中国科技大学</a></td>
<td><a href="https://mirrors.ustc.edu.cn/">https://mirrors.ustc.edu.cn</a></td>
</tr>
<tr>
<td><a href="https://mirror.sjtu.edu.cn/centos/8/isos/x86_64/">上海交大</a></td>
<td></td>
<td><a href="https://mirror.sjtu.edu.cn/centos">上海交大</a></td>
<td><a href="https://mirror.sjtu.edu.cn/">https://mirror.sjtu.edu.cn</a></td>
</tr>
<tr>
<td><a href="http://centos.mirror.liquidtelecom.com/8/isos/x86_64/">Liquid Telecom</a></td>
<td></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><a href="http://centos.bitcomm.cn/centos/8/isos/x86_64/">常州贝特康姆软件技术有限公司</a></td>
<td></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><a href="http://mirrors.pubyun.com/centos/8/isos/x86_64/">公云PubYun（母公司为贝特康姆）</a></td>
<td></td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>1、备份配置文件：</p>
<p><code>sudo cp -a /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</code></p>
<p>2、修改<strong>CentOS-Base.repo</strong>文件，取消<strong>baseurl</strong>开头的行的注释，并增加<strong>mirrorlist</strong>开头的行的注释。将文件中的<code>http://mirror.centos.org</code>替换成<code>https://repo.huaweicloud.com</code>(可修改为上面的网址)，可以参考如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sed -i \</span><br><span class="line">-e &quot;s/#baseurl/baseurl/g&quot; \</span><br><span class="line">-e &quot;s/mirrorlist=http/#mirrorlist=http/g&quot; \</span><br><span class="line">-e &quot;s@http://mirror.centos.org@https://repo.huaweicloud.com@g&quot; \</span><br><span class="line">/etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure>

<p>3、执行<code>yum clean all</code>清除原有yum缓存。</p>
<p>4、执行<code>yum makecache</code>（刷新缓存）或者<code>yum repolist all</code>（查看所有配置可以使用的文件，会自动刷新缓存）。</p>
<p>注意其中的<code>*</code>通配符，如果只需要替换一些文件中的源，请自行增删。</p>
<p>注意，如果需要启用其中一些 repo，需要将其中的 <code>enabled=0</code> 改为 <code>enabled=1</code>。</p>
<p><strong>※ 提醒：</strong> CentOS 6 及以下版本已被官网源下线, 若需使用, 请参考 CentOS-Vault 进行配置.</p>
<h3 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h3><p>CentOS官方地址：<a href="http://www.centos.org/">http://www.centos.org/</a></p>
<p>CentOS邮件列表地址：<a href="http://www.centos.org/modules/tinycontent/index.php?id=16">http://www.centos.org/modules/tinycontent/index.php?id=16</a></p>
<p>CentOS论坛地址：<a href="http://www.centos.org/modules/newbb/">http://www.centos.org/modules/newbb/</a></p>
<p>CentOS文档地址：<a href="http://www.centos.org/docs/">http://www.centos.org/docs/</a></p>
<p>CentOS Wiki地址：<a href="http://wiki.centos.org/">http://wiki.centos.org/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian 映像与镜像仓库</title>
    <url>/2019/12/31/Debian/</url>
    <content><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><table>
<thead>
<tr>
<th>映像</th>
<th>备注</th>
<th>镜像</th>
<th>镜像源地址</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/">官方映像</a></td>
<td>稳定版本</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://cdimage.debian.org/cdimage/archive/">官方映像列表</a></td>
<td>不包含最新版本</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="http://mirrors.aliyun.com/debian-cd/current/arm64/iso-dvd/">阿里云</a></td>
<td>稳定版本</td>
<td><a href="http://maven.aliyun.com/debian/">阿里云</a></td>
<td><a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com</a></td>
</tr>
<tr>
<td><a href="https://repo.huaweicloud.com/debian-cd/">华为</a></td>
<td>比较全</td>
<td><a href="https://repo.huaweicloud.com/debian/">华为</a></td>
<td><a href="https://repo.huaweicloud.com/">https://repo.huaweicloud.com</a></td>
</tr>
<tr>
<td><a href="http://mirrors.163.com/debian-cd/">网易</a></td>
<td>较新版本</td>
<td><a href="http://mirrors.163.com/debian/">网易</a></td>
<td><a href="http://mirrors.163.com/">http://mirrors.163.com</a></td>
</tr>
<tr>
<td><a href="http://mirrors.cloud.tencent.com/debian-cd/">腾讯</a></td>
<td>稳定版本</td>
<td><a href="http://mirrors.cloud.tencent.com/debian/">腾讯</a></td>
<td><a href="http://mirrors.cloud.tencent.com/">http://mirrors.cloud.tencent.com</a></td>
</tr>
<tr>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/debian-cd/current/arm64/iso-dvd/">清华大学</a></td>
<td>稳定版本</td>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/debian/">清华大学</a></td>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn</a></td>
</tr>
<tr>
<td><a href="http://mirror.lzu.edu.cn/debian-cd/">兰州大学</a></td>
<td>稳定版本</td>
<td><a href="http://mirror.lzu.edu.cn/debian/">兰州大学</a></td>
<td><a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn</a></td>
</tr>
<tr>
<td><a href="https://mirrors.ustc.edu.cn/debian-cd/current/arm64/iso-dvd/">中国科技大学</a></td>
<td>稳定版本</td>
<td><a href="https://mirrors.ustc.edu.cn/debian/">中国科技大学</a></td>
<td><a href="https://mirrors.ustc.edu.cn/">https://mirrors.ustc.edu.cn</a></td>
</tr>
<tr>
<td><a href="https://mirror.sjtu.edu.cn/debian-cd/">上海交大</a></td>
<td>稳定版本</td>
<td><a href="https://mirror.sjtu.edu.cn/debian">上海交大</a></td>
<td><a href="https://mirror.sjtu.edu.cn/">https://mirror.sjtu.edu.cn</a></td>
</tr>
</tbody></table>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>1、若需要使用<code>https</code>源，则需要执行<code>sudo apt-get install apt-transport-https ca-certificates</code>安装https源</p>
<p>2、备份配置文件：</p>
<p><code>sudo cp -a /etc/apt/sources.list /etc/apt/sources.list.bak</code></p>
<p>3、修改<strong>sources.list</strong>文件，将<code>http://deb.debian.org</code>替换成<code>https://repo.huaweicloud.com</code>，同时也将<code>http://security.debian.org</code>替换成<code>https://repo.huaweicloud.com</code> (可修改为上面的网址)，可以参考如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sed -i \</span><br><span class="line">-e &quot;s@http://deb.debian.org@https://repo.huaweicloud.com@g&quot; \</span><br><span class="line">-e &quot;s@http://security.debian.org@https://repo.huaweicloud.com@g&quot; \</span><br><span class="line">/etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>4、执行<code>apt-get update</code>更新索引</p>
<h3 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h3><p>Debian官网地址：<a href="http://www.debian.org/">http://www.debian.org/</a></p>
<p>Debian-Security官网地址：<a href="https://www.debian.org/security/">https://www.debian.org/security/</a></p>
<p>Debian安全追踪网址：<a href="https://security-tracker.debian.org/tracker/">https://security-tracker.debian.org/tracker/</a></p>
<p>Debian邮件列表地址：<a href="http://www.debian.org/support#mail_lists">http://www.debian.org/support#mail_lists</a></p>
<p>Debian文档地址：<a href="http://www.debian.org/doc/">http://www.debian.org/doc/</a></p>
<p>Debian Wiki地址：<a href="http://wiki.debian.org/">http://wiki.debian.org/</a></p>
<p>Debian镜像列表地址：<a href="http://www.debian.org/mirror/list">http://www.debian.org/mirror/list</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Debian</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 镜像仓库</title>
    <url>/2019/12/31/Docker/</url>
    <content><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><table>
<thead>
<tr>
<th>名称</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://hub-mirror.c.163.com/">网易</a></td>
<td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td>
</tr>
<tr>
<td><a href="https://docker.mirrors.ustc.edu.cn/">华中科技大学</a></td>
<td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td>
</tr>
<tr>
<td><a href="https://registry.docker-cn.com/">官方国内镜像</a></td>
<td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com/</a></td>
</tr>
</tbody></table>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><h5 id="修改配置文件加速站点"><a href="#修改配置文件加速站点" class="headerlink" title="修改配置文件加速站点"></a>修改配置文件加速站点</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;&lt;your accelerate address&gt;&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h3><p>Docker 仓库镜像:  <a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror">https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror</a></p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Software</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea 配置</title>
    <url>/2020/10/17/Idea%20%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Idea-配置"><a href="#Idea-配置" class="headerlink" title="Idea 配置"></a>Idea 配置</h1><h2 id="插件-Community"><a href="#插件-Community" class="headerlink" title="插件(Community)"></a>插件(Community)</h2><ol>
<li><p>Maven</p>
<p><a href="https://plugins.jetbrains.com/plugin/7179-maven-helper">Maven Helper</a></p>
</li>
<li><p>SQL</p>
<p><a href="https://plugins.jetbrains.com/plugin/12449-mybatis-builder">MyBatis Builder</a>  连接数据库；生产原始SQL</p>
<p><a href="https://plugins.jetbrains.com/plugin/10119-mybatisx">MyBatisX</a></p>
</li>
<li><p>Restful</p>
<p><a href="https://plugins.jetbrains.com/plugin/14280-restfultool">RestfulTool</a> 搜索接口路径；简单的 http 请求工具</p>
</li>
<li><p>其他</p>
<p><a href="https://plugins.jetbrains.com/plugin/8579-translation">Translation</a>  翻译</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 映像与镜像</title>
    <url>/2019/12/31/Linux/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>名称</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://maven.aliyun.com/">阿里云</a></td>
<td><a href="https://mirrors.aliyun.com/">https://mirrors.aliyun.com/</a></td>
</tr>
<tr>
<td><a href="https://repo.huaweicloud.com/">华为</a></td>
<td><a href="https://repo.huaweicloud.com/">https://repo.huaweicloud.com/</a></td>
</tr>
<tr>
<td><a href="http://mirrors.163.com/">网易</a></td>
<td><a href="http://mirrors.163.com/">http://mirrors.163.com/</a></td>
</tr>
<tr>
<td><a href="http://mirrors.cloud.tencent.com/">腾讯</a></td>
<td><a href="http://mirrors.cloud.tencent.com/">http://mirrors.cloud.tencent.com/</a></td>
</tr>
<tr>
<td><a href="http://mirrors.sohu.com/">搜狐</a></td>
<td><a href="http://mirrors.sohu.com/">http://mirrors.sohu.com/</a></td>
</tr>
<tr>
<td><a href="http://mirror.lzu.edu.cn/">兰州大学</a></td>
<td><a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn/</a></td>
</tr>
<tr>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学</a></td>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a></td>
</tr>
<tr>
<td><a href="http://mirror.hust.edu.cn/">华中科技大学</a></td>
<td><a href="http://mirror.hust.edu.cn/">http://mirror.hust.edu.cn/</a></td>
</tr>
<tr>
<td><a href="http://mirror.lzu.edu.cn/">兰州大学</a></td>
<td><a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn/</a></td>
</tr>
<tr>
<td><a href="https://mirror.sjtu.edu.cn/debian">上海交大</a></td>
<td><a href="https://mirror.sjtu.edu.cn/debian">https://mirror.sjtu.edu.cn/debian</a></td>
</tr>
<tr>
<td><a href="http://mirrors.ustc.edu.cn/">中国科技大学</a></td>
<td><a href="http://mirrors.ustc.edu.cn/">http://mirrors.ustc.edu.cn/</a></td>
</tr>
<tr>
<td><a href="http://mirror.bjtu.edu.cn/cn/">北京交通大学</a></td>
<td><a href="http://mirror.bjtu.edu.cn/cn/">http://mirror.bjtu.edu.cn/cn/</a></td>
</tr>
<tr>
<td><a href="http://mirror.bit.edu.cn/web/">北京理工大学</a></td>
<td><a href="http://mirror.bit.edu.cn/web/">http://mirror.bit.edu.cn/web/</a></td>
</tr>
<tr>
<td><a href="http://mirrors.neusoft.edu.cn/">大连东软信息学院</a></td>
<td><a href="http://mirrors.neusoft.edu.cn/">http://mirrors.neusoft.edu.cn/</a></td>
</tr>
<tr>
<td><a href="http://mirror.neu.edu.cn/">东北大学</a></td>
<td><a href="http://mirror.neu.edu.cn/">http://mirror.neu.edu.cn/</a></td>
</tr>
<tr>
<td><a href="http://mirror.dlut.edu.cn/">大连理工大学</a></td>
<td><a href="http://mirror.dlut.edu.cn/">http://mirror.dlut.edu.cn/</a></td>
</tr>
<tr>
<td><a href="http://mirrors.zju.edu.cn/">浙江大学</a></td>
<td><a href="http://mirrors.zju.edu.cn/">http://mirrors.zju.edu.cn/</a></td>
</tr>
<tr>
<td><a href="http://mirrors.cqu.edu.cn/">重庆大学</a></td>
<td><a href="http://mirrors.cqu.edu.cn/">http://mirrors.cqu.edu.cn/</a></td>
</tr>
<tr>
<td><a href="http://mirrors.nwsuaf.edu.cn/">西北农林科技大学</a></td>
<td><a href="http://mirrors.nwsuaf.edu.cn/">http://mirrors.nwsuaf.edu.cn/</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 重新安装回 Windows</title>
    <url>/2021/10/09/Linux%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E5%9B%9Ewindows/</url>
    <content><![CDATA[<p>1、制作U盘启动盘(Windows: rufus)</p>
<p>2、重新格式化磁盘</p>
<p>2.1 进入引导界面，并进入命令提示符</p>
<p>2.2 输入<code>diskpart</code>，进入DISKPART命令模式；</p>
<p>2.3 输入<code>list disk</code>，列出当前磁盘信息；</p>
<p>2.4 输入<code>select disk 0</code>，选择磁盘0；</p>
<p>2.5 输入<code>clean</code>，删除磁盘分区；</p>
<p>2.6 输入<code>convert gpt</code>，将磁盘转换为GPT；</p>
<p>2.7 输入<code>create partition efi size=320</code>(单位: M)，创建EFI</p>
<p>2.8 输入<code>create partition msr size=512</code>(单位: M)，创建Misrosoft保留分区</p>
<p>2.9 输入<code>create partition primary size = 102400</code>(单位: M)，创建100G的主分区，1G=1024M；这里的主分区相当于我们的C盘，大小可以随意指定，剩下的硬盘空间在安装完系统之后，进入系统在磁盘管理中可以自行分配；</p>
<p>2.10 输入<code>format fs=ntfs quick</code>回车，格式化主分区；windows磁盘的文件系统一般都是NTFS格式，所以这里我们要格式化为NTFS格式。看到显示【成功格式化该卷】的时候说明操作成功了。</p>
<p>3、重新进入引导界面</p>
<p>分区(总磁盘1T)</p>
<p>C盘（主分区）：122880M （120G）</p>
<p>D盘（Install）：153600M（150G）</p>
<p>E盘（Repository）：204800M（200G）</p>
<p>F盘（Data）：其他</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven、Gradle 镜像仓库</title>
    <url>/2019/12/31/Maven/</url>
    <content><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><table>
<thead>
<tr>
<th>名称</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://maven.aliyun.com/repository/public">阿里云</a></td>
<td><a href="http://mirrors.aliyun.com/debian/">http://mirrors.aliyun.com/debian/</a></td>
</tr>
<tr>
<td><a href="http://mirrors.163.com/maven/repository/maven-public/">网易</a></td>
<td><a href="http://mirrors.163.com/maven/repository/maven-public/">http://mirrors.163.com/maven/repository/maven-public/</a></td>
</tr>
<tr>
<td><a href="https://mirrors.huaweicloud.com/repository/maven/">华为</a></td>
<td><a href="https://mirrors.huaweicloud.com/repository/maven/">https://mirrors.huaweicloud.com/repository/maven/</a></td>
</tr>
<tr>
<td><a href="http://mirrors.cloud.tencent.com/nexus/repository/maven-public/">腾讯</a></td>
<td><a href="http://mirrors.cloud.tencent.com/nexus/repository/maven-public/">http://mirrors.cloud.tencent.com/nexus/repository/maven-public/</a></td>
</tr>
<tr>
<td><a href="https://maven.google.com/">Google</a></td>
<td><a href="https://maven.google.com/">https://maven.google.com/</a></td>
</tr>
</tbody></table>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><h5 id="Maven-配置"><a href="#Maven-配置" class="headerlink" title="Maven 配置"></a>Maven 配置</h5><p>打开 Maven 的配置文件(一般在maven安装目录的conf/settings.xml)，在<code>mirrors</code>标签中添加 mirror 子节点:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun public repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想使用其它代理仓库,可在<code>repositories</code>节点中加入对应的仓库使用地址。以使用spring代理仓为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 <strong>华为</strong> Maven 中央仓库时，需要在servers节点增加一个server子节点，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>huaweicloud<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>anonymous<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>devcloud<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Gradle-配置"><a href="#Gradle-配置" class="headerlink" title="Gradle 配置"></a>Gradle 配置</h3><p>在 build.gradle 文件中加入以下代码:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想使用 maven.aliyun.com 提供的其它代理仓，以使用 spring 仓为例，代码如下:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/spring/&#x27;</span>&#125;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h3><p>Maven官方地址：<a href="https://maven.apache.org/">https://maven.apache.org</a></p>
<p>Maven搜索地址：<a href="http://mvnrepository.com/">http://mvnrepository.com</a></p>
<p>Gradle官方地址：<a href="https://gradle.org/">https://gradle.org</a></p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Software</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Npm、Yarn 镜像仓库</title>
    <url>/2019/12/31/Npm/</url>
    <content><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><table>
<thead>
<tr>
<th>名称</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://registry.npm.taobao.org/">阿里云</a></td>
<td><a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></td>
</tr>
<tr>
<td><a href="https://repo.huaweicloud.com/repository/npm/">华为</a></td>
<td><a href="https://repo.huaweicloud.com/repository/npm/">https://repo.huaweicloud.com/repository/npm/</a></td>
</tr>
</tbody></table>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><h5 id="Npm-配置"><a href="#Npm-配置" class="headerlink" title="Npm 配置"></a>Npm 配置</h5><p>NPM的配置文件为用户家目录下的：<code>~/.npmrc</code>（Windows路径为：<code>C:\Users\&lt;UserName&gt;\.npmrc</code>），您可以点击此处直接下载配置文件，或者运行如下命令设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://repo.huaweicloud.com/repository/npm/</span><br><span class="line">npm cache clean -f</span><br></pre></td></tr></table></figure>



<h5 id="Yarn-配置"><a href="#Yarn-配置" class="headerlink" title="Yarn 配置"></a>Yarn 配置</h5><p>yarn的配置文件为用户根目录下的：<code>~/.yarnrc</code>（Windows路径为：<code>C:\Users\&lt;UserName&gt;\.yarnrc</code>），可执行如下命令设置镜像源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn config set registry https://repo.huaweicloud.com/repository/npm/</span><br></pre></td></tr></table></figure>





<h3 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h3><p>NPM官方地址：<a href="https://www.npmjs.com/">https://www.npmjs.com</a></p>
<p>NPM文档地址：<a href="https://docs.npmjs.com/">https://docs.npmjs.com</a></p>
<p>nodejs地址：<a href="https://nodejs.org/en">https://nodejs.org/en</a></p>
<p>io.js官方地址：<a href="https://iojs.org/zh">https://iojs.org/zh</a></p>
<p>Python官方地址：<a href="https://www.python.org/">https://www.python.org/</a></p>
<p>Electron官方地址：<a href="https://electronjs.org/">https://electronjs.org/</a></p>
<p>phantomJS官方地址：<a href="http://phantomjs.org/">http://phantomjs.org/</a></p>
<p>Node-Sass官方地址：<a href="https://github.com/sass/node-sass">https://github.com/sass/node-sass</a></p>
<p>Selenium官方地址：<a href="https://www.seleniumhq.org/https://gradle.org/">https://www.seleniumhq.org/https://gradle.org/</a>)</p>
<p>Node.js加速地址：<a href="https://repo.huaweicloud.com/nodejs/">https://repo.huaweicloud.com/nodejs/</a></p>
<p>io.js加速地址：<a href="https://repo.huaweicloud.com/iojs/">https://repo.huaweicloud.com/iojs/</a></p>
<p>Npm加速地址：<a href="https://repo.huaweicloud.com/npm-software/">https://repo.huaweicloud.com/npm-software/</a></p>
<p>yarn加速下载地址：<a href="https://repo.huaweicloud.com/yarn/">https://repo.huaweicloud.com/yarn/</a></p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Software</tag>
        <tag>Npm</tag>
        <tag>Yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 系列安装基本软件</title>
    <url>/2021/10/09/Ubuntu%20%E7%B3%BB%E5%88%97%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<ol>
<li><p>浏览器：chrome</p>
<p>   <a href="https://www.google.cn/chrome/">https://www.google.cn/chrome/</a></p>
</li>
</ol>
<p>​     </p>
<ol start="2">
<li><p>搜狗拼音输入法: <a href="https://pinyin.sogou.com/linux/">https://pinyin.sogou.com/linux/</a><br>  进入sougou的配置目录 $HOME/.config/sogoupinyin/conf/env.ini 找到StatusAppearance 设置为</p>
<pre><code>StatusAppearance=0  // 搜狗输入法隐藏状态栏
</code></pre>
</li>
<li><p>温度控制：sensors</p>
</li>
<li><p>下载工具：motrix<br> <a href="https://github.com/agalwood/Motrix">https://github.com/agalwood/Motrix</a></p>
</li>
<li><p>Markdown 编辑器：typora:</p>
<p><a href="https://typora.io/linux/Typora-linux-x64.tar.gz">https://typora.io/linux/Typora-linux-x64.tar.gz</a></p>
</li>
<li><p>启动器：uTools</p>
<p><a href="https://u.tools/">https://u.tools/</a></p>
</li>
<li><p>v2ray:<br> <a href="https://github.com/v2ray/v2ray-core/releases/">https://github.com/v2ray/v2ray-core/releases/</a><br>  <a href="https://github.com/Qv2ray/Qv2ray/releases/">https://github.com/Qv2ray/Qv2ray/releases/</a><br>  <a href="https://github.com/jiangxufeng/v2rayL/releases/">https://github.com/jiangxufeng/v2rayL/releases/</a></p>
</li>
<li><p>deepin-wine</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// https://github.com/zq1997/deepin-wine</span><br><span class="line">// 方案1</span><br><span class="line">sudo tee &quot;/etc/apt/sources.list.d/deepin-wine.list&quot; &gt;/dev/null &lt;&lt; &quot;EOF&quot;</span><br><span class="line">deb [trusted=yes] https://deepin-wine.i-m.dev /</span><br><span class="line">EOF</span><br><span class="line">// 方案2</span><br><span class="line">wget -O- https://deepin-wine.i-m.dev/setup.sh | sh </span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">// apt install ca-certificates // Linux 报错 Certificate verification failed: The certificate is NOT trusted.</span><br><span class="line">apt install -y com.qq.weixin.work.deepin    // 企业微信</span><br><span class="line">apt install -y com.qq.weixin.deepin    // 微信</span><br><span class="line">apt install -y com.qq.office.deepin         // TIM</span><br><span class="line">apt install -y com.tencent.meeting.deepin   // 腾讯会议</span><br></pre></td></tr></table></figure>

</li>
<li><p>DBeaver<br> <a href="https://dbeaver.io/download/">https://dbeaver.io/download/</a></p>
</li>
<li><p>IDEA<br><a href="https://www.jetbrains.com/idea/download/#section=linux">https://www.jetbrains.com/idea/download/#section=linux</a></p>
</li>
<li><p>Git Java Maven<br>  <a href="https://git-scm.com/download/linux">https://git-scm.com/download/linux</a><br>  <a href="https://openjdk.java.net/install/">https://openjdk.java.net/install/</a><br>  <a href="https://www.oracle.com/java/technologies/downloads/archive/">https://www.oracle.com/java/technologies/downloads/archive/</a><br>  <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
</li>
<li><p>主题：</p>
<p>图标：<a href="https://www.cinnamon-look.org/p/1366371/">https://www.cinnamon-look.org/p/1366371/</a></p>
</li>
<li><p>虚拟机：VirtualBox</p>
<p><a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a></p>
</li>
<li><p>油猴插件</p>
<ol>
<li> <a href="https://greasyfork.org/zh-CN/scripts/413063-%E7%94%B5%E8%84%91-%E6%89%8B%E6%9C%BA-%E5%85%A8%E7%BD%91%E5%94%AF%E4%B8%80%E5%85%A8%E8%87%AA%E5%8A%A8%E8%84%9A%E6%9C%AC-vip%E4%BC%9A%E5%91%98%E8%A7%86%E9%A2%91%E8%87%AA%E5%8A%A8%E8%A7%A3%E6%9E%90">https://greasyfork.org/zh-CN/scripts/413063-电脑-手机-全网唯一全自动脚本-vip会员视频自动解析</a></li>
</ol>
</li>
</ol>
<ol start="15">
<li><p>截图：flameshot</p>
<p><a href="https://github.com/flameshot-org/flameshot">https://github.com/flameshot-org/flameshot</a></p>
</li>
</ol>
<p>加快速度：github.com ==&gt; hub.fastgit.org</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 映像与镜像仓库</title>
    <url>/2019/12/31/Ubuntu/</url>
    <content><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><table>
<thead>
<tr>
<th>映像</th>
<th>备注</th>
<th>名称</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://cdimage.ubuntu.com/ubuntu/releases/">官方映像</a></td>
<td>较新版本</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://wiki.ubuntu.com/FocalFossa/ReleaseNotes">官方映像列表</a></td>
<td>较新版本</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="http://mirrors.aliyun.com/ubuntu-releases/">阿里云</a></td>
<td>较新版本</td>
<td><a href="http://maven.aliyun.com/ubuntu/">阿里云</a></td>
<td><a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com</a></td>
</tr>
<tr>
<td><a href="https://mirrors.huaweicloud.com/ubuntu-releases/">华为</a></td>
<td>较新版本</td>
<td><a href="https://repo.huaweicloud.com/ubuntu/">华为</a></td>
<td><a href="https://repo.huaweicloud.com/">https://repo.huaweicloud.com</a></td>
</tr>
<tr>
<td><a href="http://mirrors.163.com/ubuntu-releases/">网易</a></td>
<td>较新版本</td>
<td><a href="http://mirrors.163.com/ubuntu/">网易</a></td>
<td><a href="http://mirrors.163.com/">http://mirrors.163.com</a></td>
</tr>
<tr>
<td><a href="http://mirrors.cloud.tencent.com/ubuntu-releases/">腾讯</a></td>
<td>较新版本</td>
<td><a href="http://mirrors.cloud.tencent.com/ubuntu/">腾讯</a></td>
<td><a href="http://mirrors.cloud.tencent.com/">http://mirrors.cloud.tencent.com</a></td>
</tr>
<tr>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">清华大学</a></td>
<td>较新版本</td>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">清华大学</a></td>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn</a></td>
</tr>
<tr>
<td><a href="http://mirror.lzu.edu.cn/ubuntu-releases/">兰州大学</a></td>
<td>较新版本</td>
<td><a href="http://mirror.lzu.edu.cn/ubuntu/">兰州大学</a></td>
<td><a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn</a></td>
</tr>
<tr>
<td><a href="http://mirrors.ustc.edu.cn/ubuntu-releases/">中国科技大学</a></td>
<td>较新版本</td>
<td><a href="https://mirrors.ustc.edu.cn/ubuntu/">中国科技大学</a></td>
<td><a href="https://mirrors.ustc.edu.cn/">https://mirrors.ustc.edu.cn</a></td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td><a href="https://mirror.sjtu.edu.cn/ubuntu">上海交大</a></td>
<td><a href="https://mirror.sjtu.edu.cn/">https://mirror.sjtu.edu.cn</a></td>
</tr>
<tr>
<td><a href="http://mirrors.hust.edu.cn/ubuntu-releases/">华中科技大学</a></td>
<td>较新版本</td>
<td><a href="http://mirrors.hust.edu.cn/ubuntu/">华中科技大学</a></td>
<td><a href="http://mirrors.hust.edu.cn/">http://mirrors.hust.edu.cn</a></td>
</tr>
</tbody></table>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>1、备份配置文件：</p>
<p><code>sudo cp -a /etc/apt/sources.list /etc/apt/sources.list.bak</code></p>
<p>2、修改<strong>sources.list</strong>文件，将<code>http://archive.ubuntu.com</code>和<code>http://security.ubuntu.com</code>替换成<code>http://repo.huaweicloud.com</code>(可修改为上面的网址)，可以参考如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sed -i \</span><br><span class="line">-e &quot;s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g&quot; \</span><br><span class="line">-e &quot;s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g&quot; \</span><br><span class="line">/etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>3、执行<code>apt-get update</code>更新索引</p>
<h3 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h3><p>Ubuntu官方地址：<a href="http://www.ubuntu.com/">http://www.ubuntu.com/</a></p>
<p>Ubuntu论坛地址：<a href="http://ubuntuforums.org/">http://ubuntuforums.org/</a></p>
<p>Ubuntu Wiki地址：<a href="https://wiki.ubuntu.com/">https://wiki.ubuntu.com/</a></p>
<p>Ubuntu帮助地址：<a href="https://help.ubuntu.com/">https://help.ubuntu.com/</a></p>
<p>Ubuntu邮件列表地址：<a href="http://www.ubuntu.com/support/community/mailinglists">http://www.ubuntu.com/support/community/mailinglists</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows ISO镜像</title>
    <url>/2019/12/31/Windows/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>名称</th>
<th>网站</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://next.itellyou.cn/">MSDN (老版)</a></td>
<td><a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></td>
</tr>
<tr>
<td><a href="https://next.itellyou.cn/">MSDN (新版)</a></td>
<td><a href="https://next.itellyou.cn/">https://next.itellyou.cn/</a></td>
</tr>
<tr>
<td><a href="https://cnman.github.io/key.html">cnman (Github)</a></td>
<td><a href="https://cnman.github.io/key.html">https://cnman.github.io/key.html</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian 安装 MySQL</title>
    <url>/2019/12/31/Linux/Debian%20%E5%AE%89%E8%A3%85%20MySQL/</url>
    <content><![CDATA[<h1 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h1><h2 id="5-x-版本"><a href="#5-x-版本" class="headerlink" title="5.x 版本"></a>5.x 版本</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://dev.mysql.com/downloads/mysql/">官网</a><br><a href="https://repo.huaweicloud.com/mysql/Downloads/MySQL-5.7/">华为镜像</a>  没有最后版<br><a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/apt/debian/pool/mysql-5.7/m/mysql-community/">清华镜像</a>  仅仅提供当前版本5.x版本最后版<br><a href="http://mirrors.163.com/mysql_debian/pool/mysql-5.7/m/mysql-community/">网易镜像</a> 仅仅提供当前版本5.x版本最后版  </p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 若缺失, 可选择性安装</span></span><br><span class="line"><span class="comment"># apt install psmisc libaio1 libnuma1 libatomic1 libmecab2</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-common_5.<span class="number">7</span>.<span class="number">42</span>-<span class="number">1</span>debian10_amd64.deb</span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-community-client_5.<span class="number">7</span>.<span class="number">42</span>-<span class="number">1</span>debian10_amd64.deb</span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-client_5.<span class="number">7</span>.<span class="number">42</span>-<span class="number">1</span>debian10_amd64.deb</span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-community-server_5.<span class="number">7</span>.<span class="number">42</span>-<span class="number">1</span>debian10_amd64.deb</span><br><span class="line"><span class="comment"># 期间会提示输入密码, 并确认密码</span></span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-server_5.<span class="number">7</span>.<span class="number">42</span>-<span class="number">1</span>debian10_amd64.deb</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><h5 id="配置远程访问-并修改字符集"><a href="#配置远程访问-并修改字符集" class="headerlink" title="配置远程访问, 并修改字符集"></a>配置远程访问, 并修改字符集</h5><p>vim /etc/mysql/mysql.conf.d/mysqld.cnf</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">bind-address</span> =  <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="comment"># 修改服务器字符集，添加参数</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br></pre></td></tr></table></figure>

<h5 id="修改数据库root用户权限"><a href="#修改数据库root用户权限" class="headerlink" title="修改数据库root用户权限"></a>修改数据库root用户权限</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 执行语句允许远程访问(5.7.38版本(不包含)之前)</span><br><span class="line">GRANT ALL PRIVILEGES ON . TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;密码&#x27; WITH GRANT OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##### 执行语句允许远程访问（5.7.38版本(包含)之后）</span><br><span class="line">CREATE USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br><span class="line"># DROP USER &#x27;root&#x27;@&#x27;localhost&#x27;; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; WITH GRANT OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h2 id="8-x-版本"><a href="#8-x-版本" class="headerlink" title="8.x 版本"></a>8.x 版本</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p><a href="https://dev.mysql.com/downloads/mysql/">官网</a><br><a href="https://repo.huaweicloud.com/mysql/Downloads/MySQL-8.0/">华为镜像</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/apt/debian/pool/mysql-8.0/m/mysql-community/">清华镜像</a><br><a href="http://mirrors.163.com/mysql_debian/pool/mysql-8.0/m/mysql-community/">网易镜像</a>  </p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 若缺失, 可选择性安装</span></span><br><span class="line"><span class="comment"># apt install psmisc libaio1 libnuma1 libatomic1 libmecab2</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-common_8.<span class="number">0</span>.<span class="number">33</span>-<span class="number">1</span>debian10_amd64.deb</span><br><span class="line"><span class="comment"># 依次安装依赖组件及程序</span></span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-community-client-plugins_8.<span class="number">0</span>.<span class="number">33</span>-<span class="number">1</span>debian11_amd64.deb</span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-community-client-core_8.<span class="number">0</span>.<span class="number">33</span>-<span class="number">1</span>debian11_amd64.deb</span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-community-client_8.<span class="number">0</span>.<span class="number">33</span>-<span class="number">1</span>debian10_amd64.deb</span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-client_8.<span class="number">0</span>.<span class="number">33</span>-<span class="number">1</span>debian10_amd64.deb</span><br><span class="line"><span class="comment"># 安装依赖组件及程序</span></span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-community-server-core_8.<span class="number">0</span>.<span class="number">33</span>-<span class="number">1</span>debian11_amd64.deb</span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-community-server_8.<span class="number">0</span>.<span class="number">33</span>-<span class="number">1</span>debian10_amd64.deb</span><br><span class="line"><span class="comment"># 期间会提示输入密码, 并确认密码</span></span><br><span class="line"><span class="attribute">dpkg</span> -i mysql-server_8.<span class="number">0</span>.<span class="number">33</span>-<span class="number">1</span>debian10_amd64.deb</span><br></pre></td></tr></table></figure>

<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><h5 id="配置远程访问-并修改字符集-1"><a href="#配置远程访问-并修改字符集-1" class="headerlink" title="配置远程访问, 并修改字符集"></a>配置远程访问, 并修改字符集</h5><p>vim /etc/mysql/mysql.conf.d/mysqld.cnf</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">bind-address</span> =  <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="comment"># 修改服务器字符集，添加参数</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br></pre></td></tr></table></figure>

<h5 id="修改数据库用户权限"><a href="#修改数据库用户权限" class="headerlink" title="修改数据库用户权限"></a>修改数据库用户权限</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;myuser&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br><span class="line"># DROP USER &#x27;root&#x27;@&#x27;localhost&#x27;; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;myuser&#x27;@&#x27;%&#x27; WITH GRANT OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h1 id="APT-源"><a href="#APT-源" class="headerlink" title="APT 源"></a>APT 源</h1><p>脚本安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">mkdir $HOME/download</span><br><span class="line">wget https://dev.mysql.com/get/mysql-apt-config_0.8.13-1_all.deb  </span><br><span class="line">dpkg -i mysql-apt-config_0.8.13-1_all.deb</span><br><span class="line">if [ $? -ne 0 ] ; then</span><br><span class="line">    apt-get install lsb-release</span><br><span class="line">    dpkg -i mysql-apt-config_0.8.13-1_all.deb</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt-get install lsb-release  <span class="comment"># 若上一步安装失败，可能需要安装lsb-release</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dpkg -i mysql-apt-config_0.8.13-1_all.deb</span>  </span><br><span class="line"></span><br><span class="line">apt-get update  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt list | grep mysql-server	<span class="comment"># 查看版本</span></span></span><br><span class="line">apt-get install mysql-server</span><br></pre></td></tr></table></figure>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/mysql/">清华 APT 帮助文档</a></p>
]]></content>
      <categories>
        <category>Debian</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Debian</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 介绍</title>
    <url>/2020/10/17/Linux/Linux%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Linux-介绍"><a href="#Linux-介绍" class="headerlink" title="Linux 介绍"></a>Linux 介绍</h1><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><strong>/opt</strong>： 主要用于用户手工安装 GUI 或者便携程序目录 (不添加环境变量)</p>
<p><strong>/usr/local</strong>：主要用于用户手工安装自己编辑的程序或者非 GUI 程序 </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码学习</title>
    <url>/2020/11/26/Mybatis/Mybatis00/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MyBatis 源码系列对于新手来说是一个有趣且具有挑战性的学习项目。深入研究 MyBatis 源码将使您更好地理解 Java 持久性框架的内部工作原理，并提高编程技能。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><a href="../Mybatis01">Mybatis 源码之入门</a></p>
<p><a href="../Mybatis02">Mybatis 源码之加载配置</a></p>
<p><a href="../Mybatis04">Mybatis 源码之获取映射器类</a></p>
<p><a href="../Mybatis05">Mybatis 源码之 Mapper 实例</a></p>
<p><a href="../Mybatis05">Mybatis 源码之查询数据库</a></p>
<p><a href="../Mybatis06">Mybatis 源码之数据库结果集</a></p>
<p><a href="../Mybatis07">Mybatis 源码之更新数据库</a></p>
<p><a href="../Mybatis08">Mybatis 源码整合 Spring</a></p>
<p><a href="../Mybatis09">Mybatis 设计模式</a></p>
<p><strong>注: 源码相关版本</strong></p>
<ul>
<li><p>Mybatis: 3.5.8</p>
</li>
<li><p>Mybatis-Spring: 2.0.3</p>
</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://mybatis.org/mybatis-3/zh/index.html">官网</a><br><a href="https://github.com/mybatis/mybatis-3">源码</a><br><a href="https://mybatis.org/spring/zh/index.html">mybatis-Spring 官网</a><br><a href="https://github.com/mybatis/spring">mybatis-Spring 源码</a></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>源码</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码之入门</title>
    <url>/2020/11/26/Mybatis/Mybatis01/</url>
    <content><![CDATA[<h2 id="构建-SqlSessionFactory"><a href="#构建-SqlSessionFactory" class="headerlink" title="构建 SqlSessionFactory"></a>构建 SqlSessionFactory</h2><h3 id="从-XML-中构建"><a href="#从-XML-中构建" class="headerlink" title="从 XML 中构建"></a>从 XML 中构建</h3><p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 <code>file:// URL</code> 构造的输入流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure>

<h3 id="不使用-xml-构建"><a href="#不使用-xml-构建" class="headerlink" title="不使用 xml 构建"></a>不使用 xml 构建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line"><span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTransactionFactory</span>();</span><br><span class="line"><span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Environment</span>(<span class="string">&quot;development&quot;</span>, transactionFactory, dataSource);</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>(environment);</span><br><span class="line">configuration.addMapper(BlogMapper.class);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(configuration);</span><br></pre></td></tr></table></figure>

<h3 id="Spring-方式-构建"><a href="#Spring-方式-构建" class="headerlink" title="Spring 方式 构建"></a>Spring 方式 构建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">DataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构建省略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factoryBean.setDataSource(dataSource());</span><br><span class="line">        <span class="keyword">return</span> factoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h2><h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。<br>如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p>
<h4 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h4><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。<br>也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。<br>尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">    <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>源码</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码之加载配置</title>
    <url>/2020/11/26/Mybatis/Mybatis02/</url>
    <content><![CDATA[<h2 id="通过-SqlSessionFactoryBuilder-加载配置"><a href="#通过-SqlSessionFactoryBuilder-加载配置" class="headerlink" title="通过 SqlSessionFactoryBuilder 加载配置"></a>通过 SqlSessionFactoryBuilder 加载配置</h2><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.session.SqlSessionFactoryBuilder#build</code><br><strong>作用</strong>: 解析xml文件, 并生成配置项</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 准备工作：将配置文件加载到内存中并生成一个document对象 ，同时初始化Configuration对象</span></span><br><span class="line">    <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(inputStream, environment, properties);</span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xml文件解析器-XMLConfigBuilder"><a href="#xml文件解析器-XMLConfigBuilder" class="headerlink" title="xml文件解析器  XMLConfigBuilder"></a>xml文件解析器  <code>XMLConfigBuilder</code></h4><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.builder.xml.XMLConfigBuilder#XMLConfigBuilder</code><br><strong>作用</strong>: 解析 xml 配置文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(InputStream inputStream, String environment, Properties props)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">XPathParser</span>(inputStream, <span class="literal">true</span>, props, <span class="keyword">new</span> <span class="title class_">XMLMapperEntityResolver</span>()), environment, props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上面的6个构造函数最后都会合流到这个函数，传入XPathParser</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类初始化configuration</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">    <span class="comment">// 错误上下文设置成SQL Mapper Configuration(xml文件配置)</span></span><br><span class="line">    ErrorContext.instance().resource(<span class="string">&quot;SQL Mapper Configuration&quot;</span>);</span><br><span class="line">    <span class="comment">// 将Properties全部设置到configuration里面去</span></span><br><span class="line">    <span class="built_in">this</span>.configuration.setVariables(props);</span><br><span class="line">    <span class="built_in">this</span>.parsed = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.environment = environment;</span><br><span class="line">    <span class="built_in">this</span>.parser = parser;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析配置</span></span><br><span class="line">  <span class="keyword">public</span> Configuration <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 根据parsed变量的值判断是否已经完成了对mybatis-config.xml配置文件的解析</span></span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    parsed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 在mybatis-config.xml配置文件中查找&lt;configuration&gt;节点，并开始解析</span></span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 解析配置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// issue #117 read properties first</span></span><br><span class="line">      <span class="comment">// 解析properties</span></span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">      <span class="comment">// 解析settings</span></span><br><span class="line">      <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">      <span class="comment">// 设置vfsImpl字段</span></span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      <span class="comment">// 解析类型别名</span></span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">      <span class="comment">// 解析插件</span></span><br><span class="line">      pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">      <span class="comment">// 对象工厂</span></span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">      <span class="comment">// 对象包装工厂</span></span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">      <span class="comment">// 反射工厂</span></span><br><span class="line">      reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">      settingsElement(settings);<span class="comment">//设置具体的属性到configuration对象</span></span><br><span class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      <span class="comment">// 环境</span></span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">      <span class="comment">// databaseIdProvider</span></span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">      <span class="comment">// 类型处理器</span></span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">      <span class="comment">// 映射器</span></span><br><span class="line">      mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 未指定XMLConfigBuilder.environment字段，则使用default属性</span></span><br><span class="line">      <span class="keyword">if</span> (environment == <span class="literal">null</span>) &#123;</span><br><span class="line">        environment = context.getStringAttribute(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 遍历子节点</span></span><br><span class="line">      <span class="keyword">for</span> (XNode child : context.getChildren()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="comment">// 与XmlConfigBuilder.environment字段匹配</span></span><br><span class="line">        <span class="keyword">if</span> (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">          <span class="comment">// 创建TransactionFactory</span></span><br><span class="line">          <span class="type">TransactionFactory</span> <span class="variable">txFactory</span> <span class="operator">=</span> transactionManagerElement(child.evalNode(<span class="string">&quot;transactionManager&quot;</span>));</span><br><span class="line">          <span class="comment">// 创建DataSourceFactory和DataSource</span></span><br><span class="line">          <span class="type">DataSourceFactory</span> <span class="variable">dsFactory</span> <span class="operator">=</span> dataSourceElement(child.evalNode(<span class="string">&quot;dataSource&quot;</span>));</span><br><span class="line">          <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> dsFactory.getDataSource();</span><br><span class="line">          <span class="comment">// 创建Environment</span></span><br><span class="line">          Environment.<span class="type">Builder</span> <span class="variable">environmentBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Environment</span>.Builder(id)</span><br><span class="line">              .transactionFactory(txFactory)</span><br><span class="line">              .dataSource(dataSource);</span><br><span class="line">          <span class="comment">// 将Environment对象记录到Configuration.environment字段中</span></span><br><span class="line">          configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> DataSourceFactory <span class="title function_">dataSourceElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">      <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">      <span class="comment">// 根据type=&quot;POOLED&quot;解析返回适当的DataSourceFactory</span></span><br><span class="line">      <span class="type">DataSourceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (DataSourceFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">      factory.setProperties(props);</span><br><span class="line">      <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Environment declaration requires a DataSourceFactory.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理mapper子节点</span></span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="comment">// package子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">          <span class="comment">// 自动扫描包下所有映射器</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">mapperPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">          <span class="comment">// 扫描指定的包，并向mapperRegistry注册mapper接口</span></span><br><span class="line">          configuration.addMappers(mapperPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 获取mapper节点的resource、url、class属性，三个属性互斥</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">          <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">          <span class="type">String</span> <span class="variable">mapperClass</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">          <span class="comment">// 如果mapper节点指定了resource或者url属性，则创建XmlMapperBuilder对象，并通过该对象解析resource或者url属性指定的mapper配置文件</span></span><br><span class="line">          <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用类路径</span></span><br><span class="line">            ErrorContext.instance().resource(resource);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource)) &#123;</span><br><span class="line">              <span class="comment">// 创建XMLMapperBuilder对象，解析映射配置文件</span></span><br><span class="line">              <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">              mapperParser.parse();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用绝对url路径</span></span><br><span class="line">            ErrorContext.instance().resource(url);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getUrlAsStream(url)) &#123;</span><br><span class="line">              <span class="comment">// 创建XMLMapperBuilder对象，解析映射配置文件</span></span><br><span class="line">              <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">              mapperParser.parse();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果mapper节点指定了class属性，则向MapperRegistry注册该mapper接口</span></span><br><span class="line">            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">            <span class="comment">// 直接把这个映射加入配置</span></span><br><span class="line">            configuration.addMapper(mapperInterface);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mapper-解析器"><a href="#Mapper-解析器" class="headerlink" title="Mapper 解析器"></a>Mapper 解析器</h4><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.builder.xml.XMLMapperBuilder</code><br><strong>作用</strong>: 用户解析 mapper 节点, 并封装成 Mapper 配置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 判断是否已经加载过该映射文件</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">// 处理mapper节点</span></span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">    <span class="comment">// 将resource添加到Configuration.loadedResources集合中保存，他是hashset类型的集合，其中记录了已经加载过的映射文件</span></span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">// 绑定映射器到namespace</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理ConfigurationElement方法中解析失败的resultMap节点</span></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  <span class="comment">// 处理ConfigurationElement方法中解析失败的cache-ref节点</span></span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  <span class="comment">// 处理ConfigurationElement方法中解析失败的SQL语句节点</span></span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Mybatis-配置项-Configuration"><a href="#Mybatis-配置项-Configuration" class="headerlink" title="Mybatis 配置项 Configuration"></a>Mybatis 配置项 <code>Configuration</code></h4><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.session.Configuration#Configuration</code><br><strong>作用</strong>: 解析后的参数配置项</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> &#123;</span><br><span class="line">    <span class="comment">// 脚本语言注册器</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">LanguageDriverRegistry</span> <span class="variable">languageRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LanguageDriverRegistry</span>();</span><br><span class="line">    <span class="comment">//类型别名注册机</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">TypeAliasRegistry</span> <span class="variable">typeAliasRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeAliasRegistry</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Configuration</span><span class="params">()</span> &#123;</span><br><span class="line">        typeAliasRegistry.registerAlias(<span class="string">&quot;JDBC&quot;</span>, JdbcTransactionFactory.class);</span><br><span class="line">        typeAliasRegistry.registerAlias(<span class="string">&quot;MANAGED&quot;</span>, ManagedTransactionFactory.class);</span><br><span class="line">        <span class="comment">// 。。。  省略别名注册</span></span><br><span class="line"></span><br><span class="line">        languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class);</span><br><span class="line">        languageRegistry.register(RawLanguageDriver.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>源码</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码之获取映射器类</title>
    <url>/2020/11/26/Mybatis/Mybatis03/</url>
    <content><![CDATA[<h2 id="获取-SqlSession-对象"><a href="#获取-SqlSession-对象" class="headerlink" title="获取 SqlSession 对象"></a>获取 SqlSession 对象</h2><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.session.SqlSessionFactory#openSession</code><br><strong>作用</strong>: 创建 SqlSession 实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">  <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 mybatis-config.xml 配置文件中配置的 Environment 对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> configuration.getEnvironment();</span><br><span class="line">    <span class="comment">// 获取 TransactionFactory 对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    <span class="comment">// 创建 Transaction 对象</span></span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="comment">// 根据配置创建 Executor 对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> configuration.newExecutor(tx, execType);</span><br><span class="line">    <span class="comment">// 然后产生一个 DefaultSqlSession</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//如果打开事务出错，则关闭它</span></span><br><span class="line">    closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//最后清空错误上下文</span></span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromConnection</span><span class="params">(ExecutorType execType, Connection connection)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> autoCommit;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取当前连接的事务是否为自动提交方法</span></span><br><span class="line">      autoCommit = connection.getAutoCommit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="comment">// Failover to true, as most poor drivers</span></span><br><span class="line">      <span class="comment">// or databases won&#x27;t support transactions</span></span><br><span class="line">      <span class="comment">// 当前数据库驱动提供的连接不支持事务，则可能会抛出异常</span></span><br><span class="line">      autoCommit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 mybatis-config.xml 配置文件中配置的 Environment 对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> configuration.getEnvironment();</span><br><span class="line">    <span class="comment">// 获取 TransactionFactory 对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    <span class="comment">// 创建 Transaction 对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> transactionFactory.newTransaction(connection);</span><br><span class="line">    <span class="comment">// 根据配置创建 Executor 对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> configuration.newExecutor(tx, execType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建执行器"><a href="#创建执行器" class="headerlink" title="创建执行器"></a>创建执行器</h3><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.session.Configuration#newExecutor</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产生执行器</span></span><br><span class="line"><span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">  executorType = executorType == <span class="literal">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="literal">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="comment">// 根据参数，选择合适的 Executor 实现</span></span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">BatchExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">ReuseExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据配置决定是否开启二级缓存的功能</span></span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    <span class="comment">// 装饰器模式</span></span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此处引入插件, 通过插件可以改变 Executor 行为</span></span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="DefaultSqlSession-对象"><a href="#DefaultSqlSession-对象" class="headerlink" title="DefaultSqlSession 对象"></a>DefaultSqlSession 对象</h3><p><code>DefaultSqlSession</code> 实现了 <code>SqlSession</code> 接口的所有方法，包括对数据库的增删改查、事务管理等功能。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>源码</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码之 Mapper 实例</title>
    <url>/2020/11/26/Mybatis/Mybatis04/</url>
    <content><![CDATA[<h2 id="获取-Mapper-实列"><a href="#获取-Mapper-实列" class="headerlink" title="获取 Mapper 实列"></a>获取 Mapper 实列</h2><blockquote>
<p><strong>作用</strong>: 通过 SqlSession 对象, 查找当前 Mybatis 的 mapper 注册中心指定的 Mapper 类型, 单据 Mapper工厂, 通过工厂创建 Mapper 实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.ibatis.session.defaults.DefaultSqlSession#getMapper</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;  </span><br><span class="line">  <span class="comment">//最后会去调用MapperRegistry.getMapper  </span></span><br><span class="line">  <span class="keyword">return</span> configuration.getMapper(type, <span class="built_in">this</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.ibatis.binding.MapperRegistry#getMapper</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="comment">// 查找指定type对应MapperProxyFactory对象</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="comment">// 如果mapperProxyFactory为空，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建实现了type接口的代理对象</span></span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// org.apache.ibatis.binding.MapperProxyFactory#newInstance</span></span><br><span class="line">  <span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建实现了mapperInterface接口的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// org.apache.ibatis.binding.MapperProxyFactory#newInstance</span></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建MapperProxy对象，每次调用都会创建新的mapperProxy对象</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h3><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.binding.MapperProxy</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">4724728412955527868L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ALLOWED_MODES</span> <span class="operator">=</span> MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED</span><br><span class="line">      | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Constructor&lt;Lookup&gt; lookupConstructor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method privateLookupInMethod;</span><br><span class="line">  <span class="comment">// 记录了关联的sqlSession对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="comment">// mapper接口对应的Class对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="comment">// 用于缓存MapperMethod对象，其中key是mapper接口中方法对应的Method对象，value是对应的MapperMethod对象,MapperMethod对象会完成参数转换</span></span><br><span class="line">  <span class="comment">// 以及SQL语句的执行功能，需要注意的是，MapperMethod中并不记录任何状态相关的信息，所以可以在多个代理对象之间共享</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethodInvoker&gt; methodCache;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethodInvoker&gt; methodCache)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="built_in">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    Method privateLookupIn;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// jdk9 以上的私有方法处理</span></span><br><span class="line">      <span class="comment">// privateLookupInMethod 判断MethodHandles类中是否有privateLookupIn方法，该方法是java9中才有的</span></span><br><span class="line">      privateLookupIn = MethodHandles.class.getMethod(<span class="string">&quot;privateLookupIn&quot;</span>, Class.class, MethodHandles.Lookup.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      privateLookupIn = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    privateLookupInMethod = privateLookupIn;</span><br><span class="line"></span><br><span class="line">    Constructor&lt;Lookup&gt; lookup = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (privateLookupInMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// JDK8 私有方法</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        lookup = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, <span class="type">int</span>.class);</span><br><span class="line">        lookup.setAccessible(<span class="literal">true</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;There is neither &#x27;privateLookupIn(Class, Lookup)&#x27; nor &#x27;Lookup(Class, int)&#x27; method in java.lang.invoke.MethodHandles.&quot;</span>,</span><br><span class="line">            e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        lookup = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lookupConstructor = lookup;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Mapper-实例对象执行查询"><a href="#Mapper-实例对象执行查询" class="headerlink" title="Mapper 实例对象执行查询"></a>Mapper 实例对象执行查询</h2><p>在拿到 Mapper 实例后，直接调用查询接口 <code>Emp emp = mapper.findEmpByEmpno(1);</code>, 实际上调用了其代理对象 MapperProxy 的 invoke 方法。</p>
<blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.binding.MapperProxy#invoke</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果目标方法继承自Object,则直接调用目标方法</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 根据被调用接口方法的method对象，从缓存中获取MapperMethodInvoker对象，如果没有则创建一个并放入缓存，然后调用invoke</span></span><br><span class="line">      <span class="keyword">return</span> cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取缓存中MapperMethodInvoker,如果没有则创建一个，而MapperMethodInvoker内部封装这一个MethodHandler</span></span><br><span class="line"><span class="keyword">private</span> MapperMethodInvoker <span class="title function_">cachedInvoker</span><span class="params">(Method method)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MapUtil.computeIfAbsent(methodCache, method, m -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (m.isDefault()) &#123;</span><br><span class="line">        <span class="comment">// 如果调用接口的是默认方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (privateLookupInMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultMethodInvoker</span>(getMethodHandleJava8(method));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultMethodInvoker</span>(getMethodHandleJava9(method));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException | InvocationTargetException</span><br><span class="line">            | NoSuchMethodException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果调用的普通方法(接口)，则创建一个 PlainMethodInvoker 并放入缓存，其中 MapperMethod 保存对应接口方法的 SQL 以及入参和出参的数据类型等信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PlainMethodInvoker</span>(<span class="keyword">new</span> <span class="title class_">MapperMethod</span>(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> re.getCause();</span><br><span class="line">    <span class="keyword">throw</span> cause == <span class="literal">null</span> ? re : cause;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="创建-MapperMethod"><a href="#创建-MapperMethod" class="headerlink" title="创建 MapperMethod"></a>创建 MapperMethod</h3><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.binding.MapperMethod</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MapperMethod 构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> &#123;  </span><br><span class="line">  <span class="comment">// 记录了 SQL 语句的名称和类型</span></span><br><span class="line">  <span class="built_in">this</span>.command = <span class="keyword">new</span> <span class="title class_">SqlCommand</span>(config, mapperInterface, method);</span><br><span class="line">  <span class="comment">// Mapper 接口中对应方法的相关信息(如参数列表, 返回值)</span></span><br><span class="line">  <span class="built_in">this</span>.method = <span class="keyword">new</span> <span class="title class_">MethodSignature</span>(config, mapperInterface, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建-SqlCommand"><a href="#创建-SqlCommand" class="headerlink" title="创建 SqlCommand"></a>创建 SqlCommand</h4><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.binding.MapperMethod$SqlCommand</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="title function_">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">    <span class="comment">// 从配置中获取 MappedStatement</span></span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> resolveMappedStatement(mapperInterface, methodName, declaringClass, configuration);</span><br><span class="line">    <span class="keyword">if</span> (ms == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理@Flush注解</span></span><br><span class="line">      <span class="keyword">if</span> (method.getAnnotation(Flush.class) != <span class="literal">null</span>) &#123;</span><br><span class="line">        name = <span class="literal">null</span>;</span><br><span class="line">        type = SqlCommandType.FLUSH;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Invalid bound statement (not found): &quot;</span></span><br><span class="line">            + mapperInterface.getName() + <span class="string">&quot;.&quot;</span> + methodName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化name和type</span></span><br><span class="line">      name = ms.getId();</span><br><span class="line">      type = ms.getSqlCommandType();</span><br><span class="line">      <span class="keyword">if</span> (type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Unknown execution method for: &quot;</span> + name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析 MappedStatement</span></span><br><span class="line">  <span class="keyword">private</span> MappedStatement <span class="title function_">resolveMappedStatement</span><span class="params">(Class&lt;?&gt; mapperInterface, String methodName,</span></span><br><span class="line"><span class="params">      Class&lt;?&gt; declaringClass, Configuration configuration)</span> &#123;</span><br><span class="line">    <span class="comment">// SQL语句的名称是由Mapper接口的名称与对应的方法名称组成的</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">statementId</span> <span class="operator">=</span> mapperInterface.getName() + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">    <span class="comment">// 检测是否有该名称的SQL语句</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasStatement(statementId)) &#123;</span><br><span class="line">      <span class="comment">// 从configuration.mappedStatements集合中查找对应的MappedStatement对象，MappedStatement对象中封装了SQL语句相关的信息，在mybatis初始化时创建</span></span><br><span class="line">      <span class="keyword">return</span> configuration.getMappedStatement(statementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mapperInterface.equals(declaringClass)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理 Mapper 对象的所有接口</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (declaringClass.isAssignableFrom(superInterface)) &#123;</span><br><span class="line">        <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> resolveMappedStatement(superInterface, methodName,</span><br><span class="line">            declaringClass, configuration);</span><br><span class="line">        <span class="keyword">if</span> (ms != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> ms;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建-MethodSignature"><a href="#创建-MethodSignature" class="headerlink" title="创建 MethodSignature"></a>创建 MethodSignature</h4><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.binding.MapperMethod$MethodSignature</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MethodSignature</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> &#123;</span><br><span class="line">     <span class="comment">// 解析方法的返回值类型</span></span><br><span class="line">     <span class="type">Type</span> <span class="variable">resolvedReturnType</span> <span class="operator">=</span> TypeParameterResolver.resolveReturnType(method, mapperInterface);</span><br><span class="line">     <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line">       <span class="built_in">this</span>.returnType = (Class&lt;?&gt;) resolvedReturnType;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">       <span class="built_in">this</span>.returnType = (Class&lt;?&gt;) ((ParameterizedType) resolvedReturnType).getRawType();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.returnType = method.getReturnType();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 初始化returnsVoid、returnsMany、returnsCursor、returnsOptional等参数</span></span><br><span class="line">     <span class="built_in">this</span>.returnsVoid = <span class="keyword">void</span>.class.equals(<span class="built_in">this</span>.returnType);</span><br><span class="line">     <span class="built_in">this</span>.returnsMany = configuration.getObjectFactory().isCollection(<span class="built_in">this</span>.returnType) || <span class="built_in">this</span>.returnType.isArray();</span><br><span class="line">     <span class="built_in">this</span>.returnsCursor = Cursor.class.equals(<span class="built_in">this</span>.returnType);</span><br><span class="line">     <span class="built_in">this</span>.returnsOptional = Optional.class.equals(<span class="built_in">this</span>.returnType);</span><br><span class="line">     <span class="comment">// 若MethodSignature对应方法的返回值是Map且制定了@MapKey注解，则使用getMapKey方法处理</span></span><br><span class="line">     <span class="built_in">this</span>.mapKey = getMapKey(method);</span><br><span class="line">     <span class="built_in">this</span>.returnsMap = <span class="built_in">this</span>.mapKey != <span class="literal">null</span>;</span><br><span class="line">     <span class="comment">// 初始化rowBoundsIndex、resultHandlerIndex字段</span></span><br><span class="line">     <span class="built_in">this</span>.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);</span><br><span class="line">     <span class="built_in">this</span>.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);</span><br><span class="line">     <span class="comment">// 创建参数名称解析器, 给参数列表命名</span></span><br><span class="line">     <span class="built_in">this</span>.paramNameResolver = <span class="keyword">new</span> <span class="title class_">ParamNameResolver</span>(configuration, method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getMapKey</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">mapKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (Map.class.isAssignableFrom(method.getReturnType())) &#123;</span><br><span class="line">       <span class="comment">// 如果返回类型是map类型，查看该method是否有MapKey注解，如果有，则将这个注解的值作为map的key</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">MapKey</span> <span class="variable">mapKeyAnnotation</span> <span class="operator">=</span> method.getAnnotation(MapKey.class);</span><br><span class="line">       <span class="keyword">if</span> (mapKeyAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">         mapKey = mapKeyAnnotation.value();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mapKey;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Integer <span class="title function_">getUniqueParamIndex</span><span class="params">(Method method, Class&lt;?&gt; paramType)</span> &#123;</span><br><span class="line">   <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] argTypes = method.getParameterTypes();</span><br><span class="line">   <span class="comment">// 遍历MethodSignature对应的方法的参数列表</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line"> 	<span class="comment">// 记录paramType类型参数在参数列表中的位置索引</span></span><br><span class="line"> 	<span class="keyword">if</span> (paramType.isAssignableFrom(argTypes[i])) &#123;</span><br><span class="line"> 	  <span class="keyword">if</span> (index == <span class="literal">null</span>) &#123;</span><br><span class="line"> 		index = i;</span><br><span class="line"> 		<span class="comment">// RowBounds和ResultHandler类型的参数只能有一个，不能重复出现</span></span><br><span class="line"> 	  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(method.getName() + <span class="string">&quot; cannot have multiple &quot;</span> + paramType.getSimpleName() + <span class="string">&quot; parameters&quot;</span>);</span><br><span class="line"> 	  &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="创建-MethodSignature-1"><a href="#创建-MethodSignature-1" class="headerlink" title="创建 MethodSignature"></a>创建 MethodSignature</h4><p><strong>定位</strong>: <code>org.apache.ibatis.reflection.ParamNameResolver</code><br><strong>作用</strong>:  解析 Mapper 接口方法的参数列表的名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * aMethod(<span class="doctag">@Param</span>(&quot;M&quot;) int a, <span class="doctag">@Param</span>(&quot;N&quot;) int b) -&gt; &#123;&#123;0, &quot;M&quot;&#125;, &#123;1, &quot;N&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment"> * aMethod(int a, int b) -&gt; &#123;&#123;0, &quot;0&quot;&#125;, &#123;1, &quot;1&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment"> * aMethod(int a, RowBounds rb, int b) -&gt; &#123;&#123;0, &quot;0&quot;&#125;, &#123;2, &quot;1&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; names;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.useActualParamName = config.isUseActualParamName();</span><br><span class="line">  <span class="comment">// 获取参数列表中每个参数的类型</span></span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">  <span class="comment">// 获取参数列表上的注解</span></span><br><span class="line">  <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="comment">// 该集合用于记录参数索引与参数名称的对应关系</span></span><br><span class="line">  <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">  <span class="type">int</span> <span class="variable">paramCount</span> <span class="operator">=</span> paramAnnotations.length;</span><br><span class="line">  <span class="comment">// get names from @Param annotations</span></span><br><span class="line">  <span class="comment">// 遍历方法所有参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">paramIndex</span> <span class="operator">=</span> <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">      <span class="comment">// skip special parameters</span></span><br><span class="line">      <span class="comment">// 如果参数是 RowBounds 类型或 ResultHandler 类型，则跳过对该参数的分析</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历该参数对应的注解集合</span></span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">        <span class="comment">// @Param 注解出现过一次，就将 hasParamAnnotation 初始化为 true</span></span><br><span class="line">        hasParamAnnotation = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 获取 @Param 注解指定的参数名称</span></span><br><span class="line">        name = ((Param) annotation).value();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// @Param was not specified.</span></span><br><span class="line">      <span class="comment">// 该参数没有对应的 @Param 注解，则根据配置决定是否使用参数实际名称作为其名称</span></span><br><span class="line">      <span class="keyword">if</span> (useActualParamName) &#123;</span><br><span class="line">        name = getActualParamName(method, paramIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)</span></span><br><span class="line">        <span class="comment">// gcode issue #71</span></span><br><span class="line">        <span class="comment">// 使用参数的索引作为其名称</span></span><br><span class="line">        name = String.valueOf(map.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录到map中保存</span></span><br><span class="line">    map.put(paramIndex, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化name集合</span></span><br><span class="line">  names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getNamedParams</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">paramCount</span> <span class="operator">=</span> names.size();</span><br><span class="line">  <span class="comment">// 五参数，返回null</span></span><br><span class="line">  <span class="keyword">if</span> (args == <span class="literal">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 未使用@Param且只有一个参数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果只有一个参数</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> args[names.firstKey()];</span><br><span class="line">    <span class="keyword">return</span> wrapToMapIfCollection(value, useActualParamName ? names.get(<span class="number">0</span>) : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 处理使用@Param注解指定了参数名称或者多个参数的情况</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// param这个map记录了参数名称与实参之间的对应关系，ParamMap继承了HashMap，如果向paramMap中添加已经存在的key，会报错，</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> <span class="title class_">ParamMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">      <span class="comment">// 将参数名称与实参对应关系记录到param中</span></span><br><span class="line">      param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">      <span class="comment">// add generic param names (param1, param2, ...)</span></span><br><span class="line">      <span class="comment">// 为参数创建param+索引格式的默认参数名称，并添加到param集合中</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">genericParamName</span> <span class="operator">=</span> GENERIC_NAME_PREFIX + (i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line">      <span class="comment">// 如果@param注解指定的参数名称就是param+索引格式的，则不需要添加</span></span><br><span class="line">      <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">        <span class="comment">// 再加一个#&#123;param1&#125;,#&#123;param2&#125;...参数</span></span><br><span class="line">        <span class="comment">//你可以传递多个参数给一个映射器方法。如果你这样做了,</span></span><br><span class="line">        <span class="comment">//默认情况下它们将会以它们在参数列表中的位置来命名,比如:#&#123;param1&#125;,#&#123;param2&#125;等。</span></span><br><span class="line">        <span class="comment">//如果你想改变参数的名称(只在多参数情况下) ,那么你可以在参数上使用@Param(“paramName”)注解。</span></span><br><span class="line">        param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="执行-MapperMethod"><a href="#执行-MapperMethod" class="headerlink" title="执行 MapperMethod"></a>执行 MapperMethod</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> &#123;</span><br><span class="line">  Object result;</span><br><span class="line">  <span class="comment">// 根据SQL语句的类型调用SqlSession对应的方法</span></span><br><span class="line">  <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      <span class="comment">// 使用 ParamNameResolver 处理 args 数组，将用户传入的实参与指定参数名称关联起来</span></span><br><span class="line">      <span class="comment">// org.apache.ibatis.reflection.ParamNameResolver#getNamedParams</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      <span class="comment">// 调用sqlSession.insert方法，rowCountResult方法会根据method字段中记录的方法的返回值类型对结果进行转换</span></span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SELECT:</span><br><span class="line">      <span class="comment">// 处理返回值为void是ResultSet通过ResultHandler处理的方法</span></span><br><span class="line">      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        <span class="comment">// 如果有结果处理器</span></span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 处理返回值为集合和数组的方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">        <span class="comment">// 如果结果有多条记录</span></span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">        <span class="comment">// 处理返回值为map的方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">        <span class="comment">// 如果结果是map</span></span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">        <span class="comment">// 处理返回值为cursor的方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">        result = executeForCursor(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理返回值为单一对象的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">            &amp;&amp; (result == <span class="literal">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">          result = Optional.ofNullable(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLUSH:</span><br><span class="line">      result = sqlSession.flushStatements();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName()</span><br><span class="line">        + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此方法对返回值的类型进行安全检查</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">rowCountResult</span><span class="params">(<span class="type">int</span> rowCount)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Object result;</span><br><span class="line">  <span class="keyword">if</span> (method.returnsVoid()) &#123;</span><br><span class="line">    <span class="comment">// Mapper接口中相应方法的返回值为void</span></span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.class.equals(method.getReturnType()) || Integer.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    <span class="comment">// mapper接口中相应方法的返回值为int或者Integer</span></span><br><span class="line">    result = rowCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Long.class.equals(method.getReturnType()) || Long.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    <span class="comment">// mapper接口中相应方法的返回值为long或者Long</span></span><br><span class="line">    result = (<span class="type">long</span>) rowCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Boolean.class.equals(method.getReturnType()) || Boolean.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    <span class="comment">// mapper接口中相应方法的返回值为boolean或者Boolean</span></span><br><span class="line">    result = rowCount &gt; <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 以上条件都不成立，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName() + <span class="string">&quot;&#x27; has an unsupported return type: &quot;</span> + method.getReturnType());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>源码</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码之查询数据库</title>
    <url>/2020/11/26/Mybatis/Mybatis05/</url>
    <content><![CDATA[<p> 主要研究 DefaultSqlSession 对象的查询方法</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><a href="https://www.processon.com/view/link/655092a17b996f7b645b648d">https://www.processon.com/view/link/655092a17b996f7b645b648d</a></p>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="width:489px; height:275px;" src="https://www.processon.com/embed/65507926d8ae0c383514f124"></iframe>

<h2 id="多行查询"><a href="#多行查询" class="headerlink" title="多行查询"></a>多行查询</h2><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.session.defaults.DefaultSqlSession#selectList</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>: 根据条件查询, 返回 list 集合</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> selectList(statement, parameter, rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 核心selectList</span></span><br><span class="line"> <span class="keyword">private</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 根据 statement id 找到对应的 MappedStatement</span></span><br><span class="line">     <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">     <span class="comment">// 转用执行器来查询结果, 注意这里传入的 ResultHandler 是 null</span></span><br><span class="line">     <span class="comment">// 如果存在插件, 即(executor 被代理), 则会执行 org.apache.ibatis.plugin.Plugin#invoke</span></span><br><span class="line">     <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, handler);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// 清空错误上下文</span></span><br><span class="line">     ErrorContext.instance().reset();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 若参数为集合或数组, 则转换成 Map 对象, 否则返回原对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">wrapToMapIfCollection</span><span class="params">(Object object, String actualParamName)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">     <span class="comment">// 参数若是 Collection 型，做 collection 标记</span></span><br><span class="line">     ParamMap&lt;Object&gt; map = <span class="keyword">new</span> <span class="title class_">ParamMap</span>&lt;&gt;();</span><br><span class="line">     map.put(<span class="string">&quot;collection&quot;</span>, object);</span><br><span class="line">     <span class="keyword">if</span> (object <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">       <span class="comment">// 参数若是 List 型，做 list 标记</span></span><br><span class="line">       map.put(<span class="string">&quot;list&quot;</span>, object);</span><br><span class="line">     &#125;</span><br><span class="line">     Optional.ofNullable(actualParamName).ifPresent(name -&gt; map.put(name, object));</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object != <span class="literal">null</span> &amp;&amp; object.getClass().isArray()) &#123;</span><br><span class="line">     <span class="comment">// 参数若是数组型，做 array 标记</span></span><br><span class="line">     ParamMap&lt;Object&gt; map = <span class="keyword">new</span> <span class="title class_">ParamMap</span>&lt;&gt;();</span><br><span class="line">     map.put(<span class="string">&quot;array&quot;</span>, object);</span><br><span class="line">     Optional.ofNullable(actualParamName).ifPresent(name -&gt; map.put(name, object));</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 参数若不是集合型，直接返回原来值</span></span><br><span class="line">   <span class="keyword">return</span> object;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="插件和拦截器"><a href="#插件和拦截器" class="headerlink" title="插件和拦截器"></a>插件和拦截器</h3><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.plugin.Plugin</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.apache.ibatis.plugin.Plugin#invoke</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前方法所在类或接口中，可被当前Interceptor拦截的方式</span></span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">    <span class="comment">// 如果当前调用的方式需要被拦截，则调用intercept方法进行拦截处理</span></span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="literal">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">      <span class="comment">//调用Interceptor.intercept，也即插入了我们自己的逻辑</span></span><br><span class="line">      <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> <span class="title class_">Invocation</span>(target, method, args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前调用的方法不能被拦截，则调用target对象的相应方法</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取用户自定义Interceptor中@Signature注解的信息，getSignatureMap方法负责处理@Signture注解</span></span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">  <span class="comment">// 获取目标类型</span></span><br><span class="line">  Class&lt;?&gt; type = target.getClass();</span><br><span class="line">  <span class="comment">// 获取目标类型实现的接口，拦截器可以拦截的 4 类对象都实现了相应的接口，这也是能使用 JDK 动态代理的方式创建代理对象的基础</span></span><br><span class="line">  <span class="comment">// 支持被拦截的接口有: Executor, StatementHandler, ParameterHandler, ResultSetHandler</span></span><br><span class="line">  Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">  <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 JDK 动态代理的方式创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        type.getClassLoader(),</span><br><span class="line">        interfaces,</span><br><span class="line">        <span class="comment">// 使用 InvocationHandler 对象就是 Plugin 对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Plugin</span>(target, interceptor, signatureMap));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取得签名 Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">  <span class="comment">// 取 Intercepts 注解</span></span><br><span class="line">  <span class="type">Intercepts</span> <span class="variable">interceptsAnnotation</span> <span class="operator">=</span> interceptor.getClass().getAnnotation(Intercepts.class);</span><br><span class="line">  <span class="comment">// issue #251</span></span><br><span class="line">  <span class="comment">// 必须得有 Intercepts 注解，没有报错</span></span><br><span class="line">  <span class="keyword">if</span> (interceptsAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PluginException</span>(<span class="string">&quot;No @Intercepts annotation was found in interceptor &quot;</span> + interceptor.getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// value 是数组型，Signature 的数组</span></span><br><span class="line">  Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">  <span class="comment">// 每个 class 里有多个 Method 需要被拦截,所以这么定义</span></span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Signature sig : sigs) &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = MapUtil.computeIfAbsent(signatureMap, sig.type(), k -&gt; <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">      methods.add(method);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PluginException</span>(<span class="string">&quot;Could not find method on &quot;</span> + sig.type() + <span class="string">&quot; named &quot;</span> + sig.method() + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> signatureMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义实现拦截器</span></span><br><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;-------&quot;</span> + invocation + <span class="string">&quot;================&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">    System.out.println(<span class="string">&quot;-------&quot;</span> + result + <span class="string">&quot;================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CachingExecutor-查询"><a href="#CachingExecutor-查询" class="headerlink" title="CachingExecutor 查询"></a>CachingExecutor 查询</h3><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.executor.CachingExecutor</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>:  CachingExecutor 作为二级缓存执行器, 添加了缓存机制, 其实际查询逻辑仍然由 <code>BaseExecutor#query</code> 的实现类(即<code>delegate</code>)来执行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 获取 BoundSql 对象</span></span><br><span class="line">  <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameterObject);</span><br><span class="line">  <span class="comment">// 创建 CacheKey 对象</span></span><br><span class="line">  <span class="type">CacheKey</span> <span class="variable">key</span> <span class="operator">=</span> createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 ResultLoader.selectList 调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 获取查询语句所在命名空间对应的二级缓存</span></span><br><span class="line">  <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">  <span class="comment">// 是否开启了二级缓存</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据 select 节点的配置，决定是否需要清空二级缓存</span></span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="comment">// 检测 SQL 节点的 useCache 配置以及是否使用了 resultHandler 配置</span></span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 二级缓存不能保存输出类型的参数，如果查询操作调用了包含输出参数的存储过程，则报错</span></span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="comment">// 查询二级缓存</span></span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 二级缓存没有相应的结果集，调用封装的 Executor 对象的 query 方法</span></span><br><span class="line">        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        <span class="comment">// 将查询结果保存到 TransactionalCache.entriesToAddOnCommit 集合中</span></span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有启动二级缓存，直接调用底层Executor执行数据库查询操作</span></span><br><span class="line">  <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BaseExecutor-查询"><a href="#BaseExecutor-查询" class="headerlink" title="BaseExecutor 查询"></a>BaseExecutor 查询</h3><blockquote>
<p><strong>查询</strong>: <code>org.apache.ibatis.executor.BaseExecutor#query</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>: BaseExecutor 的实现类有: SimpleExecutor(简单执行器), ReuseExecutor(重用执行器), BatchExecutor(批处理执行器)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="comment">// 检测当前 Executor 是否已经关闭</span></span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="comment">// 非嵌套查询，并且 select 节点配置的 flushCache 属性为 true 时，才会清空一级缓存， flushCache 配置项是影响一级缓存中结果对象存活时长的第一个方面</span></span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 增加查询层数</span></span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">// 查询一级缓存</span></span><br><span class="line">    list = resultHandler == <span class="literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 针对存储过程调用的处理，在一级缓存命中时，获取缓存中保存的输出类型参数，并设置到用户传入的实参对象中</span></span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 doQuery 方法完成数据库查询，并得到映射后的结果对象</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 当前查询完成，查询层数减少</span></span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 在最外层的查询结束时，所有嵌套查询也已经完成，相关缓存项也已经完全记载，所以在此处触发DeferredLoad 加载一级缓存中记录的嵌套查询的结果对象</span></span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    <span class="comment">// 加载完成后，清空deferredLoads集合</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      <span class="comment">// 根据 LocalCacheScope 配置决定是否清空一级缓存</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从数据库查</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="comment">// 在缓存中添加占位符</span></span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 完成数据库查询操作，并返回结果对象</span></span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 删除占位符</span></span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将真正的结果对象添加到一级缓存中</span></span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="comment">// 是否未存储过程调用</span></span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    <span class="comment">// 缓存输出类型的参数</span></span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建缓存Key</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CacheKey <span class="title function_">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="comment">// 检测当前 executor 是否已经关闭</span></span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建 CacheKey 对象</span></span><br><span class="line">  <span class="type">CacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheKey</span>();</span><br><span class="line">  <span class="comment">// 将 MappedStatemen t的 id 添加到 CacheKey 对象中</span></span><br><span class="line">  cacheKey.update(ms.getId());</span><br><span class="line">  <span class="comment">// 将 offset 添加到 CacheKey 对象中</span></span><br><span class="line">  cacheKey.update(rowBounds.getOffset());</span><br><span class="line">  <span class="comment">// 将 limit 添加到 CacheKey 对象中</span></span><br><span class="line">  cacheKey.update(rowBounds.getLimit());</span><br><span class="line">  <span class="comment">// 将 sql 添加到 CacheKey 对象中</span></span><br><span class="line">  cacheKey.update(boundSql.getSql());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="type">TypeHandlerRegistry</span> <span class="variable">typeHandlerRegistry</span> <span class="operator">=</span> ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">  <span class="comment">// 获取用户传入的实参，并添加到 CacheKey 对象中</span></span><br><span class="line">  <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">      Object value;</span><br><span class="line">      <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> parameterMapping.getProperty();</span><br><span class="line">      <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        value = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">        value = parameterObject;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> configuration.newMetaObject(parameterObject);</span><br><span class="line">        value = metaObject.getValue(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将实参添加到 CacheKey 对象中</span></span><br><span class="line">      cacheKey.update(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 environment 的 id 不为空，则将其添加到 CacheKey 中</span></span><br><span class="line">  <span class="keyword">if</span> (configuration.getEnvironment() != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// issue #176</span></span><br><span class="line">    cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cacheKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SimpleExecutor-查询"><a href="#SimpleExecutor-查询" class="headerlink" title="SimpleExecutor 查询"></a>SimpleExecutor 查询</h3><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.executor.SimpleExecutor#doQuery</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>:  默认实现的查询</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取配置对象</span></span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 创建StatementHandler对象，实际返回的是RoutingStatementHandler对象</span></span><br><span class="line">    <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 完成Statement的创建和初始化</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 调用query方法执行sql语句，并通过ResultSetHandler完成结果集的映射</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭Statement对象</span></span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Statement <span class="title function_">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  Statement stmt;</span><br><span class="line">  <span class="comment">// 获取数据库连接</span></span><br><span class="line">  <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> getConnection(statementLog);</span><br><span class="line">  <span class="comment">// 创建Statement对象</span></span><br><span class="line">  stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">  <span class="comment">// 处理占位符</span></span><br><span class="line">  handler.parameterize(stmt);</span><br><span class="line">  <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.ibatis.session.Configuration#newStatementHandler</span></span><br><span class="line"><span class="comment">// 创建语句处理器</span></span><br><span class="line"><span class="keyword">public</span> StatementHandler <span class="title function_">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="comment">// 创建路由选择语句处理器</span></span><br><span class="line">  <span class="comment">// 根据 MappedStatement 的配置，生成一个对应的 StatementHandler 对象</span></span><br><span class="line">  <span class="comment">// SimpleStatementHandler, PreparedStatementHandler, CallableStatementHandler</span></span><br><span class="line">  <span class="type">StatementHandler</span> <span class="variable">statementHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingStatementHandler</span>(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  <span class="comment">// 引入插件</span></span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PreparedStatementHandler-查询"><a href="#PreparedStatementHandler-查询" class="headerlink" title="PreparedStatementHandler 查询"></a>PreparedStatementHandler 查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备语句</span></span><br><span class="line"><span class="keyword">public</span> Statement <span class="title function_">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化 Statement</span></span><br><span class="line">    statement = instantiateStatement(connection);</span><br><span class="line">    <span class="comment">// 设置超时</span></span><br><span class="line">    setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">    <span class="comment">// 设置读取条数</span></span><br><span class="line">    setFetchSize(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行数据库查询</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 执行 jdbc 的查询</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 解析返回结果</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多行查询-map"><a href="#多行查询-map" class="headerlink" title="多行查询(map)"></a>多行查询(map)</h2><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.session.defaults.DefaultSqlSession#selectMap</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>: 根据条件查询, 返回 map 对象, key 为 @MapKey 指定列, value 为查询列对象; 与多行查询的不同点在于, 返回结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.selectMap(statement, parameter, mapKey, RowBounds.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心selectMap</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowBounds)</span> &#123;</span><br><span class="line">  <span class="comment">// 调用 selectList, 此方法实现参考&quot;多行查询&quot;介绍</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; list = selectList(statement, parameter, rowBounds);</span><br><span class="line">  <span class="keyword">final</span> DefaultMapResultHandler&lt;K, V&gt; mapResultHandler = <span class="keyword">new</span> <span class="title class_">DefaultMapResultHandler</span>&lt;&gt;(mapKey,</span><br><span class="line">          configuration.getObjectFactory(), configuration.getObjectWrapperFactory(), configuration.getReflectorFactory());</span><br><span class="line">  <span class="keyword">final</span> DefaultResultContext&lt;V&gt; context = <span class="keyword">new</span> <span class="title class_">DefaultResultContext</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (V o : list) &#123;</span><br><span class="line">    <span class="comment">// 循环用 DefaultMapResultHandler 处理每条记录</span></span><br><span class="line">    context.nextResultObject(o);</span><br><span class="line">    mapResultHandler.handleResult(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意这个 DefaultMapResultHandler 里面存了所有已处理的记录(内部实现可能就是一个Map)，最后再返回一个 Map</span></span><br><span class="line">  <span class="keyword">return</span> mapResultHandler.getMappedResults();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="游标查询"><a href="#游标查询" class="headerlink" title="游标查询"></a>游标查询</h2><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.session.defaults.DefaultSqlSession#selectCursor</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>: 根据条件查询, 返回游标</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> selectCursor(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">    Cursor&lt;T&gt; cursor = executor.queryCursor(ms, wrapCollection(parameter), rowBounds);</span><br><span class="line">    registerCursor(cursor);</span><br><span class="line">    <span class="keyword">return</span> cursor;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="CachingExecutor-游标查询"><a href="#CachingExecutor-游标查询" class="headerlink" title="CachingExecutor 游标查询"></a>CachingExecutor 游标查询</h3><p><strong>定位</strong>: <code>org.apache.ibatis.executor.CachingExecutor#queryCursor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; Cursor&lt;E&gt; <span class="title function_">queryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  flushCacheIfRequired(ms);</span><br><span class="line">  <span class="comment">// 没有二级缓存</span></span><br><span class="line">  <span class="keyword">return</span> delegate.queryCursor(ms, parameter, rowBounds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BaseExecutor-游标查询"><a href="#BaseExecutor-游标查询" class="headerlink" title="BaseExecutor 游标查询"></a>BaseExecutor 游标查询</h3><p><strong>定位</strong>: <code>org.apache.ibatis.executor.BaseExecutor#queryCursor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; Cursor&lt;E&gt; <span class="title function_">queryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameter);</span><br><span class="line">  <span class="keyword">return</span> doQueryCursor(ms, parameter, rowBounds, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SimpleExecutor-游标查询"><a href="#SimpleExecutor-游标查询" class="headerlink" title="SimpleExecutor 游标查询"></a>SimpleExecutor 游标查询</h3><p><strong>定位</strong>: <code>org.apache.ibatis.executor.SimpleExecutor#doQueryCursor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;E&gt; Cursor&lt;E&gt; <span class="title function_">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">  <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, <span class="literal">null</span>, boundSql);</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">  Cursor&lt;E&gt; cursor = handler.queryCursor(stmt);</span><br><span class="line">  stmt.closeOnCompletion();</span><br><span class="line">  <span class="keyword">return</span> cursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PreparedStatementHandler-游标查询"><a href="#PreparedStatementHandler-游标查询" class="headerlink" title="PreparedStatementHandler 游标查询"></a>PreparedStatementHandler 游标查询</h3><p><strong>定位</strong>: <code>org.apache.ibatis.executor.statement.PreparedStatementHandler#queryCursor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; Cursor&lt;E&gt; <span class="title function_">queryCursor</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleCursorResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>源码</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码之数据库结果集</title>
    <url>/2020/11/26/Mybatis/Mybatis06/</url>
    <content><![CDATA[<h2 id="普通结果集"><a href="#普通结果集" class="headerlink" title="普通结果集"></a>普通结果集</h2><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.executor.resultset.DefaultResultSetHandler#handleResultSets</code></p>
</blockquote>
<p>处理配置 resultMap, resultSet 和 resultSets 的结果映射(支持多个结果集)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(mappedStatement.getId());</span><br><span class="line">  <span class="comment">// 该集合用于保存映射结果得到的结果对象</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="type">int</span> <span class="variable">resultSetCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取第一个 ResultSet 对象</span></span><br><span class="line">  <span class="type">ResultSetWrapper</span> <span class="variable">rsw</span> <span class="operator">=</span> getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 MappedStatement.resultMaps 集合</span></span><br><span class="line">  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">  <span class="type">int</span> <span class="variable">resultMapCount</span> <span class="operator">=</span> resultMaps.size();</span><br><span class="line">  <span class="comment">// 如果集合集不为空，则 resultMaps 集合不能为空，否则抛出异常</span></span><br><span class="line">  validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">  <span class="comment">// 遍历 resultMaps 集合</span></span><br><span class="line">  <span class="keyword">while</span> (rsw != <span class="literal">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">    <span class="comment">// 获取该结果集对应的 ResultMap 对象</span></span><br><span class="line">    <span class="type">ResultMap</span> <span class="variable">resultMap</span> <span class="operator">=</span> resultMaps.get(resultSetCount);</span><br><span class="line">    <span class="comment">// 根据 ResultMap 中定义的映射规则对 ResultSet 进行映射，并将映射的结果对象添加到multipleResult 集合中保存</span></span><br><span class="line">    handleResultSet(rsw, resultMap, multipleResults, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 获取下一个结果集</span></span><br><span class="line">    rsw = getNextResultSet(stmt);</span><br><span class="line">    <span class="comment">// 清空 nestedResultObjects 集合</span></span><br><span class="line">    cleanUpAfterHandlingResultSet();</span><br><span class="line">    <span class="comment">// 递增 resultSetCount</span></span><br><span class="line">    resultSetCount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 MappedStatement.resultSets 属性，该属性对多结果集的情况使用，该属性将列出语句执行后返回的结果集，并给每个结果集一个名称，名称是逗号分隔的，</span></span><br><span class="line">  String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">  <span class="keyword">if</span> (resultSets != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="literal">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">      <span class="comment">// 根据 resultSet 的名称，获取未处理的 ResultMapping</span></span><br><span class="line">      <span class="type">ResultMapping</span> <span class="variable">parentMapping</span> <span class="operator">=</span> nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">      <span class="keyword">if</span> (parentMapping != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">nestedResultMapId</span> <span class="operator">=</span> parentMapping.getNestedResultMapId();</span><br><span class="line">        <span class="type">ResultMap</span> <span class="variable">resultMap</span> <span class="operator">=</span> configuration.getResultMap(nestedResultMapId);</span><br><span class="line">        <span class="comment">// 根据 ResultMap 对象映射结果集</span></span><br><span class="line">        handleResultSet(rsw, resultMap, <span class="literal">null</span>, parentMapping);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取下一个结果集</span></span><br><span class="line">      rsw = getNextResultSet(stmt);</span><br><span class="line">      <span class="comment">// 清空 nestedResultObjects 集合</span></span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      <span class="comment">// 递增 resultSetCount</span></span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.executor.resultset.DefaultResultSetHandler#handleResultSets</code></p>
</blockquote>
<p>处理单个结果集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理结果集</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResultSet</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parentMapping != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理多结果集中的嵌套映射</span></span><br><span class="line">      handleRowValues(rsw, resultMap, <span class="literal">null</span>, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (resultHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果用户未指定处理映射结果对象的 ResultHandler 对象，则使用 DefaultResultHandler 作为默认的 ResultHandler 对象</span></span><br><span class="line">        <span class="type">DefaultResultHandler</span> <span class="variable">defaultResultHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResultHandler</span>(objectFactory);</span><br><span class="line">        <span class="comment">// 对 ResultSet 进行映射，并将映射得到的结果对象添加到 DefaultResultHandler 对象中暂存</span></span><br><span class="line">        handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 将 DefaultResultHandler 中保存的结果对象添加到 multipleResults 集合中</span></span><br><span class="line">        multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用用户指定的 ResultHandler 对象处理结果对象</span></span><br><span class="line">        handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// issue #228 (close resultsets)</span></span><br><span class="line">    <span class="comment">// 调用 ResultSet.close 方法关闭结果集</span></span><br><span class="line">    closeResultSet(rsw.getResultSet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理一行的所有字段值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRowValues</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 针对存在嵌套 ResultMap 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (resultMap.hasNestedResultMaps()) &#123;</span><br><span class="line">    <span class="comment">// 检测是否允许在嵌套映射中使用 RowBound</span></span><br><span class="line">    ensureNoRowBounds();</span><br><span class="line">    checkResultHandler();</span><br><span class="line">    <span class="comment">// 检测是否允许在嵌套映射中使用用户自定义的 ResultHandler</span></span><br><span class="line">    handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 针对不含嵌套映射的简单映射的处理</span></span><br><span class="line">    handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非嵌套结果集"><a href="#非嵌套结果集" class="headerlink" title="非嵌套结果集"></a>非嵌套结果集</h3><p><code>org.apache.ibatis.executor.resultset.DefaultResultSetHandler#handleRowValuesForSimpleResultMap</code><br>遍历结果集的所有行,  将一行的数据自动映射成一个对象，并将此对象添加到 resultList 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRowValuesForSimpleResultMap</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 默认上下文对象</span></span><br><span class="line">  DefaultResultContext&lt;Object&gt; resultContext = <span class="keyword">new</span> <span class="title class_">DefaultResultContext</span>&lt;&gt;();</span><br><span class="line">  <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> rsw.getResultSet();</span><br><span class="line">  <span class="comment">// 根据 RowBounds 中的 offset 定位到指定的记录</span></span><br><span class="line">  skipRows(resultSet, rowBounds);</span><br><span class="line">  <span class="comment">// 检测已经处理的行数是否已经达到上限（RowBounds,limit）以及ResultSet中是否还有可处理的记录</span></span><br><span class="line">  <span class="keyword">while</span> (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">// 根据该行记录以及 ResultMap.discriminator，决定映射使用的 ResultMap</span></span><br><span class="line">    <span class="type">ResultMap</span> <span class="variable">discriminatedResultMap</span> <span class="operator">=</span> resolveDiscriminatedResultMap(resultSet, resultMap, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 根据最终确定的 ResultMap 对 ResultSet 中的该行记录进行映射，得到映射后的结果对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">rowValue</span> <span class="operator">=</span> getRowValue(rsw, discriminatedResultMap, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 将映射创建的结果对象添加到 ResultHandler.resultList 中保存</span></span><br><span class="line">    storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>org.apache.ibatis.executor.resultset.DefaultResultSetHandler#resolveDiscriminatedResultMap</code></p>
<p>使用配置字段的结果值来决定使用哪个 resultMap</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">column</span>=<span class="string">&quot;draft&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;DraftPost&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ResultMap <span class="title function_">resolveDiscriminatedResultMap</span><span class="params">(ResultSet rs, ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 记录已经处理过的 ResultMap 的 id</span></span><br><span class="line">  Set&lt;String&gt; pastDiscriminators = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 获取 ResultMap 中的 Discriminator 对象</span></span><br><span class="line">  <span class="type">Discriminator</span> <span class="variable">discriminator</span> <span class="operator">=</span> resultMap.getDiscriminator();</span><br><span class="line">  <span class="keyword">while</span> (discriminator != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取记录中对应列的值，其中会使用相应的 TypeHandler 对象将该列值转换成 Java 类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getDiscriminatorValue(rs, discriminator, columnPrefix);</span><br><span class="line">    <span class="comment">// 根据该列值获取对应的 ResultMap 的 id</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">discriminatedMapId</span> <span class="operator">=</span> discriminator.getMapIdFor(String.valueOf(value));</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasResultMap(discriminatedMapId)) &#123;</span><br><span class="line">      <span class="comment">// 根据上述获取的 id 查找相应的 ResultMap 对象</span></span><br><span class="line">      resultMap = configuration.getResultMap(discriminatedMapId);</span><br><span class="line">      <span class="comment">// 记录当前 Discriminator 对象</span></span><br><span class="line">      <span class="type">Discriminator</span> <span class="variable">lastDiscriminator</span> <span class="operator">=</span> discriminator;</span><br><span class="line">      <span class="comment">// 获取 ResultMap 对象中的 Discrimination</span></span><br><span class="line">      discriminator = resultMap.getDiscriminator();</span><br><span class="line">      <span class="comment">// 检测 Discriminator 是否出现了环形引用</span></span><br><span class="line">      <span class="keyword">if</span> (discriminator == lastDiscriminator || !pastDiscriminators.add(discriminatedMapId)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 该 ResultMap 对象为映射最终使用的 ResultMap</span></span><br><span class="line">  <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.apache.ibatis.executor.resultset.DefaultResultSetHandler#getRowValue</code><br>  创建实体类对象；自动映射结果集中有的column，但 resultMap 中并没有配置；根据 resultMap 节点中配置的映射关系进行映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 核心，取得一行的值</span></span><br><span class="line">  <span class="keyword">private</span> Object <span class="title function_">getRowValue</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 实例化 ResultLoaderMap (延迟加载器)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ResultLoaderMap</span> <span class="variable">lazyLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultLoaderMap</span>();</span><br><span class="line">    <span class="comment">// 创建该行记录映射之后得到的结果对象，该结果对象的类型由 ResultMap 节点的 type 属性指定</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">rowValue</span> <span class="operator">=</span> createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span><br><span class="line">    <span class="keyword">if</span> (rowValue != <span class="literal">null</span> &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">      <span class="comment">// 创建上述结果对象相应的 MetaObject 对象</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> configuration.newMetaObject(rowValue);</span><br><span class="line">      <span class="comment">// 成功映射任意属性，则 foundValues 为 true,否则 foundValues 为 false</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">foundValues</span> <span class="operator">=</span> <span class="built_in">this</span>.useConstructorMappings;</span><br><span class="line">      <span class="comment">// 检测是否需要进行自动映射</span></span><br><span class="line">      <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// 自动映射 ResultMap 中未明确指定的列</span></span><br><span class="line">        foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 映射 ResultMap 中明确指定需要映射的列</span></span><br><span class="line">      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span><br><span class="line">      foundValues = lazyLoader.size() &gt; <span class="number">0</span> || foundValues;</span><br><span class="line">      <span class="comment">// 如果没有成功映射任何属性，则根据 mybatis-config.xml 中的 returnInstanceForEmptyRow 配置决定返回空的结果对象还是返回 null</span></span><br><span class="line">      rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rowValue;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 自动映射</span></span><br><span class="line">    <span class="comment">// 如果配置了自动映射, 跟根据 typeHandler 来解析列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">applyAutomaticMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 获取 ResultSet 中存在，但 ResultMap 中没有明确映射的列所对应的UnMappedColumnAutoMapping 集合，如果 ResultMap 中设置的 resultType 为 HashMap 的话，则全部的列都会在这里获取到</span></span><br><span class="line">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">foundValues</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!autoMapping.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 遍历 autoMapping 集合</span></span><br><span class="line">      <span class="keyword">for</span> (UnMappedColumnAutoMapping mapping : autoMapping) &#123;</span><br><span class="line">        <span class="comment">// 使用 TypeHandler 获取自动映射的列值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> mapping.typeHandler.getResult(rsw.getResultSet(), mapping.column);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">          foundValues = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span> || (configuration.isCallSettersOnNulls() &amp;&amp; !mapping.primitive)) &#123;</span><br><span class="line">          <span class="comment">// gcode issue #377, call setter on nulls (value is not &#x27;found&#x27;)</span></span><br><span class="line">          <span class="comment">// 将自动映射的属性值设置到结果对象中</span></span><br><span class="line">          metaObject.setValue(mapping.property, value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foundValues;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据 &lt;resultMap&gt; 节点中配置的映射关系进行映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">applyPropertyMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, ResultLoaderMap lazyLoader, String columnPrefix)</span></span><br><span class="line">      <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 获取该 ResultMap 中明确需要进行映射的列名集合</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">foundValues</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获取 ResultMap.propertyResultMappings 集合，其中记录了映射使用的所有 ResultMapping 对象</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">    <span class="keyword">for</span> (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">      <span class="comment">// 处理列前缀</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">column</span> <span class="operator">=</span> prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">      <span class="keyword">if</span> (propertyMapping.getNestedResultMapId() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// the user added a column attribute to a nested result map, ignore it</span></span><br><span class="line">        <span class="comment">// 该属性需要使用一个嵌套 ResultMap 进行映射，忽略 column 属性</span></span><br><span class="line">        column = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 下面的逻辑主要处理三种场景</span></span><br><span class="line">      <span class="comment">// 场景1：column是&#123;prop1=col1,prop2=col2&#125;这种形式的，一般与嵌套查询配合使用，表示将col1和col2的列值传递给内层嵌套查询作为参数</span></span><br><span class="line">      <span class="comment">// 场景2：基本类型的属性映射</span></span><br><span class="line">      <span class="comment">// 场景3：多结果集的场景处理，该属性来自于另一个结果集</span></span><br><span class="line">      <span class="keyword">if</span> (propertyMapping.isCompositeResult() <span class="comment">// 场景1</span></span><br><span class="line">          || (column != <span class="literal">null</span> &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH))) <span class="comment">// 场景2</span></span><br><span class="line">          || propertyMapping.getResultSet() != <span class="literal">null</span>) &#123; <span class="comment">// 场景3</span></span><br><span class="line">        <span class="comment">// 通过 getPropertyMappingValue 方法完成映射，并得到属性值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">        <span class="comment">// issue #541 make property optional</span></span><br><span class="line">        <span class="comment">// 获取属性名称</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> propertyMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (property == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == DEFERRED) &#123;</span><br><span class="line">          <span class="comment">// DEFERRED表示的是占位符对象</span></span><br><span class="line">          foundValues = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">          foundValues = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span> || (configuration.isCallSettersOnNulls() &amp;&amp; !metaObject.getSetterType(property).isPrimitive())) &#123;</span><br><span class="line">          <span class="comment">// gcode issue #377, call setter on nulls (value is not &#x27;found&#x27;)</span></span><br><span class="line">          <span class="comment">// 设置属性值</span></span><br><span class="line">          metaObject.setValue(property, value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foundValues;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 嵌套查询, 加载出此字段的值; 多结果集: 直接返回占位符; 否则根据 typeHandler 来解析返回值</span></span><br><span class="line">  <span class="keyword">private</span> Object <span class="title function_">getPropertyMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)</span></span><br><span class="line">      <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 嵌套查询</span></span><br><span class="line">    <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">      <span class="comment">// 多结果集的处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMapping.getResultSet() != <span class="literal">null</span>) &#123;</span><br><span class="line">      addPendingChildRelation(rs, metaResultObject, propertyMapping);   <span class="comment">// TODO is that OK?</span></span><br><span class="line">      <span class="comment">// 返回占位符对象</span></span><br><span class="line">      <span class="keyword">return</span> DEFERRED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 获取 ResultMapping 中记录的 TypeHandler 对象</span></span><br><span class="line">      <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">column</span> <span class="operator">=</span> prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">      <span class="comment">// 使用 TypeHandler 对象获取属性值</span></span><br><span class="line">      <span class="keyword">return</span> typeHandler.getResult(rs, column);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>org.apache.ibatis.reflection.MetaObject</code></p>
<p>元对象, 各种get，set方法类似ognl表达式的解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MetaObject 的构造方法是 private 修饰的，只能通过 forObject 这个静态方法创建 MetaObject 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MetaObject <span class="title function_">forObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若 object 为 null ，则统一返回 SystemMetaObject.NULL_META_OBJECT</span></span><br><span class="line">    <span class="keyword">return</span> SystemMetaObject.NULL_META_OBJECT;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MetaObject</span>(object, objectFactory, objectWrapperFactory, reflectorFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化上述字段</span></span><br><span class="line">  <span class="built_in">this</span>.originalObject = object;</span><br><span class="line">  <span class="built_in">this</span>.objectFactory = objectFactory;</span><br><span class="line">  <span class="built_in">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">  <span class="built_in">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">    <span class="comment">// 如果对象本身已经是 ObjectWrapper 型，则直接赋给 objectWrapper</span></span><br><span class="line">    <span class="built_in">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">    <span class="comment">// 若 ObjectWrapperFactory 能够为该原始对象创建对应的 ObjectWrapper 对象，则优先使用ObjectWrapperFactory,而</span></span><br><span class="line">    <span class="comment">// DefaultObjectWrapperFactory.hasWrapperFor 始终返回 false，用户可以自定义ObjectWrapperFactory 实现进行扩展</span></span><br><span class="line">    <span class="built_in">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="built_in">this</span>, object);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    <span class="comment">// 若原始对象为 map 对象，则创建 MapWrapper 对象</span></span><br><span class="line">    <span class="built_in">this</span>.objectWrapper = <span class="keyword">new</span> <span class="title class_">MapWrapper</span>(<span class="built_in">this</span>, (Map) object);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">    <span class="comment">// 若原始对象是 Collection 类型，则创建 CollectionWrapper 对象</span></span><br><span class="line">    <span class="built_in">this</span>.objectWrapper = <span class="keyword">new</span> <span class="title class_">CollectionWrapper</span>(<span class="built_in">this</span>, (Collection) object);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 若原始对象是普通的 javaBean 对象，则创建 BeanWrapper 对象</span></span><br><span class="line">    <span class="built_in">this</span>.objectWrapper = <span class="keyword">new</span> <span class="title class_">BeanWrapper</span>(<span class="built_in">this</span>, object);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  <span class="comment">// 解析属性表达式</span></span><br><span class="line">  <span class="type">PropertyTokenizer</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyTokenizer</span>(name);</span><br><span class="line">  <span class="comment">// 处理子表达式</span></span><br><span class="line">  <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 根据 PropertyTokenizer 解析后制定的属性，创建相应的 MetaObject 对象</span></span><br><span class="line">    <span class="type">MetaObject</span> <span class="variable">metaValue</span> <span class="operator">=</span> metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">    <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">      <span class="comment">// 如果上层就是 null 了，那就结束，返回 null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 递归处理子表达式</span></span><br><span class="line">      <span class="keyword">return</span> metaValue.getValue(prop.getChildren());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 ObjectWrapper 获取指定的属性值</span></span><br><span class="line">    <span class="keyword">return</span> objectWrapper.get(prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String name, Object value)</span> &#123;</span><br><span class="line">  <span class="type">PropertyTokenizer</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyTokenizer</span>(name);</span><br><span class="line">  <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">    <span class="type">MetaObject</span> <span class="variable">metaValue</span> <span class="operator">=</span> metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">    <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果上层就是 null了，还得看有没有儿子，没有那就结束</span></span><br><span class="line">        <span class="comment">// don&#x27;t instantiate child path if value is null</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则还得 new 一个，委派给 ObjectWrapper.instantiatePropertyValue</span></span><br><span class="line">        metaValue = objectWrapper.instantiatePropertyValue(name, prop, objectFactory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归调用 setValue</span></span><br><span class="line">    metaValue.setValue(prop.getChildren(), value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 到了最后一层了，所以委派给ObjectWrapper.set</span></span><br><span class="line">    objectWrapper.set(prop, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套结果集"><a href="#嵌套结果集" class="headerlink" title="嵌套结果集"></a>嵌套结果集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRowValuesForNestedResultMap</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 创建 DefaultResultContext 对象</span></span><br><span class="line">  <span class="keyword">final</span> DefaultResultContext&lt;Object&gt; resultContext = <span class="keyword">new</span> <span class="title class_">DefaultResultContext</span>&lt;&gt;();</span><br><span class="line">  <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> rsw.getResultSet();</span><br><span class="line">  <span class="comment">// 定位到指定的记录行</span></span><br><span class="line">  skipRows(resultSet, rowBounds);</span><br><span class="line">  <span class="type">Object</span> <span class="variable">rowValue</span> <span class="operator">=</span> previousRowValue;</span><br><span class="line">  <span class="comment">// 检测是否能继续映射结果集中剩余的记录行</span></span><br><span class="line">  <span class="keyword">while</span> (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">// 通过 resolveDiscriminatedResultMap 方法决定映射使用的 ResultMap 对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ResultMap</span> <span class="variable">discriminatedResultMap</span> <span class="operator">=</span> resolveDiscriminatedResultMap(resultSet, resultMap, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 为该行记录生成 CacheKey</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">CacheKey</span> <span class="variable">rowKey</span> <span class="operator">=</span> createRowKey(discriminatedResultMap, rsw, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 根据 CacheKey 查找 nestedResultObjects 集合</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">partialObject</span> <span class="operator">=</span> nestedResultObjects.get(rowKey);</span><br><span class="line">    <span class="comment">// issue #577 &amp;&amp; #542</span></span><br><span class="line">    <span class="comment">// 检测 resultOrdered 属性</span></span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.isResultOrdered()) &#123;</span><br><span class="line">      <span class="comment">// 主结果对象发生变化</span></span><br><span class="line">      <span class="keyword">if</span> (partialObject == <span class="literal">null</span> &amp;&amp; rowValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 清空 nestedResultObjects 集合</span></span><br><span class="line">        nestedResultObjects.clear();</span><br><span class="line">        <span class="comment">// 调用 storeObject 方法保存主结果对象</span></span><br><span class="line">        storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 完成该行记录的映射返回结果对象，将结果对象添加到 nestedResultObjects 集合中</span></span><br><span class="line">      rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, <span class="literal">null</span>, partialObject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 完成该行记录的映射返回结果对象，将结果对象添加到 nestedResultObjects 集合中</span></span><br><span class="line">      rowValue = getRowValue(rsw, discriminatedResultMap, rowKey, <span class="literal">null</span>, partialObject);</span><br><span class="line">      <span class="comment">// 调用 storeObject 方法保存结果对象</span></span><br><span class="line">      <span class="keyword">if</span> (partialObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 resultOrdered 属性为 true 时的特殊处理，调用 storeObject 方法保存结果对象</span></span><br><span class="line">  <span class="keyword">if</span> (rowValue != <span class="literal">null</span> &amp;&amp; mappedStatement.isResultOrdered() &amp;&amp; shouldProcessMoreRows(resultContext, rowBounds)) &#123;</span><br><span class="line">    storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">    previousRowValue = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowValue != <span class="literal">null</span>) &#123;</span><br><span class="line">    previousRowValue = rowValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="游标结果集"><a href="#游标结果集" class="headerlink" title="游标结果集"></a>游标结果集</h2><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.executor.resultset.DefaultResultSetHandler#handleCursorResultSets</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; Cursor&lt;E&gt; <span class="title function_">handleCursorResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;handling cursor results&quot;</span>).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取结果集并封装成 ResultSetWrapper 对象</span></span><br><span class="line">  <span class="type">ResultSetWrapper</span> <span class="variable">rsw</span> <span class="operator">=</span> getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取映射使用的 ResultMap 对象集合</span></span><br><span class="line">  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 边界检测，只能映射一个结果集，所以只能存在一个 ResultMap 对象</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">resultMapCount</span> <span class="operator">=</span> resultMaps.size();</span><br><span class="line">  validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">  <span class="keyword">if</span> (resultMapCount != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Cursor results cannot be mapped to multiple resultMaps&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用第一个 ResultMap 对象</span></span><br><span class="line">  <span class="type">ResultMap</span> <span class="variable">resultMap</span> <span class="operator">=</span> resultMaps.get(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 将 ResultSetWrapper 对象、映射使用的 ResultMap 对象一级控制映射的起止位置的 RowBounds 对象封装成 DefaultCursor 对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultCursor</span>&lt;&gt;(<span class="built_in">this</span>, resultMap, rsw, rowBounds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认游标"><a href="#默认游标" class="headerlink" title="默认游标"></a>默认游标</h3><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.cursor.defaults.DefaultCursor</code></p>
</blockquote>
<p>在调用游标迭代器的 hasNext 或者 next 方法时，会将 ResultSet 中的列封装成实体对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">fetchNextUsingRowBound</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 映射一行数据库记录，得到结果对象</span></span><br><span class="line">  <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> fetchNextObjectFromDatabase();</span><br><span class="line">  <span class="comment">// 从结果集开始一条条记录映射，但是将RowBounds.offset之前的映射结果全部忽略</span></span><br><span class="line">  <span class="keyword">while</span> (objectWrapperResultHandler.fetched &amp;&amp; indexWithRowBound &lt; rowBounds.getOffset()) &#123;</span><br><span class="line">    result = fetchNextObjectFromDatabase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">fetchNextObjectFromDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 检测当前右表对象是否关闭</span></span><br><span class="line">  <span class="keyword">if</span> (isClosed()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    objectWrapperResultHandler.fetched = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 更新游标状态</span></span><br><span class="line">    status = CursorStatus.OPEN;</span><br><span class="line">    <span class="keyword">if</span> (!rsw.getResultSet().isClosed()) &#123;</span><br><span class="line">      <span class="comment">// 通过DefaultResultSetHandler.handleRowValues方法完成映射，</span></span><br><span class="line">      resultSetHandler.handleRowValues(rsw, resultMap, objectWrapperResultHandler, RowBounds.DEFAULT, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取结果对象</span></span><br><span class="line">  <span class="type">T</span> <span class="variable">next</span> <span class="operator">=</span> objectWrapperResultHandler.result;</span><br><span class="line">  <span class="keyword">if</span> (objectWrapperResultHandler.fetched) &#123;</span><br><span class="line">    <span class="comment">// 统计返回的结果对象数量</span></span><br><span class="line">    indexWithRowBound++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// No more object or limit reached</span></span><br><span class="line">  <span class="comment">// 检测是否还存在需要映射的记录，如果没有，则关闭游标并修改状态</span></span><br><span class="line">  <span class="keyword">if</span> (!objectWrapperResultHandler.fetched || getReadItemsCount() == rowBounds.getOffset() + rowBounds.getLimit()) &#123;</span><br><span class="line">    <span class="comment">// 关闭结果集以及对应的Statement对象</span></span><br><span class="line">    close();</span><br><span class="line">    status = CursorStatus.CONSUMED;</span><br><span class="line">  &#125;</span><br><span class="line">  objectWrapperResultHandler.result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回结果对象</span></span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.apache.ibatis.cursor.defaults.DefaultCursor$CursorIterator</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">CursorIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">  T object;</span><br><span class="line">  <span class="type">int</span> <span class="variable">iteratorIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!objectWrapperResultHandler.fetched) &#123;</span><br><span class="line">      object = fetchNextUsingRowBound();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objectWrapperResultHandler.fetched;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Fill next with object fetched from hasNext()</span></span><br><span class="line">    <span class="comment">// 在 hasNext 方法也会调用 fetchNextUsingRowBound 方法，并将映射结果对象记录到 object 字段中</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">next</span> <span class="operator">=</span> object;</span><br><span class="line">    <span class="keyword">if</span> (!objectWrapperResultHandler.fetched) &#123;</span><br><span class="line">      <span class="comment">// 对结果集进行映射的核心</span></span><br><span class="line">      next = fetchNextUsingRowBound();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (objectWrapperResultHandler.fetched) &#123;</span><br><span class="line">      objectWrapperResultHandler.fetched = <span class="literal">false</span>;</span><br><span class="line">      object = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 记录返回结果对象的个数</span></span><br><span class="line">      iteratorIndex++;</span><br><span class="line">      <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Cannot remove element from Cursor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="存储过程输出参数"><a href="#存储过程输出参数" class="headerlink" title="存储过程输出参数"></a>存储过程输出参数</h2><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.executor.resultset.DefaultResultSetHandler#handleOutputParameters</code></p>
</blockquote>
<p>将存储过程中 OUT 参数结果设置到调用方的参数列表对象中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleOutputParameters</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 获取用户传入的实际参数，并为其创建相应的MetaObject对象</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">parameterObject</span> <span class="operator">=</span> parameterHandler.getParameterObject();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">MetaObject</span> <span class="variable">metaParam</span> <span class="operator">=</span> configuration.newMetaObject(parameterObject);</span><br><span class="line">  <span class="comment">// 获取 BoundSql.parameterMappings 集合，其中记录了参数相关信息</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="comment">// 遍历所有参数信息</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ParameterMapping</span> <span class="variable">parameterMapping</span> <span class="operator">=</span> parameterMappings.get(i);</span><br><span class="line">    <span class="comment">// 只处理 OUT|INOUT</span></span><br><span class="line">    <span class="keyword">if</span> (parameterMapping.getMode() == ParameterMode.OUT || parameterMapping.getMode() == ParameterMode.INOUT) &#123;</span><br><span class="line">      <span class="comment">// 如果存在输出类型的参数，则解析参数值，并设置到 parameterObject 中</span></span><br><span class="line">      <span class="keyword">if</span> (ResultSet.class.equals(parameterMapping.getJavaType())) &#123;</span><br><span class="line">        <span class="comment">// 如果指定该输出参数为 ResultSet 类型，则需要进行映射</span></span><br><span class="line">        handleRefCursorOutputParameter((ResultSet) cs.getObject(i + <span class="number">1</span>), parameterMapping, metaParam);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 TypeHandler 获取参数值，并设置到 parameterObject 中</span></span><br><span class="line">        <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        metaParam.setValue(parameterMapping.getProperty(), typeHandler.getResult(cs, i + <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理游标(OUT参数)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRefCursorOutputParameter</span><span class="params">(ResultSet rs, ParameterMapping parameterMapping, MetaObject metaParam)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="keyword">if</span> (rs == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取映射使用的 ResultMap 对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">resultMapId</span> <span class="operator">=</span> parameterMapping.getResultMapId();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ResultMap</span> <span class="variable">resultMap</span> <span class="operator">=</span> configuration.getResultMap(resultMapId);</span><br><span class="line">    <span class="comment">// 将结果集封装成 ResultSetWrapper</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ResultSetWrapper</span> <span class="variable">rsw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultSetWrapper</span>(rs, configuration);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.resultHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建用于保存映射结果对象的 DefaultResultHandler 对象</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">DefaultResultHandler</span> <span class="variable">resultHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResultHandler</span>(objectFactory);</span><br><span class="line">      <span class="comment">// 通过 handleRowValues 方法完成映射操作，并将结果对象保存到 DefaultResultHandler 中</span></span><br><span class="line">      handleRowValues(rsw, resultMap, resultHandler, <span class="keyword">new</span> <span class="title class_">RowBounds</span>(), <span class="literal">null</span>);</span><br><span class="line">      <span class="comment">// 将映射得到的结果对象保存到 parameterObject 中</span></span><br><span class="line">      metaParam.setValue(parameterMapping.getProperty(), resultHandler.getResultList());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handleRowValues(rsw, resultMap, resultHandler, <span class="keyword">new</span> <span class="title class_">RowBounds</span>(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// issue #228 (close resultsets)</span></span><br><span class="line">    closeResultSet(rs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>源码</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码之更新数据库</title>
    <url>/2020/11/26/Mybatis/Mybatis07/</url>
    <content><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><a href="https://www.processon.com/view/link/655098457b996f7b645b6afe">https://www.processon.com/view/link/655098457b996f7b645b6afe</a></p>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="width:489px; height:275px;" src="https://www.processon.com/embed/655093e59750447ca926f509"></iframe>


<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.session.defaults.DefaultSqlSession#update</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//每次要更新之前，dirty标志设为true</span></span><br><span class="line">    dirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">// 用执行器来update结果</span></span><br><span class="line">    <span class="keyword">return</span> executor.update(ms, wrapCollection(parameter));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error updating database.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.apache.ibatis.executor.CachingExecutor#update</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line"><span class="comment">// 刷新二级缓存完再 update</span></span><br><span class="line">flushCacheIfRequired(ms);</span><br><span class="line"><span class="keyword">return</span> delegate.update(ms, parameterObject);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.apache.ibatis.executor.BaseExecutor#update</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SqlSession.update/insert/delete 都会调用此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="comment">// 判断当前Executor是否已经关闭</span></span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先清局部缓存(一级缓存)，再更新，如何更新交由子类，模板方法模式</span></span><br><span class="line">  clearLocalCache();</span><br><span class="line">  <span class="comment">// 执行sql语句</span></span><br><span class="line">  <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.apache.ibatis.executor.SimpleExecutor#doUpdate</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 新建一个 StatementHandler</span></span><br><span class="line">    <span class="comment">// 这里看到 ResultHandler 传入的是 null</span></span><br><span class="line">    <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(<span class="built_in">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 准备语句</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.apache.ibatis.executor.statement.PreparedStatementHandler#update</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 调用 PreparedStatement.execute</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 调用 PreparedStatement.getUpdateCount</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> ps.getUpdateCount();</span><br><span class="line">  <span class="comment">// 获取实际入参</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">parameterObject</span> <span class="operator">=</span> boundSql.getParameterObject();</span><br><span class="line">  <span class="comment">// 若配置了 useGeneratedKeys 并且是 insert 语句, </span></span><br><span class="line">  <span class="comment">// 则返回 Jdbc3KeyGenerator.INSTANCE, 否则返回 NoKeyGenerator.INSTANCE</span></span><br><span class="line">  <span class="comment">// 若配置了 sekectKey, 则使用 SelectKeyGenerator 的实例</span></span><br><span class="line">  <span class="type">KeyGenerator</span> <span class="variable">keyGenerator</span> <span class="operator">=</span> mappedStatement.getKeyGenerator();</span><br><span class="line">  <span class="comment">// 执行主键生成器的后置方法, 主要给入参设置对应的主键值</span></span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="comment">// 返回更新的行数</span></span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><code>org.apache.ibatis.session.defaults.DefaultSqlSession#insert</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> insert(statement, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">  <span class="comment">// 调用更新</span></span><br><span class="line">  <span class="keyword">return</span> update(statement, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PreparedStatementHandler-更新"><a href="#PreparedStatementHandler-更新" class="headerlink" title="PreparedStatementHandler 更新"></a>PreparedStatementHandler 更新</h3><blockquote>
<p><strong>定位</strong>: <code>org.apache.ibatis.executor.statement.BaseStatementHandler#BaseStatementHandler</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>： 语句处理器的基类, 其子类有<code>PreparedStatementHandler</code>, <code>SimpleStatementHandler</code>, <code>CallableStatementHandler</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化字段</span></span><br><span class="line">  <span class="built_in">this</span>.configuration = mappedStatement.getConfiguration();</span><br><span class="line">  <span class="built_in">this</span>.executor = executor;</span><br><span class="line">  <span class="built_in">this</span>.mappedStatement = mappedStatement;</span><br><span class="line">  <span class="built_in">this</span>.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">  <span class="built_in">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (boundSql == <span class="literal">null</span>) &#123; <span class="comment">// issue #435, get the key before calculating the statement</span></span><br><span class="line">    <span class="comment">// 调用 KeyGenerator.processBefore方法获取主键</span></span><br><span class="line">    generateKeys(parameterObject);</span><br><span class="line">    boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.boundSql = boundSql;</span><br><span class="line">  <span class="comment">// 生成 parameterHandler</span></span><br><span class="line">  <span class="built_in">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  <span class="comment">// 生成 resultSetHandler</span></span><br><span class="line">  <span class="built_in">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成 key</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">generateKeys</span><span class="params">(Object parameter)</span> &#123;</span><br><span class="line">  <span class="type">KeyGenerator</span> <span class="variable">keyGenerator</span> <span class="operator">=</span> mappedStatement.getKeyGenerator();</span><br><span class="line">  ErrorContext.instance().store();</span><br><span class="line">  <span class="comment">// 调用主键生成器的前置方法</span></span><br><span class="line">  keyGenerator.processBefore(executor, mappedStatement, <span class="literal">null</span>, parameter);</span><br><span class="line">  ErrorContext.instance().recall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator</code></p>
<p>主键生成器, 默认使用数据库的生成策略, 将生成后的主键赋值到入参对应的字段中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBefore</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span> &#123;</span><br><span class="line">  <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processAfter</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span> &#123;</span><br><span class="line">  <span class="comment">// 将用户传入的实参 parameter 封装成集合类型，然后传入 processBatch 方法中处理</span></span><br><span class="line">  processBatch(ms, stmt, parameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBatch</span><span class="params">(MappedStatement ms, Statement stmt, Object parameter)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取 keyProperties 属性指定的属性名称，它表示主键对应的属性名称</span></span><br><span class="line">  <span class="keyword">final</span> String[] keyProperties = ms.getKeyProperties();</span><br><span class="line">  <span class="keyword">if</span> (keyProperties == <span class="literal">null</span> || keyProperties.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 核心是使用 JDBC3 的 Statement.getGeneratedKeys</span></span><br><span class="line">  <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.getGeneratedKeys()) &#123;</span><br><span class="line">    <span class="comment">// 获取ResultSet的元数据信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 检测数据库生成的主键的列数与 keyProperties 属性指定的列数是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> (rsmd.getColumnCount() &lt; keyProperties.length) &#123;</span><br><span class="line">      <span class="comment">// Error?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 主键列的值赋值到入参对象中</span></span><br><span class="line">      assignKeys(configuration, rs, rsmd, keyProperties, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Error getting generated key or setting result to parameter object. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><code>org.apache.ibatis.session.defaults.DefaultSqlSession#delete</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> update(statement, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">  <span class="comment">// delete 也是调用更新</span></span><br><span class="line">  <span class="keyword">return</span> update(statement, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>源码</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 源码整合 Spring</title>
    <url>/2020/11/26/Mybatis/Mybatis08/</url>
    <content><![CDATA[<p>在使用 Mybatis 时, 需要通过 SqlSessionFactory 打开一个SqlSession, 然后实例化 Mapper 接口的动态代理对象, 执行数据库相关操作。 </p>
<h2 id="创建-SqlSessionFactory-对象"><a href="#创建-SqlSessionFactory-对象" class="headerlink" title="创建 SqlSessionFactory 对象"></a>创建 SqlSessionFactory 对象</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 MyBatis-Spring 中，则使用 <code>SqlSessionFactoryBean</code> 来创建 <code>SqlSessionFactory</code>，<code>SqlSessionFactoryBean</code> 实现了 Spring 的 <code>FactoryBean</code> 接口，Spring 将会在应用启动时为你创建 <code>SqlSessionFactory</code>，并使用 <code>sqlSessionFactory</code> 这个名字存储起来。</p>
<blockquote>
<p><strong>定位</strong>: <code>org.mybatis.spring.SqlSessionFactoryBean</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBean</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; &#123;</span><br><span class="line">  <span class="comment">// Spring 初始化 bean 时, 会被调用</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    notNull(dataSource, <span class="string">&quot;Property &#x27;dataSource&#x27; is required&quot;</span>);</span><br><span class="line">    notNull(sqlSessionFactoryBuilder, <span class="string">&quot;Property &#x27;sqlSessionFactoryBuilder&#x27; is required&quot;</span>);</span><br><span class="line">    <span class="comment">// configuration 和 configLocation 不能一起指定</span></span><br><span class="line">    state((configuration == <span class="literal">null</span> &amp;&amp; configLocation == <span class="literal">null</span>) || !(configuration != <span class="literal">null</span> &amp;&amp; configLocation != <span class="literal">null</span>),</span><br><span class="line">      <span class="string">&quot;Property &#x27;configuration&#x27; and &#x27;configLocation&#x27; can not specified with together&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化 SqlSessionFactory</span></span><br><span class="line">    <span class="built_in">this</span>.sqlSessionFactory = buildSqlSessionFactory();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 生成 SqlSessionFactory 对象</span></span><br><span class="line">  <span class="keyword">protected</span> SqlSessionFactory <span class="title function_">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> Configuration targetConfiguration;</span><br><span class="line">    <span class="comment">// 初始化 Configuration 全局配置对象</span></span><br><span class="line">    <span class="type">XMLConfigBuilder</span> <span class="variable">xmlConfigBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.configuration != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果已存在 Configuration 对象</span></span><br><span class="line">      targetConfiguration = <span class="built_in">this</span>.configuration;</span><br><span class="line">      <span class="keyword">if</span> (targetConfiguration.getVariables() == <span class="literal">null</span>) &#123;</span><br><span class="line">        targetConfiguration.setVariables(<span class="built_in">this</span>.configurationProperties);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.configurationProperties != <span class="literal">null</span>) &#123;</span><br><span class="line">        targetConfiguration.getVariables().putAll(<span class="built_in">this</span>.configurationProperties);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 配置了 mybatis-config.xml 配置文件</span></span><br><span class="line">      xmlConfigBuilder = <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(<span class="built_in">this</span>.configLocation.getInputStream(), <span class="literal">null</span>, <span class="built_in">this</span>.configurationProperties);</span><br><span class="line">      targetConfiguration = xmlConfigBuilder.getConfiguration();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Property &#x27;configuration&#x27; or &#x27;configLocation&#x27; not specified, using default MyBatis Configuration&quot;</span>);</span><br><span class="line">      <span class="comment">// 创建一个 Configuration 对象, 使用默认配置</span></span><br><span class="line">      targetConfiguration = <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">      Optional.ofNullable(<span class="built_in">this</span>.configurationProperties).ifPresent(targetConfiguration::setVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果配置了 ObjectFactory（实例工厂）、ObjectWrapperFactory（ObjectWrapper工厂）、VFS（虚拟文件系统）</span></span><br><span class="line"><span class="comment">     * 则分别往 Configuration 全局配置对象设置</span></span><br><span class="line"><span class="comment">     */</span>Optional.ofNullable(<span class="built_in">this</span>.objectFactory).ifPresent(targetConfiguration::setObjectFactory);</span><br><span class="line">Optional.ofNullable(<span class="built_in">this</span>.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);</span><br><span class="line">    Optional.ofNullable(<span class="built_in">this</span>.vfs).ifPresent(targetConfiguration::setVfsImpl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果配置了需要设置别名的包路径，则扫描该包路径下的 Class 对象</span></span><br><span class="line"><span class="comment">     * 往 Configuration 全局配置对象的 TypeAliasRegistry 别名注册表进行注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (hasLength(<span class="built_in">this</span>.typeAliasesPackage)) &#123;</span><br><span class="line">      scanClasses(<span class="built_in">this</span>.typeAliasesPackage, <span class="built_in">this</span>.typeAliasesSuperType).stream()</span><br><span class="line">        <span class="comment">// 过滤掉匿名类</span></span><br><span class="line">        .filter(clazz -&gt; !clazz.isAnonymousClass())</span><br><span class="line">        <span class="comment">// 过滤掉接口</span></span><br><span class="line">        .filter(clazz -&gt; !clazz.isInterface())</span><br><span class="line">        <span class="comment">// 过滤掉内部类</span></span><br><span class="line">        .filter(clazz -&gt; !clazz.isMemberClass())</span><br><span class="line">        .forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果单独配置了需要设置别名的 Class 对象</span></span><br><span class="line"><span class="comment">     * 则将其往 Configuration 全局配置对象的 TypeAliasRegistry 别名注册表注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">this</span>.typeAliases)) &#123;</span><br><span class="line">      Stream.of(<span class="built_in">this</span>.typeAliases).forEach(typeAlias -&gt; &#123;</span><br><span class="line">        targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Registered type alias: &#x27;&quot;</span> + typeAlias + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 Configuration 全局配置对象添加 Interceptor 插件</span></span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">this</span>.plugins)) &#123;</span><br><span class="line">      Stream.of(<span class="built_in">this</span>.plugins).forEach(plugin -&gt; &#123;</span><br><span class="line">        targetConfiguration.addInterceptor(plugin);</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Registered plugin: &#x27;&quot;</span> + plugin + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描包路径，往 Configuration 全局配置对象添加 TypeHandler 类型处理器</span></span><br><span class="line">    <span class="keyword">if</span> (hasLength(<span class="built_in">this</span>.typeHandlersPackage)) &#123;</span><br><span class="line">      scanClasses(<span class="built_in">this</span>.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -&gt; !clazz.isAnonymousClass())</span><br><span class="line">        .filter(clazz -&gt; !clazz.isInterface()).filter(clazz -&gt; !Modifier.isAbstract(clazz.getModifiers()))</span><br><span class="line">        .forEach(targetConfiguration.getTypeHandlerRegistry()::register);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 Configuration 全局配置对象添加 TypeHandler 类型处理器</span></span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">this</span>.typeHandlers)) &#123;</span><br><span class="line">      Stream.of(<span class="built_in">this</span>.typeHandlers).forEach(typeHandler -&gt; &#123;</span><br><span class="line">        targetConfiguration.getTypeHandlerRegistry().register(typeHandler);</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Registered type handler: &#x27;&quot;</span> + typeHandler + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认的枚举类型处理器</span></span><br><span class="line">    targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 Configuration 全局配置对象添加 LanguageDriver 语言驱动</span></span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="built_in">this</span>.scriptingLanguageDrivers)) &#123;</span><br><span class="line">      Stream.of(<span class="built_in">this</span>.scriptingLanguageDrivers).forEach(languageDriver -&gt; &#123;</span><br><span class="line">        targetConfiguration.getLanguageRegistry().register(languageDriver);</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Registered scripting language driver: &#x27;&quot;</span> + languageDriver + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置默认的 LanguageDriver 语言驱动</span></span><br><span class="line">    Optional.ofNullable(<span class="built_in">this</span>.defaultScriptingLanguageDriver)</span><br><span class="line">      .ifPresent(targetConfiguration::setDefaultScriptingLanguage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前数据源的数据库 id</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.databaseIdProvider != <span class="literal">null</span>) &#123;<span class="comment">// fix #64 set databaseId before parse mapper xmls</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        targetConfiguration.setDatabaseId(<span class="built_in">this</span>.databaseIdProvider.getDatabaseId(<span class="built_in">this</span>.dataSource));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed getting a databaseId&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 Cache 缓存</span></span><br><span class="line">    Optional.ofNullable(<span class="built_in">this</span>.cache).ifPresent(targetConfiguration::addCache);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xmlConfigBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 解析 xml 配置文件</span></span><br><span class="line">        xmlConfigBuilder.parse();</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Parsed configuration file: &#x27;&quot;</span> + <span class="built_in">this</span>.configLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed to parse config resource: &quot;</span> + <span class="built_in">this</span>.configLocation, ex);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Environment 环境信息</span></span><br><span class="line">    targetConfiguration.setEnvironment(<span class="keyword">new</span> <span class="title class_">Environment</span>(<span class="built_in">this</span>.environment,</span><br><span class="line">      <span class="built_in">this</span>.transactionFactory == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">SpringManagedTransactionFactory</span>() : <span class="built_in">this</span>.transactionFactory,</span><br><span class="line">      <span class="built_in">this</span>.dataSource));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 配置了 XML 映射文件的路径, 遍历所有的 XML 映射文件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Resource mapperLocation : <span class="built_in">this</span>.mapperLocations) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mapperLocation == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">XMLMapperBuilder</span> <span class="variable">xmlMapperBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(mapperLocation.getInputStream(),</span><br><span class="line">              targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">            <span class="comment">// 解析 XML 映射文件</span></span><br><span class="line">            xmlMapperBuilder.parse();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">          &#125;</span><br><span class="line">          LOGGER.debug(() -&gt; <span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造器创建一个 DefaultSqlSessionFactory 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Spring 事件监听</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// 需要快速失败，并且监听到了 Spring 容器初始化完成事件</span></span><br><span class="line">    <span class="keyword">if</span> (failFast &amp;&amp; event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">      <span class="comment">// fail-fast -&gt; check all statements are completed</span></span><br><span class="line">      <span class="comment">// 将 MyBatis 中还未完全解析的对象，在这里再进行解析</span></span><br><span class="line">      <span class="built_in">this</span>.sqlSessionFactory.getConfiguration().getMappedStatementNames();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 扫描指定包下的指定子类或者子接口, 如果 assignableType 为空, 则返回这个包下的所有类</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; scanClasses(String packagePatterns, Class&lt;?&gt; assignableType) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    String[] packagePatternArray = tokenizeToStringArray(packagePatterns,</span><br><span class="line">        ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">    <span class="keyword">for</span> (String packagePattern : packagePatternArray) &#123;</span><br><span class="line">      <span class="comment">// 获取到 classpath 下包路径下的 Resource 对象</span></span><br><span class="line">      Resource[] resources = RESOURCE_PATTERN_RESOLVER.getResources(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX</span><br><span class="line">          + ClassUtils.convertClassNameToResourcePath(packagePattern) + <span class="string">&quot;/**/*.class&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 获取 Resource 资源的 ClassMetadata 对象</span></span><br><span class="line">          <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> METADATA_READER_FACTORY.getMetadataReader(resource).getClassMetadata();</span><br><span class="line">          Class&lt;?&gt; clazz = Resources.classForName(classMetadata.getClassName());</span><br><span class="line">          <span class="keyword">if</span> (assignableType == <span class="literal">null</span> || assignableType.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            classes.add(clazz);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          LOGGER.warn(() -&gt; <span class="string">&quot;Cannot load the &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause by &quot;</span> + e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例化-Mapper-接口"><a href="#实例化-Mapper-接口" class="headerlink" title="实例化 Mapper 接口"></a>实例化 Mapper 接口</h2><h3 id="扫描-Mapper"><a href="#扫描-Mapper" class="headerlink" title="扫描 Mapper"></a>扫描 Mapper</h3><h4 id="通过定义-MapperScannerConfigurer-的-Spring-bean-对象"><a href="#通过定义-MapperScannerConfigurer-的-Spring-bean-对象" class="headerlink" title="通过定义 MapperScannerConfigurer 的 Spring bean 对象"></a>通过定义 MapperScannerConfigurer 的 Spring bean 对象</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.mybatis.spring.sample.mapper&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 扫描被 Mapper 注解修饰的类(如果在 basePackage 包下存在非 Mapper 接口的文件, 并且不想要被代理, 则需要设置) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;annotationClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.apache.ibatis.annotations.Mapper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="MapperScannerConfigurer"><a href="#MapperScannerConfigurer" class="headerlink" title="MapperScannerConfigurer"></a>MapperScannerConfigurer</h5><blockquote>
<p><strong>定位</strong>: <code>org.mybatis.spring.mapper.MapperScannerConfigurer</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>：用于扫描 Mapper 接口，借助<code>ClassPathMapperScanner</code>扫描器注册 Mapper 接口的BeanDefinition 对象 (注意: 默认情况并没有设置 <code>annotationClass</code> )</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerConfigurer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span>, InitializingBean, ApplicationContextAware, BeanNameAware &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在 BeanDefinitionRegistry 完成后, 扫描 basePackage 下的类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.processPropertyPlaceHolders) &#123;</span><br><span class="line">      <span class="comment">// 处理属性中的占位符</span></span><br><span class="line">      processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个 Bean 扫描器</span></span><br><span class="line">    <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">    <span class="comment">// 是否要将 Mapper 接口添加到 Configuration 全局配置对象中</span></span><br><span class="line">    scanner.setAddToConfig(<span class="built_in">this</span>.addToConfig);</span><br><span class="line">    <span class="comment">// 如果 annotationClass 不为空，则扫描被 annotationClass 注解修饰的类</span></span><br><span class="line">    scanner.setAnnotationClass(<span class="built_in">this</span>.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(<span class="built_in">this</span>.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">    scanner.setSqlSessionTemplate(<span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">    <span class="comment">// 设置 SqlSessionFactory 的 BeanName</span></span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(<span class="built_in">this</span>.sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(<span class="built_in">this</span>.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(<span class="built_in">this</span>.nameGenerator);</span><br><span class="line">    scanner.setMapperFactoryBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(defaultScope)) &#123;</span><br><span class="line">      scanner.setDefaultScope(defaultScope);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 会根据 annotationClass, markerInterface 生成过滤器</span></span><br><span class="line">    <span class="comment">// 添加几个过滤器</span></span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    scanner.scan(StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ClassPathMapperScanner"><a href="#ClassPathMapperScanner" class="headerlink" title="ClassPathMapperScanner"></a>ClassPathMapperScanner</h5><blockquote>
<p><strong>定位:</strong> <code>org.mybatis.spring.mapper.ClassPathMapperScanner</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>: 负责执行扫描，将用户配置信息，设置到扫描到的 Mapper 接口的 BeanDefinition 对象，如将 BeanClass 修改为 MapperFactoryBean，将 autowireMode 设置为根据类型注入，可以让 Spring 实例化的时候，会使用 <code>MapperFactoryBean</code> 类型，并自动注入 SqlSessionFactory 实例，实现创建 Mapper 动态代理对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerFilters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 标记是否接受所有接口</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">acceptAllInterfaces</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// if specified, use the given annotation and / or marker interface</span></span><br><span class="line">    <span class="comment">// 如果配置了注解，则扫描有该注解的 Mapper 接口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.annotationClass != <span class="literal">null</span>) &#123;</span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(<span class="built_in">this</span>.annotationClass));</span><br><span class="line">      acceptAllInterfaces = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// override AssignableTypeFilter to ignore matches on the actual marker interface</span></span><br><span class="line">    <span class="comment">// 如果配置了某个接口，则也需要扫描该接口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.markerInterface != <span class="literal">null</span>) &#123;</span><br><span class="line">      addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AssignableTypeFilter</span>(<span class="built_in">this</span>.markerInterface) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">matchClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      acceptAllInterfaces = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acceptAllInterfaces) &#123;</span><br><span class="line">      <span class="comment">// default include filter that accepts all classes</span></span><br><span class="line">      <span class="comment">// 如果上面两个都没有配置，则接受所有的类</span></span><br><span class="line">      addIncludeFilter((metadataReader, metadataReaderFactory) -&gt; <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exclude package-info.java</span></span><br><span class="line">    <span class="comment">// 排除 package-info.java 文件</span></span><br><span class="line">    addExcludeFilter((metadataReader, metadataReaderFactory) -&gt; &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> metadataReader.getClassMetadata().getClassName();</span><br><span class="line">      <span class="keyword">return</span> className.endsWith(<span class="string">&quot;package-info&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="comment">// 扫描指定包路径，根据上面的过滤器，获取到路径下 Class 对象的 BeanDefinition 对象</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      LOGGER.warn(() -&gt; <span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages)</span><br><span class="line">          + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 后置处理这些 BeanDefinition</span></span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> &#123;</span><br><span class="line">    AbstractBeanDefinition definition;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 获取 BeanDefinition 注册表，然后开始遍历</span></span><br><span class="line">    <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> getRegistry();</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (AbstractBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">scopedProxy</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (ScopedProxyFactoryBean.class.getName().equals(definition.getBeanClassName())) &#123;</span><br><span class="line">        <span class="comment">// 获取被装饰的 BeanDefinition 对象</span></span><br><span class="line">        definition = (AbstractBeanDefinition) Optional</span><br><span class="line">            .ofNullable(((RootBeanDefinition) definition).getDecoratedDefinition())</span><br><span class="line">            .map(BeanDefinitionHolder::getBeanDefinition).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">&quot;The target bean definition of scoped proxy bean not found. Root bean definition[&quot;</span> + holder + <span class="string">&quot;]&quot;</span>));</span><br><span class="line">        scopedProxy = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// &lt;2&gt; 获取对应的 Bean 的 Class 名称，也就是 Mapper 接口的 Class 对象</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> definition.getBeanClassName();</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Creating MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + beanClassName</span><br><span class="line">          + <span class="string">&quot;&#x27; mapperInterface&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">      <span class="comment">// but, the actual class of the bean is MapperFactoryBean</span></span><br><span class="line">      <span class="comment">// &lt;3&gt; 往构造方法的参数列表中添加一个参数，为当前 Mapper 接口的 Class 对象</span></span><br><span class="line">      definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); <span class="comment">// issue #59</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * &lt;4&gt; 修改该 Mapper 接口的 Class对象 为 MapperFactoryBean.class</span></span><br><span class="line"><span class="comment">       * 这样一来当你注入该 Mapper 接口的时候，实际注入的是 MapperFactoryBean 对象，构造方法的入参就是 Mapper 接口</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      definition.setBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// &lt;5&gt; 添加 addToConfig 属性</span></span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;addToConfig&quot;</span>, <span class="built_in">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">explicitFactoryUsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// &lt;6&gt; 开始添加 sqlSessionFactory 或者 sqlSessionTemplate 属性</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">        <span class="comment">// 设置了 sqlSessionFactoryBeanName，则添加 sqlSessionFactory 对象的引用</span></span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(<span class="built_in">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 配置了 sqlSessionFactory 对象，则设置 sqlSessionFactory 属性值</span></span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>, <span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          <span class="comment">// 如果上面已经清楚的使用了 SqlSessionFactory，则打印一个警告</span></span><br><span class="line">          LOGGER.warn(() -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 配置了 sqlSessionTemplateBeanName，则添加 sqlSessionTemplate 对象的引用</span></span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(<span class="built_in">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionTemplate != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          LOGGER.warn(() -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 配置了 sqlSessionTemplate 对象，则设置 sqlSessionTemplate 属性值</span></span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>, <span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 上面没有找到对应的 SqlSessionFactory，则设置通过类型注入</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        <span class="comment">// Mapper 接口初始化中会自动根据类型注入 SqlSessionFactory 的实例</span></span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      definition.setLazyInit(lazyInitialization);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (scopedProxy) &#123;</span><br><span class="line">        <span class="comment">// 已经封装过的则直接执行下一个</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ConfigurableBeanFactory.SCOPE_SINGLETON.equals(definition.getScope()) &amp;&amp; defaultScope != <span class="literal">null</span>) &#123;</span><br><span class="line">        definition.setScope(defaultScope);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果不是单例模式，默认是</span></span><br><span class="line"><span class="comment">       * 将 BeanDefinition 在封装一层进行注册</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!definition.isSingleton()) &#123;</span><br><span class="line">        <span class="type">BeanDefinitionHolder</span> <span class="variable">proxyHolder</span> <span class="operator">=</span> ScopedProxyUtils.createScopedProxy(holder, registry, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (registry.containsBeanDefinition(proxyHolder.getBeanName())) &#123;</span><br><span class="line">          registry.removeBeanDefinition(proxyHolder.getBeanName());</span><br><span class="line">        &#125;</span><br><span class="line">        registry.registerBeanDefinition(proxyHolder.getBeanName(), proxyHolder.getBeanDefinition());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">    <span class="comment">// 必须是接口, 并且是顶级了或者内部类</span></span><br><span class="line">    <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过注解-MapperScan-扫描"><a href="#通过注解-MapperScan-扫描" class="headerlink" title="通过注解 @MapperScan 扫描"></a>通过注解 @MapperScan 扫描</h4><p>使用例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@MapperScan(value = &quot;org.mybatis.spring.sample.mapper&quot;, annotationClass = Mapper.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="MapperScan-注解"><a href="#MapperScan-注解" class="headerlink" title="MapperScan 注解"></a>MapperScan 注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MapperScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Repeatable(MapperScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line"></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanNameGenerator</span>&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator.class;</span><br><span class="line"></span><br><span class="line">  Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass() <span class="keyword">default</span> Annotation.class;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; markerInterface() <span class="keyword">default</span> Class.class;</span><br><span class="line"></span><br><span class="line">  String <span class="title function_">sqlSessionTemplateRef</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  String <span class="title function_">sqlSessionFactoryRef</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  Class&lt;? <span class="keyword">extends</span> <span class="title class_">MapperFactoryBean</span>&gt; factoryBean() <span class="keyword">default</span> MapperFactoryBean.class;</span><br><span class="line"></span><br><span class="line">  String <span class="title function_">lazyInitialization</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  String <span class="title function_">defaultScope</span><span class="params">()</span> <span class="keyword">default</span> AbstractBeanDefinition.SCOPE_DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="MapperScannerRegistrar"><a href="#MapperScannerRegistrar" class="headerlink" title="MapperScannerRegistrar"></a>MapperScannerRegistrar</h5><blockquote>
<p><strong>定位</strong>: <code>org.mybatis.spring.annotation.MapperScannerRegistrar</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>: <code>@MapperScann</code> 的注册器，根据注解信息注册 <code>MapperScannerConfigurer</code> 对象，用于扫描 Mapper 接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, ResourceLoaderAware &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">mapperScanAttrs</span> <span class="operator">=</span> AnnotationAttributes</span><br><span class="line">.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    <span class="keyword">if</span> (mapperScanAttrs != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将 MapperScan 的注解信息封装成 MapperScannerConfigurer BeanDefinition 对象, 并注册到 Spring 中</span></span><br><span class="line">      registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,</span><br><span class="line">          generateBaseBeanName(importingClassMetadata, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过-Mybatis-Spring-的-xml-配置-基本不用"><a href="#通过-Mybatis-Spring-的-xml-配置-基本不用" class="headerlink" title="通过 Mybatis-Spring 的 xml 配置(基本不用)"></a>通过 Mybatis-Spring 的 xml 配置(基本不用)</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:mybatis</span>=<span class="string">&quot;http://mybatis.org/schema/mybatis-spring&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mybatis:scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.mybatis.spring.sample.mapper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;mybatis:scan /&gt;</code> 的解析器 <code>org.mybatis.spring.config.MapperScannerBeanDefinitionParser</code>, 实现原理等同于 <code>MapperScannerRegistrar</code>, 解析 <code>mybatis:scan</code> 配置的标签信息并注册 <code>MapperScannerConfigurer</code> 对象</p>
<h3 id="实例化-Mapper"><a href="#实例化-Mapper" class="headerlink" title="实例化 Mapper"></a>实例化 Mapper</h3><h3 id="MapperFactoryBean"><a href="#MapperFactoryBean" class="headerlink" title="MapperFactoryBean"></a>MapperFactoryBean</h3><blockquote>
<p><strong>定位</strong>: <code>org.mybatis.spring.mapper.MapperFactoryBean</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>: 实现 FactoryBean 接口，继承 SqlSessionDaoSupport 抽象类，Mapper 接口对应 Spring Bean 对象，用于返回对应的动态代理对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperFactoryBean</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 继承了 DaoSupport 接口，它实现了 InitializingBean 接口</span></span><br><span class="line"><span class="comment">   * 则在 Spring 容器中初始化该 Bean 的 afterPropertiesSet() 方法，也就调用该方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">checkDaoConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 校验 sqlSessionTemplate 非空</span></span><br><span class="line">    <span class="built_in">super</span>.checkDaoConfig();</span><br><span class="line">    notNull(<span class="built_in">this</span>.mapperInterface, <span class="string">&quot;Property &#x27;mapperInterface&#x27; is required&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果该 Mapper 接口没有被解析至 Configuration，则对其进行解析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> getSqlSession().getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class="built_in">this</span>.mapperInterface)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将该 Mapper 接口添加至 Configuration，会对该接口进行一系列的解析</span></span><br><span class="line">        configuration.addMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Error while adding the mapper &#x27;&quot;</span> + <span class="built_in">this</span>.mapperInterface + <span class="string">&quot;&#x27; to configuration.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在 Spring 容器中，注入当前 Bean 时调用该方法，也就是返回 Mapper 接口的动态代理对象（代理类为&#123;<span class="doctag">@link</span> org.apache.ibatis.binding.MapperProxy&#125;）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// getSqlSession() 方法返回 SqlSessionTemplate 对象</span></span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SqlSessionDaoSupport"><a href="#SqlSessionDaoSupport" class="headerlink" title="SqlSessionDaoSupport"></a>SqlSessionDaoSupport</h4><blockquote>
<p><strong>定位</strong>: <code>org.mybatis.spring.support.SqlSessionDaoSupport</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title class_">DaoSupport</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line">  <span class="comment">// 设置 DAO 使用的 MyBatis SqlSessionFactory, 并根据给定的 SqlSessionFactory 创建 SqlSessionTemplate 对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionTemplate == <span class="literal">null</span> || sqlSessionFactory != <span class="built_in">this</span>.sqlSessionTemplate.getSqlSessionFactory()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.sqlSessionTemplate = createSqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据 sqlSessionFactory 创建 SqlSessionTemplate 对象</span></span><br><span class="line">  <span class="keyword">protected</span> SqlSessionTemplate <span class="title function_">createSqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 显式设置 DAO 的 SqlSessionTemplate，作为指定 SqlSessionFactory 的替代方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionTemplate</span><span class="params">(SqlSessionTemplate sqlSessionTemplate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sqlSessionTemplate = sqlSessionTemplate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SqlSessionTemplate"><a href="#SqlSessionTemplate" class="headerlink" title="SqlSessionTemplate"></a>SqlSessionTemplate</h4><p><code>SqlSessionTemplate</code> 是 MyBatis-Spring 的核心。作为 <code>SqlSession</code> 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 <code>SqlSession</code>。 <code>SqlSessionTemplate</code> 是线程安全的，可以被多个 DAO 或映射器所共享使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title class_">SqlSession</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span><br><span class="line"><span class="params">                            PersistenceExceptionTranslator exceptionTranslator)</span> &#123;</span><br><span class="line"></span><br><span class="line">    notNull(sqlSessionFactory, <span class="string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);</span><br><span class="line">    notNull(executorType, <span class="string">&quot;Property &#x27;executorType&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    <span class="built_in">this</span>.executorType = executorType;</span><br><span class="line">    <span class="built_in">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">    <span class="comment">// 创建一个 SqlSession 的动态代理对象，代理类为 SqlSessionInterceptor</span></span><br><span class="line">    <span class="built_in">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; SqlSession.class &#125;, <span class="keyword">new</span> <span class="title class_">SqlSessionInterceptor</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionProxy.selectCursor(statement, parameter, rowBounds);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionProxy.selectList(statement, parameter, rowBounds);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionProxy.update(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 。。。</span></span><br><span class="line">  <span class="comment">// 基本所有 SqlSession 接口的方法, 都由 sqlSessionProxy 来进行调用</span></span><br><span class="line">  <span class="comment">// 。。。</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getConfiguration().getMapper(type, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// JDK 代理 Handler</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="comment">// 获取 SqlSession 对象</span></span><br><span class="line">      <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession(SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory,</span><br><span class="line">          SqlSessionTemplate.<span class="built_in">this</span>.executorType, SqlSessionTemplate.<span class="built_in">this</span>.exceptionTranslator);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 SqlSession 的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(sqlSession, args);</span><br><span class="line">        <span class="comment">// 当前 SqlSession 不是 Spring 托管的事务</span></span><br><span class="line">        <span class="keyword">if</span> (!SqlSessionUtils.isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">          <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">          <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">          <span class="comment">// 强制提交</span></span><br><span class="line">          sqlSession.commit(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">unwrapped</span> <span class="operator">=</span> unwrapThrowable(t);</span><br><span class="line">        <span class="keyword">if</span> (SqlSessionTemplate.<span class="built_in">this</span>.exceptionTranslator != <span class="literal">null</span> &amp;&amp; unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">          <span class="comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span></span><br><span class="line">          <span class="comment">// 关闭 SqlSession 会话，释放资源</span></span><br><span class="line">          SqlSessionUtils.closeSqlSession(sqlSession, SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">          sqlSession = <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">// 对异常进行转换，差不多就是转换成 MyBatis 的异常</span></span><br><span class="line">          <span class="type">Throwable</span> <span class="variable">translated</span> <span class="operator">=</span> SqlSessionTemplate.<span class="built_in">this</span>.exceptionTranslator</span><br><span class="line">              .translateExceptionIfPossible((PersistenceException) unwrapped);</span><br><span class="line">          <span class="keyword">if</span> (translated != <span class="literal">null</span>) &#123;</span><br><span class="line">            unwrapped = translated;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> unwrapped;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlSession != <span class="literal">null</span>) &#123;</span><br><span class="line">          SqlSessionUtils.closeSqlSession(sqlSession, SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取当前的-sqlSession"><a href="#获取当前的-sqlSession" class="headerlink" title="获取当前的 sqlSession"></a>获取当前的 sqlSession</h4><blockquote>
<p><strong>定位</strong>: <code>org.mybatis.spring.SqlSessionUtils#getSqlSession</code></p>
</blockquote>
<blockquote>
<p><strong>作用</strong>: 从当前线程变量中获取 SqlSession，如果不存在，则创建一个, 并将新创建的 SQL Session 添加到线程变量中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> &#123;</span><br><span class="line"></span><br><span class="line">  notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);</span><br><span class="line">  notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从 Spring 事务管理器中获取一个 SqlSessionHolder 对象</span></span><br><span class="line">  <span class="type">SqlSessionHolder</span> <span class="variable">holder</span> <span class="operator">=</span> (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line">  <span class="comment">// 获取到 SqlSession 对象</span></span><br><span class="line">  <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sessionHolder(executorType, holder);</span><br><span class="line">  <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上面没有获取到，则创建一个 SqlSession</span></span><br><span class="line">  session = sessionFactory.openSession(executorType);</span><br><span class="line">  <span class="comment">// 将上面创建的 SqlSession 封装成 SqlSessionHolder，往 Spring 事务管理器注册</span></span><br><span class="line">  registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line">  <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 sqlSession 对象注册到当前线程变量中</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerSessionHolder</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType,  PersistenceExceptionTranslator exceptionTranslator, SqlSession session)</span> &#123;</span><br><span class="line">  SqlSessionHolder holder;</span><br><span class="line">  <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">    <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> sessionFactory.getConfiguration().getEnvironment();</span><br><span class="line">    <span class="comment">// &lt;1&gt; 如果使用 Spring 事务管理器</span></span><br><span class="line">    <span class="keyword">if</span> (environment.getTransactionFactory() <span class="keyword">instanceof</span> SpringManagedTransactionFactory) &#123;</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Registering transaction synchronization for SqlSession [&quot;</span> + session + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      <span class="comment">// &lt;1.1&gt; 创建 SqlSessionHolder 对象</span></span><br><span class="line">      holder = <span class="keyword">new</span> <span class="title class_">SqlSessionHolder</span>(session, executorType, exceptionTranslator);</span><br><span class="line">      <span class="comment">// &lt;1.2&gt; 绑定到 TransactionSynchronizationManager 中</span></span><br><span class="line">      TransactionSynchronizationManager.bindResource(sessionFactory, holder);</span><br><span class="line">      <span class="comment">// &lt;1.3&gt; 创建 SqlSessionSynchronization 到 TransactionSynchronizationManager 中</span></span><br><span class="line">      TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> <span class="title class_">SqlSessionSynchronization</span>(holder, sessionFactory));</span><br><span class="line">      <span class="comment">// &lt;1.4&gt; 设置同步</span></span><br><span class="line">      holder.setSynchronizedWithTransaction(<span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// &lt;1.5&gt; 增加计数</span></span><br><span class="line">      holder.requested();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// &lt;2&gt; 如果非 Spring 事务管理器，抛出 TransientDataAccessResourceException 异常</span></span><br><span class="line">      <span class="keyword">if</span> (TransactionSynchronizationManager.getResource(environment.getDataSource()) == <span class="literal">null</span>) &#123;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;SqlSession [&quot;</span> + session</span><br><span class="line">            + <span class="string">&quot;] was not registered for synchronization because DataSource is not transactional&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransientDataAccessResourceException</span>(</span><br><span class="line">            <span class="string">&quot;SqlSessionFactory must be using a SpringManagedTransactionFactory in order to use Spring transaction synchronization&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;SqlSession [&quot;</span> + session</span><br><span class="line">        + <span class="string">&quot;] was not registered for synchronization because synchronization is not active&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SqlSession-和-Mapper-关系"><a href="#SqlSession-和-Mapper-关系" class="headerlink" title="SqlSession 和 Mapper 关系"></a>SqlSession 和 Mapper 关系</h2><p>在 Mybatis 中,  每次打开 openSession 后, 都会创建一个新的 SqlSession 实例, 在从 SqlSession 中获取 Mapper 实例时, 也会创建一个新的 Mapper 代理对象；</p>
<p>在 Mybatis-Spring 中, Mapper 的代理对象由 Spring 容器的 MapperFactoryBean 对象创建, 并且为单例的，每次调用 Mapper 的增删改查时，会先 openSession ( 创建一个新 SqlSession 实例) 后, 通过 ThreadLocal 来实现当前线程持有当前的 SqlSession 实例对象</p>
<h2 id="Mybatis-Spring-事务托管"><a href="#Mybatis-Spring-事务托管" class="headerlink" title="Mybatis-Spring 事务托管"></a>Mybatis-Spring 事务托管</h2><p>使用 MyBatis-Spring 的其中一个主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而不是给 MyBatis 创建一个新的专用事务管理器，MyBatis-Spring 借助了 Spring 中的 <code>DataSourceTransactionManager</code> 来实现事务管理。</p>
<p>一旦配置好了 Spring 的事务管理器，你就可以在 Spring 中按你平时的方式来配置事务。并且支持 <code>@Transactional</code> 注解和 AOP 风格的配置。在事务处理期间，一个单独的 <code>SqlSession</code> 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>编程式事务管理案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PlatformTransactionManager transactionManager;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(PlatformTransactionManager transactionManager)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.transactionManager = transactionManager;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TransactionTemplate</span> <span class="variable">transactionTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(transactionManager);</span><br><span class="line">    transactionTemplate.execute(txStatus -&gt; &#123;</span><br><span class="line">      userMapper.insertUser(user);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://mybatis.org/spring/zh/index.html">https://mybatis.org/spring/zh/index.html</a></p>
<p><a href="https://github.com/liu844869663/mybatis-spring/">mybatis-spring 注释源码</a></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>源码</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 设计模式</title>
    <url>/2020/11/26/Mybatis/Mybatis09/</url>
    <content><![CDATA[<h3 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h3><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>私有构造器, 对外提供实例方法</p>
<ul>
<li>ErrorContext</li>
<li>LogFactory</li>
</ul>
<h3 id="构造者模式"><a href="#构造者模式" class="headerlink" title="构造者模式"></a>构造者模式</h3><p>封装复杂的创建对象的过程, 通过 build 方法生成对象实例</p>
<ul>
<li>SqlSessionFactoryBuilder: 构建 SqlSessionFactory 对象</li>
<li>XMLConfigBuilder: 解析整个Mybatis的配置</li>
<li>XMLMapperBuilder：解析Mapper映射器</li>
<li>XMLStatementBuilder：解析增删改查标签</li>
<li>XMLScriptBuilder：解析动态SQL</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>通过工厂创建出具体的对象</p>
<ul>
<li>SqlSessionFactory</li>
<li>MapperProxyFactory</li>
<li>DataSourceFactory</li>
</ul>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>Mybatis 中定义方法的时候使用的都是接口的方式，接口是不能进行实例化操作的，因此在使用具体对象的时候需要使用动态代理来创建出具体的代理对象 MapperProxy</p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>Cache 包下，Cache是一个接口，具体的子类实现是 PertualCache, 在 decorators 包下包含了一系列的其他实现，通过装饰者模式实现的(如：WeakCache / BlockingCache / LruCache / FifoCache)</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><ul>
<li>ChooseSqlNode</li>
<li>IfSqlNode</li>
</ul>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>Executor,BaseTypeHandler,IntegerTypeHandler…..</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>在 plugins 模块中，包含了 interceptor,  interceptorChain</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>日志模块使用适配器模式，各个子包实现</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>PropertyTokenizer</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>源码</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Log4J日志打印引发的OOM问题排查</title>
    <url>/2022/09/11/Question/Log4J%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E5%BC%95%E5%8F%91%E7%9A%84OOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote>
<p>服务在没有预警的情况下莫名重启; 经过查询日志平台, 发现以下的日志</p>
</blockquote>
<blockquote>
<p>java.lang.OutOfMemoryError: Java heap space<br>Dumping heap to /dump/service_name_a1b21.hprof …<br>Heap dump file created [1568487987 bytes in 9.043 secs]</p>
</blockquote>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><ol>
<li>下载 service_name_a1b21.hprof 堆的 dump 文件</li>
<li>使用 Eclipse Memory Analyzer 打开 hprof 文件</li>
<li>打开 Leak Suspects 扇形图 <img src="/images/20220912/mat_a1.png" alt="Leak Suspects"></li>
<li>查询错误栈信息 <img src="/images/20220912/mat_a2.png" alt="stacktrace.png"></li>
<li>查看 Dominator Tree(支配树)<img src="/images/20220912/mat_a3.png" alt="Dominator Tree.png"><br>根据 Retain Heap 排序, 发现 char[]0x7c0400000;char[]0x7aa100000;char[]0x791500000, 三个字符串内容基本相同, 并且占用内存较大<br>结合错误栈信息和代码, 定位出是由于日志打印所需的字符串参数拼接时, 无法分配足够的内存导致的</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>尽量减少打印内容(如为空字段无需打印)</li>
<li>调整打印方式, 对于大批量的数据, 分批次打印甚至不打印</li>
</ol>
<h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/qq_19922839/article/details/120731372">Eclipse MAT 工具使用说明</a></p>
<p><a href="https://mianshenglee.github.io/2019/08/29/java-monitor-6.html">Eclipse MAT 工具概念说明</a></p>
<h4 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h4><p><strong>下载</strong></p>
<p><a href="https://www.eclipse.org/mat/downloads.php">最新版本</a><br><a href="https://www.eclipse.org/mat/previousReleases.php">历史版本</a></p>
<blockquote>
<p>最新可使用jdk8的版本: Memory Analyzer 1.10.0 Release</p>
</blockquote>
<p><strong>概念说明</strong></p>
<ul>
<li><p><code>outgoing references</code> ：表示该对象的出节点（被该对象引用的对象）。</p>
</li>
<li><p><code>incoming references</code> ：表示该对象的入节点（引用到该对象的对象）。</p>
</li>
</ul>
<h4 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h4><p><a href="https://blog.csdn.net/gw5205566/article/details/105666637">JVisualVM</a></p>
<blockquote>
<p>下载 dump 文件<br>jmap -dump:format=b,file=文件名 进程PID<br>实时查看 JVM 内存<br>命令：jmap -header 进程PID; 图形化工具: jconsole</p>
</blockquote>
<h4 id="同类代码"><a href="#同类代码" class="headerlink" title="同类代码"></a>同类代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.codehaus.jackson.map.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Jvm 参数: -Xmx30m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\develop\mat\workspace\test</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * -Xmx30m: 堆内存设置为 30M</span></span><br><span class="line"><span class="comment"> * -XX:+HeapDumpOnOutOfMemoryError 当JVM发生OOM时，自动生成 DUMP 文件。</span></span><br><span class="line"><span class="comment"> * -XX:HeapDumpPath=D:\develop\mat\workspace\test 参数表示生成 DUMP 文件的路径或者文件路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> devinx3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DumpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BYTE_TO_MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> mockData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">contentMemory</span> <span class="operator">=</span> getContentMemory(toJSON(data));</span><br><span class="line">        <span class="comment">// 打印字节大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;mock data json size = &quot;</span> + contentMemory + <span class="string">&quot; Byte; &quot;</span> + contentMemory / <span class="number">1024</span> / <span class="number">1024.0</span> + <span class="string">&quot; Mb&quot;</span>);</span><br><span class="line">        log(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串内容占用内存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getContentMemory</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str.length() * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mock 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">mockData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(BYTE_TO_MB);</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> BYTE_TO_MB / <span class="number">2</span> * times - random.nextInt(BYTE_TO_MB / <span class="number">8</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">singleTimes</span> <span class="operator">=</span> total / times;</span><br><span class="line">        List&lt;<span class="type">char</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="comment">// 2M</span></span><br><span class="line">            <span class="type">char</span>[] bytes = <span class="keyword">new</span> <span class="title class_">char</span>[singleTimes];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bytes.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                bytes[j] = (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + random.nextInt(<span class="number">10</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转成 JSON 字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toJSON</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsString(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        printMemory();</span><br><span class="line">        <span class="comment">// 问题发生点</span></span><br><span class="line">        LoggerFactory.getLogger(DumpTest.class).debug(<span class="string">&quot;log_obj: &#123;&#125;&quot;</span>, toJSON(obj));</span><br><span class="line">        printMemory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印内存使用情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 睡眠 100ms</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">// 虚拟机级内存情况查询</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> rt.maxMemory();</span><br><span class="line">        <span class="type">long</span> <span class="variable">free</span> <span class="operator">=</span> rt.freeMemory();</span><br><span class="line">        <span class="type">long</span> <span class="variable">usable</span> <span class="operator">=</span> max - free;</span><br><span class="line">        System.out.println(<span class="string">&quot;================================================================&quot;</span> + date);</span><br><span class="line">        System.out.println(<span class="string">&quot;JVM已使用内存 = &quot;</span> + (usable / BYTE_TO_MB));</span><br><span class="line">        System.out.println(<span class="string">&quot;JVM未使用内存 = &quot;</span> + (free / BYTE_TO_MB));</span><br><span class="line">        System.out.println(<span class="string">&quot;JVM最大(已分配)内存 = &quot;</span> + (max / BYTE_TO_MB));</span><br><span class="line">        System.out.println(<span class="string">&quot;================================================================&quot;</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>MAT</tag>
        <tag>Eclipse Memory Analyzer</tag>
        <tag>内存分析</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenVPN 连接错误 TLS error: Unsupported protocol. </title>
    <url>/2021/10/18/Question/%E8%BF%9E%E6%8E%A5%20OpenVPN%20%E5%87%BA%E7%8E%B0TLS%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="OpenVPN-连接错误-TLS-error-Unsupported-protocol"><a href="#OpenVPN-连接错误-TLS-error-Unsupported-protocol" class="headerlink" title="OpenVPN 连接错误 TLS error: Unsupported protocol."></a>OpenVPN 连接错误 TLS error: Unsupported protocol.</h1><h4 id="场景：连接VPN出现如下报错"><a href="#场景：连接VPN出现如下报错" class="headerlink" title="场景：连接VPN出现如下报错"></a>场景：连接VPN出现如下报错</h4><p><code>sudo journalctl -u NetworkManager -f -n 30</code></p>
<p>nm-openvpn[4327]: TLS error: Unsupported protocol. This typically<br>  indicates that client and server have no common TLS version enabled.<br>  This can be caused by mismatched tls-version-min and tls-version-max<br>  options on client and server. If your OpenVPN client is between v2.3.6<br>  and v2.3.2 try adding tls-version-min 1.0 to the client configuration<br>  to use TLS 1.0+ instead of TLS 1.0 only<br>nm-openvpn[4327]: OpenSSL: error:1425F102:SSL routines:ssl_choose_client_version:unsupported protocol<br>nm-openvpn[4327]: TLS_ERROR: BIO read tls_read_plaintext error<br>nm-openvpn[4327]: TLS Error: TLS object -&gt; incoming plaintext read error<br>nm-openvpn[4327]: TLS Error: TLS handshake failed<br>nm-openvpn[4327]: Fatal TLS error (check_tls_errors_co), restarting<br>nm-openvpn[4327]: SIGUSR1[soft,tls-error] received, process restarting</p>
<h4 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h4><p>系统：Deepin v20 </p>
<p>架构: amd64 (x86_64)</p>
<p>内核: Linux 5.10.50-adm64-desktop</p>
<p>包: network-manager-openvpn/1.8.10-1</p>
<h4 id="解决方案：参考stackoverflow-的回答-分成三种方案："><a href="#解决方案：参考stackoverflow-的回答-分成三种方案：" class="headerlink" title="解决方案：参考stackoverflow 的回答, 分成三种方案："></a>解决方案：参考stackoverflow 的回答, 分成三种方案：</h4><p><a href="https://stackoverflow.com/questions/53058362/openssl-v1-1-1-ssl-choose-client-version-unsupported-protocol">https://stackoverflow.com/questions/53058362/openssl-v1-1-1-ssl-choose-client-version-unsupported-protocol</a></p>
<h6 id="方案1：配置-VPN-客户端以允许-TLS-1-0-版-tls-version-min-1-0-；"><a href="#方案1：配置-VPN-客户端以允许-TLS-1-0-版-tls-version-min-1-0-；" class="headerlink" title="方案1：配置 VPN 客户端以允许 TLS 1.0 版 (tls-version-min 1.0)；"></a>方案1：配置 VPN 客户端以允许 TLS 1.0 版 (tls-version-min 1.0)；</h6><p>但是由于使用 GUI 客户端导致 tls-version-min 无法生效，(network-manager-openvpn 不支持), 所以需要 <strong>升级 network-manager-openvpn</strong> 到  network-manager-openvpn/1.8.12-1；或者使用 openvpn 指定配置文件运行, 并在配置文件中 添加 <code>tls-version-min 1.0</code></p>
<h6 id="方案2：调整系统范围的-OpenSSL-MinProtocol-设置；"><a href="#方案2：调整系统范围的-OpenSSL-MinProtocol-设置；" class="headerlink" title="方案2：调整系统范围的 OpenSSL MinProtocol 设置；"></a>方案2：调整系统范围的 OpenSSL MinProtocol 设置；</h6><p>Deepin20 现在至少需要 TLS 1.2 版本而不是 TLS 1.0。如果服务器不支持 TLS 1.2 或更高版本，您将收到一些连接错误。所以可以更改 /etc/ssl/openssl.cnf 配置文件。修改文件末尾：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[system_default_sect]</span></span><br><span class="line"><span class="attr">MinProtocol</span> = TLSv1.<span class="number">0</span> <span class="comment"># 修改此行, 原值 TLSv1.2</span></span><br><span class="line"><span class="attr">CipherString</span> = DEFAULT@SECLEVEL=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h6 id="方案3：调整OpenVPN服务器的-TLS-版本。"><a href="#方案3：调整OpenVPN服务器的-TLS-版本。" class="headerlink" title="方案3：调整OpenVPN服务器的 TLS 版本。"></a>方案3：调整OpenVPN服务器的 TLS 版本。</h6>]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>Software</tag>
        <tag>Question</tag>
        <tag>OpenVPN</tag>
        <tag>Deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 源码学习</title>
    <url>/2020/10/26/SpringMVC/SpringMVC00/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当踏上阅读 Spring MVC 源码的旅程，将迎来一场对框架内部运作的深入探索。通过阅读源码，将不仅加深对框架的理解，还能提升的编程技能。<br>在这个系列中，我们将从 DispatcherServlet 这个请求处理的入口点开始，会一步步深入的代码分析和注释解读，将能够更好地理解每个组件的作用和相互关系。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><a href="../SpringMVC01">SpringMVC 源码之启动</a></p>
<p><a href="../SpringMVC02">SpringMVC 源码之多个容器加载</a></p>
<p><a href="../SpringMVC03">SpringMVC 源码之加九大组件初始化</a></p>
<p><a href="../SpringMVC04">SpringMVC 源码之网络请求(1)</a></p>
<p><a href="../SpringMVC05">SpringMVC 源码之网络请求(2)</a></p>
<p><a href="../SpringMVC06">SpringMVC 源码之网络请求(3)</a></p>
<p><a href="../SpringMVC07">SpringMVC 源码之网络请求(4)</a></p>
<p><a href="../SpringMVC08">SpringMVC 源码之异步处理</a></p>
<p><a href="../SpringMVC09">SpringMVC 源码之常用接口</a></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">官网</a><br><a href="https://gitee.com/devinx3/learn-spring-framework5.2">源码注释</a></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 源码之容器配置及启动</title>
    <url>/2020/10/26/SpringMVC/SpringMVC01/</url>
    <content><![CDATA[<h2 id="Java-Web项目中的一个配置文件"><a href="#Java-Web项目中的一个配置文件" class="headerlink" title="Java Web项目中的一个配置文件"></a>Java Web项目中的一个配置文件</h2><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring 配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- org.springframework.web.context.ContextLoader#initWebApplicationContext --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring-container.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC 配置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- org.springframework.web.servlet.DispatcherServlet#init --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc-container.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h2><p>通过注册 Web 服务器的监听器 ContextLoaderListener, 加载 Spring 配置文件并启动;<br>在加载Servlet时, DispatcherServlet 引导 SpringMVC 启动;<br>通过启动 SpringMVC 事件加载内置组件(可覆盖 <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties">DispatcherServlet.properties</a> 自定义配置)。  </p>
<blockquote>
<p>SpringBoot 中的顺序是不一样的, 是由Spring内嵌 使用 Spring 配置来引导自身和嵌入式 Servlet 容器。 Filter 和 Servlet 声明在 Spring 配置中检测到并在 Servlet 容器中注册。有关更多详细信息参阅 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container">Spring 文档</a>。</p>
</blockquote>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html">DispatcherServlet</a></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 源码之多个容器加载</title>
    <url>/2020/10/26/SpringMVC/SpringMVC02/</url>
    <content><![CDATA[<h2 id="Spring-容器启动"><a href="#Spring-容器启动" class="headerlink" title="Spring 容器启动"></a>Spring 容器启动</h2><h3 id="ContextLoader-initWebApplicationContext"><a href="#ContextLoader-initWebApplicationContext" class="headerlink" title="ContextLoader#initWebApplicationContext"></a>ContextLoader#initWebApplicationContext</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.context.ContextLoader#initWebApplicationContext</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.web.context.ContextLoaderListener#contextInitialized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent event)</span> &#123;</span><br><span class="line">    initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// web.xml中存在多次ContextLoader定义</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line"><span class="string">&quot;Cannot initialize context because there is already a root application context present - &quot;</span> +</span><br><span class="line"><span class="string">&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	servletContext.log(<span class="string">&quot;Initializing Spring root WebApplicationContext&quot;</span>);</span><br><span class="line">	<span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(ContextLoader.class);</span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">&quot;Root WebApplicationContext: initialization started&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// Store context in local instance variable, to guarantee that</span></span><br><span class="line">		<span class="comment">// it is available on ServletContext shutdown.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.context == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 初始化context，第一次执行的时候获取到一个root webApplicationcontext</span></span><br><span class="line">			<span class="built_in">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">			<span class="type">ConfigurableWebApplicationContext</span> <span class="variable">cwac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext) <span class="built_in">this</span>.context;</span><br><span class="line">			<span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">				<span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">				<span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">				<span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line">					<span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">					<span class="type">ApplicationContext</span> <span class="variable">parent</span> <span class="operator">=</span> loadParentContext(servletContext);</span><br><span class="line">					cwac.setParent(parent);</span><br><span class="line">				&#125;</span><br><span class="line">				configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将创建的context对象记录在servletContext中,创建并且准备好了spring容器</span></span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="built_in">this</span>.context);</span><br><span class="line"></span><br><span class="line">		<span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">		<span class="keyword">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">			currentContext = <span class="built_in">this</span>.context;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="literal">null</span>) &#123;</span><br><span class="line">			currentContextPerThread.put(ccl, <span class="built_in">this</span>.context);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">			<span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">			logger.info(<span class="string">&quot;Root WebApplicationContext initialized in &quot;</span> + elapsedTime + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.context;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">		logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ContextLoader-configureAndRefreshWebApplicationContext"><a href="#ContextLoader-configureAndRefreshWebApplicationContext" class="headerlink" title="ContextLoader#configureAndRefreshWebApplicationContext"></a>ContextLoader#configureAndRefreshWebApplicationContext</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.context.ContextLoader#configureAndRefreshWebApplicationContext</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac, ServletContext sc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">        <span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">        <span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idParam</span> <span class="operator">=</span> sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class="line">        <span class="keyword">if</span> (idParam != <span class="literal">null</span>) &#123;</span><br><span class="line">            wac.setId(idParam);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Generate default id...</span></span><br><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">                    ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wac.setServletContext(sc);</span><br><span class="line">    <span class="comment">// 获取配置的Spring参数配置文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocationParam</span> <span class="operator">=</span> sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class="line">    <span class="keyword">if</span> (configLocationParam != <span class="literal">null</span>) &#123;</span><br><span class="line">        wac.setConfigLocation(configLocationParam);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置环境变量</span></span><br><span class="line">    <span class="comment">// The wac environment&#x27;s #initPropertySources will be called in any case when the context</span></span><br><span class="line">    <span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line">    <span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> wac.getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">        ((ConfigurableWebEnvironment) env).initPropertySources(sc, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动容器前设置上下文信息</span></span><br><span class="line">    customizeContext(sc, wac);</span><br><span class="line">    <span class="comment">// 启动 Spring 容器</span></span><br><span class="line">    wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC-容器启动"><a href="#SpringMVC-容器启动" class="headerlink" title="SpringMVC 容器启动"></a>SpringMVC 容器启动</h2><h3 id="HttpServletBean-init"><a href="#HttpServletBean-init" class="headerlink" title="HttpServletBean#init"></a>HttpServletBean#init</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.HttpServletBean#init</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">    <span class="comment">// 将servlet中配置的init-param参数封装到pvs变量中</span></span><br><span class="line">    <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletConfigPropertyValues</span>(getServletConfig(), <span class="built_in">this</span>.requiredProperties);</span><br><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将当前的servlet对象转化成BeanWrapper对象，从而能够以spring的方法来将pvs注入到该beanWrapper中</span></span><br><span class="line">            <span class="type">BeanWrapper</span> <span class="variable">bw</span> <span class="operator">=</span> PropertyAccessorFactory.forBeanPropertyAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="type">ResourceLoader</span> <span class="variable">resourceLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextResourceLoader</span>(getServletContext());</span><br><span class="line">            <span class="comment">// 注册自定义属性编辑器，一旦有Resource类型的属性，将会使用ResourceEditor进行解析</span></span><br><span class="line">            bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> <span class="title class_">ResourceEditor</span>(resourceLoader, getEnvironment()));</span><br><span class="line">            <span class="comment">// 模板方法，可以在子类调用，做一些初始化工作，bw代表的是DispatcherServlet</span></span><br><span class="line">            initBeanWrapper(bw);</span><br><span class="line">            <span class="comment">// 以spring的方式来将pvs注入到该beanWrapper对象中,将配置的初始化值（contextConfigLocation）设置到DispatcherServlet</span></span><br><span class="line">            bw.setPropertyValues(pvs, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">    <span class="comment">// 模板方法，子类初始化的入口方法，查看FrameworkServlet#initServletBean方法</span></span><br><span class="line">    initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FrameworkServlet-initServletBean"><a href="#FrameworkServlet-initServletBean" class="headerlink" title="FrameworkServlet#initServletBean"></a>FrameworkServlet#initServletBean</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.FrameworkServlet#initServletBean</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    getServletContext().log(<span class="string">&quot;Initializing Spring &quot;</span> + getClass().getSimpleName() + <span class="string">&quot; &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Initializing Servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录开启时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建或刷新WebApplicationContext实例并对servlet功能所使用的变量进行初始化</span></span><br><span class="line">        <span class="built_in">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        <span class="comment">// 模板方法，空实现，留给子类扩展</span></span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.enableLoggingRequestDetails ?</span><br><span class="line">                <span class="string">&quot;shown which may lead to unsafe logging of potentially sensitive data&quot;</span> :</span><br><span class="line">                <span class="string">&quot;masked to prevent unsafe logging of potentially sensitive data&quot;</span>;</span><br><span class="line">        logger.debug(<span class="string">&quot;enableLoggingRequestDetails=&#x27;&quot;</span> + <span class="built_in">this</span>.enableLoggingRequestDetails +</span><br><span class="line">                <span class="string">&quot;&#x27;: request parameters and headers will be &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Completed initialization in &quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FrameworkServlet-initWebApplicationContext"><a href="#FrameworkServlet-initWebApplicationContext" class="headerlink" title="FrameworkServlet#initWebApplicationContext"></a>FrameworkServlet#initWebApplicationContext</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext</code></p>
</blockquote>
<blockquote>
<p>所有的前后端交互的框架都是以servlet为基础的，所以在使用springmvc的时候，默认会把自己的容器设置成 ServletContext 的属性，<br>默认根容器的key为 WebApplicationContext.Root,定义在WebApplicationContext中，所以在获取的时候只需要调用ServletContext.getAttribute即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获得根 WebApplicationContext 对象</span></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">            WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    <span class="comment">// 获得webApplicationContext wac对象</span></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果构造方法中已经传入webApplicationContext属性，则直接使用</span></span><br><span class="line">    <span class="comment">// 此方式主要用于servlet3.0之后的环境，也就是说可以通过ServletContext.addServlet的方法注册servlet，此时就可以在创建FrameworkServlet和</span></span><br><span class="line">    <span class="comment">// 其子类的时候通过构造方法传递已经准备好的webApplicationContext</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="built_in">this</span>.webApplicationContext;</span><br><span class="line">        <span class="comment">// 如果是ConfigurationWebApplicationContext类型，并且未激活，则进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">cwac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="comment">// 未激活</span></span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 配置和刷新上下文环境</span></span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从servletContext获取对应的webApplicationContext对象</span></span><br><span class="line">    <span class="comment">// 此方式需要在配置Servlet的时候将servletContext中的webApplicationContext的name配置到contextAttribute属性就可以</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &lt;servlet&gt;</span></span><br><span class="line"><span class="comment">    &lt;servlet-name&gt;mvc-test&lt;/servlet-name&gt;</span></span><br><span class="line"><span class="comment">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span></span><br><span class="line"><span class="comment">    &lt;!--SpringMVC配置文件--&gt;</span></span><br><span class="line"><span class="comment">    &lt;init-param&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-name&gt;contextAttribute&lt;/param-name&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-value&gt;val&lt;/param-value&gt;</span></span><br><span class="line"><span class="comment">    &lt;/init-param&gt;</span></span><br><span class="line"><span class="comment">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span></span><br><span class="line"><span class="comment">&lt;/servlet&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前面两种方式都无效的情况下会创建一个webApplicationContext对象，一般情况下都是使用这样的方式</span></span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将contextRefreshedEvent事件没有触发时调用此方法，模板方法，可以在子类重写</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将applicationContext设置到servletContext中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FrameworkServlet-createWebApplicationContext"><a href="#FrameworkServlet-createWebApplicationContext" class="headerlink" title="FrameworkServlet#createWebApplicationContext"></a>FrameworkServlet#createWebApplicationContext</h5><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.FrameworkServlet#createWebApplicationContext(org.springframework.web.context.WebApplicationContext)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> WebApplicationContext parent)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createWebApplicationContext((ApplicationContext) parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取servlet的初始化参数contextClass,如果没有配置默认为XmlWebApplicationContext.class</span></span><br><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">    <span class="comment">// 如果非ConfigurableWebApplicationContext类型，抛出ConfigurableWebApplicationContext异常</span></span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(</span><br><span class="line">    <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">    <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">    <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过反射方式实例化contextClass</span></span><br><span class="line">    <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span></span><br><span class="line">    (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置environment</span></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">// parent为在ContextLoaderListener中创建的实例，在ContextLoaderListener加载的时候初始化的WebApplicationContext类型实例</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="comment">// 获取contextConfigLocation属性，配置在servlet初始化参数中</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将设置的contextConfigLocation参数传给wac,默认传入WEB-INFO/servletName-servlet.xml</span></span><br><span class="line">    wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置和初始化wac</span></span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FrameworkServlet-configureAndRefreshWebApplicationContext"><a href="#FrameworkServlet-configureAndRefreshWebApplicationContext" class="headerlink" title="FrameworkServlet#configureAndRefreshWebApplicationContext"></a>FrameworkServlet#configureAndRefreshWebApplicationContext</h5><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.FrameworkServlet#configureAndRefreshWebApplicationContext</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果wac使用了默认编号，则重新设置id属性</span></span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">        <span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">        <span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line">        <span class="comment">// 使用contextId属性</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.contextId != <span class="literal">null</span>) &#123;</span><br><span class="line">            wac.setId(<span class="built_in">this</span>.contextId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自动生成</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Generate default id...</span></span><br><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">                    ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="string">&#x27;/&#x27;</span> + getServletName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置wac的servletContext、servletConfig、namespace属性</span></span><br><span class="line">    wac.setServletContext(getServletContext());</span><br><span class="line">    wac.setServletConfig(getServletConfig());</span><br><span class="line">    wac.setNamespace(getNamespace());</span><br><span class="line">    <span class="comment">// 添加监听器sourceFilteringListener到wac中,实际监听的是ContextRefreshListener所监听的事件，监听ContextRefreshedEvent事件，</span></span><br><span class="line">    <span class="comment">// 当接收到消息之后会调用onApplicationEvent方法，调用onRefresh方法，并将refreshEventReceived标志设置为true，表示已经refresh过</span></span><br><span class="line">    wac.addApplicationListener(<span class="keyword">new</span> <span class="title class_">SourceFilteringListener</span>(wac, <span class="keyword">new</span> <span class="title class_">ContextRefreshListener</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The wac environment&#x27;s #initPropertySources will be called in any case when the context</span></span><br><span class="line">    <span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line">    <span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">    <span class="comment">// 获取环境对象并且添加相关的属性</span></span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> wac.getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">        ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行处理完WebApplicationContext后的逻辑，此处为空方法，不做任何实现</span></span><br><span class="line">    postProcessWebApplicationContext(wac);</span><br><span class="line">    <span class="comment">// 执行自定义初始化context</span></span><br><span class="line">    applyInitializers(wac);</span><br><span class="line">    <span class="comment">// 刷新wac,从而初始化wac</span></span><br><span class="line">    wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FrameworkServlet-onRefresh"><a href="#FrameworkServlet-onRefresh" class="headerlink" title="FrameworkServlet#onRefresh"></a>FrameworkServlet#onRefresh</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#onRefresh</code>  </p>
</blockquote>
<blockquote>
<p>SpringMVC 容器启动后, 发送事件 ContextRefreshedEvent 后, 进行初始化<br>初始化 SpringMVC 内置的九大组件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 MultipartResolver:主要用来处理文件上传.如果定义过当前类型的bean对象，那么直接获取，如果没有的话，可以为null</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    <span class="comment">// 初始化 LocaleResolver:主要用来处理国际化配置,基于URL参数的配置(AcceptHeaderLocaleResolver)，基于session的配置(SessionLocaleResolver)，基于cookie的配置(CookieLocaleResolver)</span></span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    <span class="comment">// 初始化 ThemeResolver:主要用来设置主题Theme</span></span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    <span class="comment">// 初始化 HandlerMapping:映射器，用来将对应的request跟controller进行对应</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    <span class="comment">// 初始化 HandlerAdapter:处理适配器，主要包含Http请求处理器适配器，简单控制器处理器适配器，注解方法处理器适配器</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    <span class="comment">// 初始化 HandlerExceptionResolver:基于HandlerExceptionResolver接口的异常处理</span></span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    <span class="comment">// 初始化 RequestToViewNameTranslator:当controller处理器方法没有返回一个View对象或逻辑视图名称，并且在该方法中没有直接往response的输出流里面写数据的时候，spring将会采用约定好的方式提供一个逻辑视图名称</span></span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="comment">// 初始化 ViewResolver: 将ModelAndView选择合适的视图进行渲染的处理器</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    <span class="comment">// 初始化 FlashMapManager: 提供请求存储属性，可供其他请求使用</span></span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html">DispatcherServlet</a></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 源码之加九大组件初始化</title>
    <url>/2020/10/26/SpringMVC/SpringMVC03/</url>
    <content><![CDATA[<h3 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#initMultipartResolver</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initMultipartResolver</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// MULTIPART_RESOLVER_BEAN_NAME = &quot;multipartResolver&quot;</span></span><br><span class="line">        <span class="comment">// 从spring上下文获取名称为 multipartResolver ，类型为MultipartResolver的Bean</span></span><br><span class="line">        <span class="built_in">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.multipartResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.multipartResolver.getClass().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">        <span class="comment">// Default is no multipart resolver.</span></span><br><span class="line">        <span class="built_in">this</span>.multipartResolver = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No MultipartResolver &#x27;&quot;</span> + MULTIPART_RESOLVER_BEAN_NAME + <span class="string">&quot;&#x27; declared&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LocaleResolver"><a href="#LocaleResolver" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#initLocaleResolver</code> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title function_">initLocaleResolver</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// LOCALE_RESOLVER_BEAN_NAME = &quot;localeResolver&quot;</span></span><br><span class="line">        <span class="comment">// 从上下文中获取Bean名称为 LocaleResolver的对象</span></span><br><span class="line">        <span class="built_in">this</span>.localeResolver = context.getBean(LOCALE_RESOLVER_BEAN_NAME, LocaleResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.localeResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.localeResolver.getClass().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">        <span class="comment">// We need to use the default.</span></span><br><span class="line">        <span class="comment">// 从配置文件中获取默认的AcceptHeaderLocaleResolver对象</span></span><br><span class="line">        <span class="built_in">this</span>.localeResolver = getDefaultStrategy(context, LocaleResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No LocaleResolver &#x27;&quot;</span> + LOCALE_RESOLVER_BEAN_NAME +</span><br><span class="line">                    <span class="string">&quot;&#x27;: using default [&quot;</span> + <span class="built_in">this</span>.localeResolver.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#initThemeResolver</code> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initThemeResolver</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// THEME_RESOLVER_BEAN_NAME = &quot;themeResolver&quot;</span></span><br><span class="line">        <span class="built_in">this</span>.themeResolver = context.getBean(THEME_RESOLVER_BEAN_NAME, ThemeResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.themeResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.themeResolver.getClass().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">        <span class="comment">// We need to use the default.</span></span><br><span class="line">        <span class="comment">// 从配置文件中获取默认的FixedThemeResolver</span></span><br><span class="line">        <span class="built_in">this</span>.themeResolver = getDefaultStrategy(context, ThemeResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No ThemeResolver &#x27;&quot;</span> + THEME_RESOLVER_BEAN_NAME +</span><br><span class="line">                    <span class="string">&quot;&#x27;: using default [&quot;</span> + <span class="built_in">this</span>.themeResolver.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#initHandlerMappings</code> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// 将handlerMappings置空</span></span><br><span class="line">    <span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果开启探测功能，则扫描已注册的HandlerMapping的bean，添加到handlerMappings中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">        <span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">        <span class="comment">// 扫描已注册的handlerMapping的bean</span></span><br><span class="line">        Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 添加到handlerMappings中，并进行排序</span></span><br><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handlerMappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchingBeans.values());</span><br><span class="line">            <span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">            AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerMappings);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果关闭探测功能，则获取Bean名称为handlerMapping对应的bean，将其添加到handlerMappings</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// HANDLER_MAPPING_BEAN_NAME = &quot;handlerMapping&quot;</span></span><br><span class="line">            <span class="type">HandlerMapping</span> <span class="variable">hm</span> <span class="operator">=</span> context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">            <span class="built_in">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="comment">// Ignore, we&#x27;ll add a default HandlerMapping later.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></span><br><span class="line">    <span class="comment">// a default HandlerMapping if no other mappings are found.</span></span><br><span class="line">    <span class="comment">// 如果未获得到，则获得默认配置的handlerMapping类</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No HandlerMappings declared for servlet &#x27;&quot;</span> + getServletName() +</span><br><span class="line">                    <span class="string">&quot;&#x27;: using default strategies from DispatcherServlet_test.properties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#initHandlerAdapters</code> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerAdapters</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handlerAdapters = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerAdapters) &#123;</span><br><span class="line">        <span class="comment">// Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">        Map&lt;String, HandlerAdapter&gt; matchingBeans =</span><br><span class="line">                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handlerAdapters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchingBeans.values());</span><br><span class="line">            <span class="comment">// We keep HandlerAdapters in sorted order.</span></span><br><span class="line">            AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerAdapters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// HANDLER_ADAPTER_BEAN_NAME = &quot;handlerAdapter&quot;</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);</span><br><span class="line">            <span class="built_in">this</span>.handlerAdapters = Collections.singletonList(ha);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="comment">// Ignore, we&#x27;ll add a default HandlerAdapter later.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure we have at least some HandlerAdapters, by registering</span></span><br><span class="line">    <span class="comment">// default HandlerAdapters if no other adapters are found.</span></span><br><span class="line">    <span class="comment">// 如果未获得到，则获得默认配置的HandlerAdapter类，HttpRequestHandlerAdapter,SimpleControllerHandlerAdapter,RequestMappingHandlerAdapter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No HandlerAdapters declared for servlet &#x27;&quot;</span> + getServletName() +</span><br><span class="line">                    <span class="string">&quot;&#x27;: using default strategies from DispatcherServlet_test.properties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#initHandlerExceptionResolvers</code> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerExceptionResolvers</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// 置空 handlerExceptionResolver 处理</span></span><br><span class="line">    <span class="built_in">this</span>.handlerExceptionResolvers = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动扫描handlerExceptionResolver类型的bean</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerExceptionResolvers) &#123;</span><br><span class="line">        <span class="comment">// Find all HandlerExceptionResolvers in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">        Map&lt;String, HandlerExceptionResolver&gt; matchingBeans = BeanFactoryUtils</span><br><span class="line">                .beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handlerExceptionResolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchingBeans.values());</span><br><span class="line">            <span class="comment">// We keep HandlerExceptionResolvers in sorted order.</span></span><br><span class="line">            AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerExceptionResolvers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取名字为HANDLER_EXCEPTION_RESOLVER_BEAN_NAME的bean</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// HANDLER_EXCEPTION_RESOLVER_BEAN_NAME = &quot;handlerExceptionResolver&quot;</span></span><br><span class="line">            <span class="type">HandlerExceptionResolver</span> <span class="variable">her</span> <span class="operator">=</span></span><br><span class="line">                    context.getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);</span><br><span class="line">            <span class="built_in">this</span>.handlerExceptionResolvers = Collections.singletonList(her);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="comment">// Ignore, no HandlerExceptionResolver is fine too.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure we have at least some HandlerExceptionResolvers, by registering</span></span><br><span class="line">    <span class="comment">// default HandlerExceptionResolvers if no other resolvers are found.</span></span><br><span class="line">    <span class="comment">// 如果未获得到，则获取默认配置的handlerExceptionResolver类，ExceptionHandlerExceptionResolver,ResponseStatusExceptionResolver,DefaultHandlerExceptionResolver</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerExceptionResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handlerExceptionResolvers = getDefaultStrategies(context, HandlerExceptionResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No HandlerExceptionResolvers declared in servlet &#x27;&quot;</span> + getServletName() +</span><br><span class="line">                    <span class="string">&quot;&#x27;: using default strategies from DispatcherServlet_test.properties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#initRequestToViewNameTranslator</code> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initRequestToViewNameTranslator</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME = &quot;viewNameTranslator&quot;</span></span><br><span class="line">        <span class="built_in">this</span>.viewNameTranslator =</span><br><span class="line">                context.getBean(REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME, RequestToViewNameTranslator.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.viewNameTranslator.getClass().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.viewNameTranslator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">        <span class="comment">// We need to use the default.</span></span><br><span class="line">        <span class="comment">// 如果未找到，则获取默认的 RequestToViewNameTranslator 对象，DefaultRequestToViewNameTranslator</span></span><br><span class="line">        <span class="built_in">this</span>.viewNameTranslator = getDefaultStrategy(context, RequestToViewNameTranslator.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No RequestToViewNameTranslator &#x27;&quot;</span> + REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME +</span><br><span class="line">                    <span class="string">&quot;&#x27;: using default [&quot;</span> + <span class="built_in">this</span>.viewNameTranslator.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#initViewResolvers</code> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initViewResolvers</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// 置空 viewResolvers 处理</span></span><br><span class="line">    <span class="built_in">this</span>.viewResolvers = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 自动扫描 ViewResolver 类型的 Bean</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllViewResolvers) &#123;</span><br><span class="line">        <span class="comment">// Find all ViewResolvers in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">        Map&lt;String, ViewResolver&gt; matchingBeans =</span><br><span class="line">                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.viewResolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchingBeans.values());</span><br><span class="line">            <span class="comment">// We keep ViewResolvers in sorted order.</span></span><br><span class="line">            AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.viewResolvers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得名字为VIEW_RESOLVER_BEAN_NAME的bean</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// VIEW_RESOLVER_BEAN_NAME = &quot;viewResolver&quot;</span></span><br><span class="line">            <span class="type">ViewResolver</span> <span class="variable">vr</span> <span class="operator">=</span> context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);</span><br><span class="line">            <span class="built_in">this</span>.viewResolvers = Collections.singletonList(vr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="comment">// Ignore, we&#x27;ll add a default ViewResolver later.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure we have at least one ViewResolver, by registering</span></span><br><span class="line">    <span class="comment">// a default ViewResolver if no other resolvers are found.</span></span><br><span class="line">    <span class="comment">// 如果未获得到，则获取默认配置的ViewResolver对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.viewResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.viewResolvers = getDefaultStrategies(context, ViewResolver.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No ViewResolvers declared for servlet &#x27;&quot;</span> + getServletName() +</span><br><span class="line">                    <span class="string">&quot;&#x27;: using default strategies from DispatcherServlet_test.properties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#initFlashMapManager</code> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFlashMapManager</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flashMapManager = context.getBean(FLASH_MAP_MANAGER_BEAN_NAME, FlashMapManager.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.flashMapManager.getClass().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Detected &quot;</span> + <span class="built_in">this</span>.flashMapManager);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">        <span class="comment">// We need to use the default.</span></span><br><span class="line">        <span class="comment">// 未找到，则获取默认的 FlashMapManager 对象，SessionFlashMapManager</span></span><br><span class="line">        <span class="built_in">this</span>.flashMapManager = getDefaultStrategy(context, FlashMapManager.class);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No FlashMapManager &#x27;&quot;</span> + FLASH_MAP_MANAGER_BEAN_NAME +</span><br><span class="line">                    <span class="string">&quot;&#x27;: using default [&quot;</span> + <span class="built_in">this</span>.flashMapManager.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="getDefaultStrategy-给定策略接口的默认策略对象"><a href="#getDefaultStrategy-给定策略接口的默认策略对象" class="headerlink" title="getDefaultStrategy 给定策略接口的默认策略对象"></a>getDefaultStrategy 给定策略接口的默认策略对象</h5><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#getDefaultStrategy</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">getDefaultStrategy</span><span class="params">(ApplicationContext context, Class&lt;T&gt; strategyInterface)</span> &#123;</span><br><span class="line">    List&lt;T&gt; strategies = getDefaultStrategies(context, strategyInterface);</span><br><span class="line">    <span class="keyword">if</span> (strategies.size() != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInitializationException</span>(</span><br><span class="line">    <span class="string">&quot;DispatcherServlet needs exactly 1 strategy for interface [&quot;</span> + strategyInterface.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strategies.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为给定的策略接口创建一个默认策略对象列表。</span></span><br><span class="line"><span class="comment"> * 默认实现使用“DispatcherServlet _test.properties”文件（在包作为DispatcherServlet类）来确定类名。它实例化策略对象通过上下文的BeanFactory。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getDefaultStrategies</span><span class="params">(ApplicationContext context, Class&lt;T&gt; strategyInterface)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得strategyInterface对应的value值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> strategyInterface.getName();</span><br><span class="line">    <span class="comment">// 创建value对应的对象们，并返回</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> defaultStrategies.getProperty(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 基于&quot;,&quot;分隔，创建classNames数组</span></span><br><span class="line">        String[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span><br><span class="line">        <span class="comment">// 创建strategyInterface集合</span></span><br><span class="line">        List&lt;T&gt; strategies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(classNames.length);</span><br><span class="line">        <span class="comment">// 遍历classNames数组，创建对应的类，添加到strategyInterface中</span></span><br><span class="line">        <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得className类</span></span><br><span class="line">                Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</span><br><span class="line">                <span class="comment">// 创建className对应的类，并添加到strategies中</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">strategy</span> <span class="operator">=</span> createDefaultStrategy(context, clazz);</span><br><span class="line">                strategies.add((T) strategy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInitializationException</span>(</span><br><span class="line">                        <span class="string">&quot;Could not find DispatcherServlet&#x27;s default strategy class [&quot;</span> + className +</span><br><span class="line">                        <span class="string">&quot;] for interface [&quot;</span> + key + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInitializationException</span>(</span><br><span class="line">                        <span class="string">&quot;Unresolvable class definition for DispatcherServlet&#x27;s default strategy class [&quot;</span> +</span><br><span class="line">                        className + <span class="string">&quot;] for interface [&quot;</span> + key + <span class="string">&quot;]&quot;</span>, err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategies;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 源码之网络请求(1)</title>
    <url>/2020/10/26/SpringMVC/SpringMVC04/</url>
    <content><![CDATA[<h2 id="FrameworkServlet-service"><a href="#FrameworkServlet-service" class="headerlink" title="FrameworkServlet#service"></a>FrameworkServlet#service</h2><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.FrameworkServlet#service</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// 获得请求方法</span></span><br><span class="line">    <span class="type">HttpMethod</span> <span class="variable">httpMethod</span> <span class="operator">=</span> HttpMethod.resolve(request.getMethod());</span><br><span class="line">    <span class="comment">// 处理patch请求</span></span><br><span class="line">    <span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理其他类型的请求</span></span><br><span class="line">        <span class="built_in">super</span>.service(request, response);</span><br><span class="line">        <span class="comment">// 此父类方法调用了 javax.servlet.http.HttpServlet#doGet/doPost 等方法</span></span><br><span class="line">        <span class="comment">// 同时子类 FrameworkServlet 重写了 doGet/doPost, 继续调用了 FrameworkServlet#processRequest</span></span><br><span class="line">        <span class="comment">// 即此方法最终都会调用 FrameworkServlet#processRequest</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FrameworkServlet-processRequest"><a href="#FrameworkServlet-processRequest" class="headerlink" title="FrameworkServlet#processRequest"></a>FrameworkServlet#processRequest</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.FrameworkServlet#processRequest</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录当前时间，用于计算处理请求花费的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 记录异常，用于保存处理请求过程中发送的异常</span></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">failureCause</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取LocaleContextHolder中原来保存的LocaleContext(保存的本地化信息)</span></span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">previousLocaleContext</span> <span class="operator">=</span> LocaleContextHolder.getLocaleContext();</span><br><span class="line">    <span class="comment">// 获取当前请求的LocaleContext</span></span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">localeContext</span> <span class="operator">=</span> buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取RequestContextHolder总原来保存的RequestAttribute(管理request和session的属性)</span></span><br><span class="line">    <span class="type">RequestAttributes</span> <span class="variable">previousAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">    <span class="comment">// 获取当前请求的ServletRequestAttribute</span></span><br><span class="line">    <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步管理器</span></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> <span class="title class_">RequestBindingInterceptor</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前请求的LocaleContext和ServletRequestAttribute设置到LocaleContextHolder和RequestContextHolder</span></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行真正的逻辑</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">        <span class="comment">// 记录抛出的异常</span></span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 记录抛出的异常</span></span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复原来的LocaleContext和ServletRequestAttributes到LocaleContextHolder和RequestContextHolder中</span></span><br><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果日志级别为debug，则打印请求日志</span></span><br><span class="line">        logResult(request, response, failureCause, asyncManager);</span><br><span class="line">        <span class="comment">// 发布ServletRequestHandledEvent请求处理完成事件</span></span><br><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DispatcherServlet-doService"><a href="#DispatcherServlet-doService" class="headerlink" title="DispatcherServlet#doService"></a>DispatcherServlet#doService</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#doService</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 如果日志级别为 DEBUG，则打印请求日志</span></span><br><span class="line">    logRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">    <span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">    <span class="comment">// 当include请求时对request的Attribute做快照备份</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">    <span class="comment">// 设置Spring框架中的常用对象到request属性中，这四个属性会在handler和view中使用</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FlashMap的相关配置，主要用于Redirect转发时参数的传递，此处有一个应用场景:如果post请求是提交表单，提交完之后redirect到一个显示订单的页面，</span></span><br><span class="line">    <span class="comment">// 此时需要知道一些订单的信息，但redirect本身没有提交参数的功能，如果想传递参数，那么就必须要写到url，而url有长度的限制同时还容易对外暴露，此时</span></span><br><span class="line">    <span class="comment">// 可以使用flashMap来传递参数，</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.flashMapManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">FlashMap</span> <span class="variable">inputFlashMap</span> <span class="operator">=</span> <span class="built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> <span class="title class_">FlashMap</span>());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="built_in">this</span>.flashMapManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行请求的分发</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 异步处理相关</span></span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">            <span class="comment">// 还原request快照的属性</span></span><br><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DispatcherServlet-doDispatch"><a href="#DispatcherServlet-doDispatch" class="headerlink" title="DispatcherServlet#doDispatch"></a>DispatcherServlet#doDispatch</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#doDispatch</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 实际处理时所用的request，如果不是上传请求，则直接使用接收到的request，否则封装成上传类型的request</span></span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="comment">// 处理请求的处理器链(包含处理器和对应的interceptor)</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 是不是上传请求的标志</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步管理器</span></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 封装model和view的容器</span></span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 处理请求过程中抛出的异常，但是不包含渲染过程中抛出的异常</span></span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检测请求是否为上传请求，如果是则通过multipartResolver将其封装成MultipartHttpServletRequest对象</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            <span class="comment">// 设置上传请求的标志</span></span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">// 获得请求对应的HandlerExecutionChain对象（HandlerMethod和HandlerInterceptor拦截器们）</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="comment">//  如果获取不到，则根据配置抛出异常或返回404错误</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            <span class="comment">// 获得当前handler对应的HandlerAdapter对象</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="comment">// 处理GET、HEAD请求的Last-Modified,当浏览器第一次跟服务器请求资源时，服务器会在返回的请求头里包含一个last_modified的属性，</span></span><br><span class="line">            <span class="comment">// 代表资源最后时什么时候修改的，在浏览器以后发送请求的时候，会同时发送之前接收到的Last_modified.服务器接收到带last_modified的请求后，</span></span><br><span class="line">            <span class="comment">// 会跟实际资源的最后修改时间做对比，如果过期了返回新的资源，否则直接返回304表示未过期，直接使用之前缓存的结果即可</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="comment">// 获取请求中服务器端最后被修改时间</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行响应的Interceptor的preHandler</span></span><br><span class="line">            <span class="comment">// 注意：该方法如果有一个拦截器的前置处理返回false，则开始倒序触发所有的拦截器的 已完成处理</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 真正的调用handler方法，也就是执行对应的方法，并返回视图</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果需要异步处理，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当view为空时，根据request设置默认的view</span></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 执行响应的interceptor的postHandler方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// 记录异常</span></span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理返回结果，包括处理异常、渲染页面、触发Interceptor的afterCompletion</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// 已完成处理 拦截器</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        <span class="comment">// 完成处理激活触发器</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否执行异步请求</span></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="comment">// 删除上传请求的资源</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 源码之网络请求(2)</title>
    <url>/2020/10/26/SpringMVC/SpringMVC05/</url>
    <content><![CDATA[<h3 id="DispatcherServlet-checkMultipart"><a href="#DispatcherServlet-checkMultipart" class="headerlink" title="DispatcherServlet#checkMultipart"></a>DispatcherServlet#checkMultipart</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#checkMultipart</code></p>
</blockquote>
<blockquote>
<p>检测请求是否为上传请求，如果是则通过 multipartResolver 将其封装成 MultipartHttpServletRequest 对象 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HttpServletRequest <span class="title function_">checkMultipart</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException &#123;</span><br><span class="line">    <span class="comment">// 如果该请求是一个涉及到 multipart （文件）的请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.multipartResolver != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.multipartResolver.isMultipart(request)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.getDispatcherType().equals(DispatcherType.REQUEST)) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Request already resolved to MultipartHttpServletRequest, e.g. by MultipartFilter&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hasMultipartException(request)) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Multipart resolution previously failed for current request - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;skipping re-resolution for undisturbed error rendering&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将 HttpServletRequest 请求封装成 MultipartHttpServletRequest 对象，解析请求里面的参数以及文件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.multipartResolver.resolveMultipart(request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (MultipartException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Multipart resolution failed for error dispatch&quot;</span>, ex);</span><br><span class="line">                    <span class="comment">// Keep processing error dispatch with regular request handle below</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If not returned before: return original request.</span></span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DispatcherServlet-getHandler"><a href="#DispatcherServlet-getHandler" class="headerlink" title="DispatcherServlet#getHandler"></a>DispatcherServlet#getHandler</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#getHandler</code><br><strong>定位</strong>: <code>org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获得处理器（HandlerMethod或者HandlerExecutionChain），该方法是抽象方法，由子类实现</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getHandlerInternal(request);</span><br><span class="line">    <span class="comment">// 获得不到，则使用默认处理器</span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还是获得不到，则返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">    <span class="comment">// 如果找到的处理器是String类型，则从Spring容器中找到对应的Bean作为处理器</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">        handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建HandlerExecutionChain对象（包含处理器和拦截器）</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">executionChain</span> <span class="operator">=</span> getHandlerExecutionChain(handler, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Mapped to &quot;</span> + handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled() &amp;&amp; !request.getDispatcherType().equals(DispatcherType.ASYNC)) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Mapped to &quot;</span> + executionChain.getHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对跨域请求的处理</span></span><br><span class="line">    <span class="keyword">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> (<span class="built_in">this</span>.corsConfigurationSource != <span class="literal">null</span> ? <span class="built_in">this</span>.corsConfigurationSource.getCorsConfiguration(request) : <span class="literal">null</span>);</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">handlerConfig</span> <span class="operator">=</span> getCorsConfiguration(handler, request);</span><br><span class="line">        config = (config != <span class="literal">null</span> ? config.combine(handlerConfig) : handlerConfig);</span><br><span class="line">        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#getHandlerInternal</code></p>
</blockquote>
<blockquote>
<p>RequestMappingHandlerMapping 实现了 AbstractHandlerMethodMapping<br>RequestMappingHandlerMapping 处理添加 @RequestMapping 的 API</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取访问的路径，一般类似于request.getServletPath()，返回不含contextPath的访问路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    request.setAttribute(LOOKUP_PATH, lookupPath);</span><br><span class="line">    <span class="comment">// 获得读锁</span></span><br><span class="line">    <span class="built_in">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取HandlerMethod作为handler对象，这里涉及到路径匹配的优先级</span></span><br><span class="line">        <span class="comment">// 优先级: 精确匹配&gt;最长路径匹配&gt;扩展名匹配</span></span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> lookupHandlerMethod(lookupPath, request);</span><br><span class="line">        <span class="comment">// handlerMethod内部包含有bean对象，其实指的是对应的controller</span></span><br><span class="line">        <span class="keyword">return</span> (handlerMethod != <span class="literal">null</span> ? handlerMethod.createWithResolvedBean() : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//  释放读锁</span></span><br><span class="line">        <span class="built_in">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#lookupHandlerMethod</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//  Match数组，存储匹配上当前请求的结果（Mapping + HandlerMethod）</span></span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 首先根据lookupPath获取到匹配条件</span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="built_in">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将找到的匹配条件添加到matches</span></span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不能直接使用lookupPath得到匹配条件，则将所有匹配条件加入matches</span></span><br><span class="line">    <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// No choice but to go through all mappings...</span></span><br><span class="line">        addMatchingMappings(<span class="built_in">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将包含匹配条件和handler的matches排序，并取第一个作为bestMatch，如果前面两个排序相同则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Match</span> <span class="variable">bestMatch</span> <span class="operator">=</span> matches.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建MatchComparator对象，排序matches结果，排序器</span></span><br><span class="line">            Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> <span class="title class_">MatchComparator</span>(getMappingComparator(request));</span><br><span class="line">            matches.sort(comparator);</span><br><span class="line">            <span class="comment">// 获得首个Match对象，也就是最匹配的</span></span><br><span class="line">            bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(matches.size() + <span class="string">&quot; matching mappings: &quot;</span> + matches);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">                <span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比较bestMatch和secondBestMatch，如果相等，说明有问题，抛出IllegalStateException异常</span></span><br><span class="line">            <span class="comment">// 因为，两个优先级一样高，说明无法判断谁更优先</span></span><br><span class="line">            <span class="type">Match</span> <span class="variable">secondBestMatch</span> <span class="operator">=</span> matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> bestMatch.handlerMethod.getMethod();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">                <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;Ambiguous handler methods mapped for &#x27;&quot;</span> + uri + <span class="string">&quot;&#x27;: &#123;&quot;</span> + m1 + <span class="string">&quot;, &quot;</span> + m2 + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);</span><br><span class="line">        <span class="comment">// 处理首个Match对象</span></span><br><span class="line">        handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">        <span class="comment">// 返回首个Match对象的handlerMethod属性</span></span><br><span class="line">        <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果匹配不到，则处理不匹配的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handleNoMatch(<span class="built_in">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#getHandlerInternal</code></p>
</blockquote>
<blockquote>
<p>BeanNameUrlHandlerMapping 和 SimpleUrlHandlerMapping 实现了 AbstractUrlHandlerMapping<br>BeanNameUrlHandlerMapping 处理容器 bean 对象的名称为当前 url<br>eg: <code>&lt;bean name=&quot;/hello01&quot; class=&quot;controller.HelloController01&quot;/&gt;</code><br>SimpleUrlHandlerMapping 处理通过配置设置到处理对象<br>eg:   </p>
<blockquote>
<p><code>&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;</code><br><code>  &lt;property name=&quot;mappings&quot;&gt;</code><br><code>    &lt;props&gt;</code><br><code>      &lt;prop key=&quot;/hello02&quot;&gt;helloController02&lt;/prop&gt;</code><br><code>      &lt;prop key=&quot;/hello03&quot;&gt;helloController03&lt;/prop&gt;</code><br><code>    &lt;/props&gt;</code><br><code>  &lt;/property&gt;</code><br><code>&lt;/bean&gt;</code>  </p>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 截取用于匹配的URL有效路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    request.setAttribute(LOOKUP_PATH, lookupPath);</span><br><span class="line">    <span class="comment">// 根据路径寻找handler，此处并不是直接从map中获取，很多handler都有通配符的写法，甚至有多个匹配项，此时需要做好选择</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> lookupHandler(lookupPath, request);</span><br><span class="line">    <span class="comment">// 如果找不到处理器，则使用rootHandler或defaultHandler处理器</span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to care for the default handler directly, since we need to</span></span><br><span class="line">        <span class="comment">// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">rawHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 如果是根路径，则使用rootHandler处理器</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.matchesCharacter(lookupPath, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果请求的路径仅仅是“/”,那么使用RootHandler进行处理</span></span><br><span class="line">            rawHandler = getRootHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果无法找到handler，则使用默认的handler</span></span><br><span class="line">        <span class="keyword">if</span> (rawHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            rawHandler = getDefaultHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rawHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">            <span class="comment">// 如果找到的处理器是String类型，则从容器中找到该beanName对应的Bean作为处理器</span></span><br><span class="line">            <span class="keyword">if</span> (rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) rawHandler;</span><br><span class="line">                rawHandler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 空方法，校验处理器。目前暂无子类实现该方法</span></span><br><span class="line">            validateHandler(rawHandler, request);</span><br><span class="line">            <span class="comment">// 创建处理器（HandlerExecutionChain对象）</span></span><br><span class="line">            handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#lookupHandler</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">lookupHandler</span><span class="params">(String urlPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// Direct match?</span></span><br><span class="line">    <span class="comment">// 直接根据url进行查找handler</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">        <span class="comment">// 如果找到的处理器是String类型，则从容器中找到该beanName对应的Bean作为处理器</span></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">            handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 空方法，校验处理器。目前暂无子类实现该方法</span></span><br><span class="line">        validateHandler(handler, request);</span><br><span class="line">        <span class="comment">// 创建处理器</span></span><br><span class="line">        <span class="keyword">return</span> buildPathExposingHandler(handler, urlPath, urlPath, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pattern match?</span></span><br><span class="line">    <span class="comment">// 通过表达式进行匹配具体通过antPathMatcher实现</span></span><br><span class="line">    List&lt;String&gt; matchingPatterns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 情况二，Pattern匹配合适的，并添加到 matchingPatterns 中</span></span><br><span class="line">    <span class="keyword">for</span> (String registeredPattern : <span class="built_in">this</span>.handlerMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getPathMatcher().match(registeredPattern, urlPath)) &#123;</span><br><span class="line">            <span class="comment">// 路径通过Pattern匹配成功</span></span><br><span class="line">            matchingPatterns.add(registeredPattern);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (useTrailingSlashMatch()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!registeredPattern.endsWith(<span class="string">&quot;/&quot;</span>) &amp;&amp; getPathMatcher().match(registeredPattern + <span class="string">&quot;/&quot;</span>, urlPath)) &#123;</span><br><span class="line">                matchingPatterns.add(registeredPattern + <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得首个匹配（最优）的结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">bestMatch</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);</span><br><span class="line">    <span class="keyword">if</span> (!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">        matchingPatterns.sort(patternComparator);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled() &amp;&amp; matchingPatterns.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Matching patterns &quot;</span> + matchingPatterns);</span><br><span class="line">        &#125;</span><br><span class="line">        bestMatch = matchingPatterns.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bestMatch != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获得bestMatch对应的处理器</span></span><br><span class="line">        handler = <span class="built_in">this</span>.handlerMap.get(bestMatch);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bestMatch.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                handler = <span class="built_in">this</span>.handlerMap.get(bestMatch.substring(<span class="number">0</span>, bestMatch.length() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果获得不到，抛出IllegalStateException异常</span></span><br><span class="line">            <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;Could not find handler for best pattern match [&quot;</span> + bestMatch + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">        <span class="comment">// 如果找到的处理器是String类型，则从容器中找到该beanName对应的Bean作为处理器</span></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">            handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 空方法，校验处理器。目前暂无子类实现该方法</span></span><br><span class="line">        validateHandler(handler, request);</span><br><span class="line">        <span class="comment">// 获得最匹配的路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pathWithinMapping</span> <span class="operator">=</span> getPathMatcher().extractPathWithinPattern(bestMatch, urlPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// There might be multiple &#x27;best patterns&#x27;, let&#x27;s make sure we have the correct URI template variables</span></span><br><span class="line">        <span class="comment">// for all of them</span></span><br><span class="line">        <span class="comment">// 之前通过sort方法进行排序，然后拿第一个作为bestPatternMatch的，不过有可能有多个pattern的顺序相同，也就是sort方法返回0，这里就是处理这种情况</span></span><br><span class="line">        Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line">            <span class="keyword">if</span> (patternComparator.compare(bestMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">                Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);</span><br><span class="line">                Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">                uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled() &amp;&amp; uriTemplateVariables.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;URI variables &quot;</span> + uriTemplateVariables);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建处理器</span></span><br><span class="line">        <span class="keyword">return</span> buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No handler found...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandlerExecutionChain</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 HandlerExecutionChain 对象</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">chain</span> <span class="operator">=</span> (handler <span class="keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">            (HandlerExecutionChain) handler : <span class="keyword">new</span> <span class="title class_">HandlerExecutionChain</span>(handler));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得请求路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> <span class="built_in">this</span>.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH);</span><br><span class="line">    <span class="comment">// 遍历 adaptedInterceptors 数组，获得请求匹配的拦截器</span></span><br><span class="line">    <span class="keyword">for</span> (HandlerInterceptor interceptor : <span class="built_in">this</span>.adaptedInterceptors) &#123;</span><br><span class="line">        <span class="comment">// 需要匹配，若路径匹配，则添加到 chain 中</span></span><br><span class="line">        <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">            <span class="type">MappedInterceptor</span> <span class="variable">mappedInterceptor</span> <span class="operator">=</span> (MappedInterceptor) interceptor;</span><br><span class="line">            <span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="built_in">this</span>.pathMatcher)) &#123;</span><br><span class="line">                chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无需匹配，直接添加到 chain 中</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            chain.addInterceptor(interceptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DispatcherServlet-getHandlerAdapter"><a href="#DispatcherServlet-getHandlerAdapter" class="headerlink" title="DispatcherServlet#getHandlerAdapter"></a>DispatcherServlet#getHandlerAdapter</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;No adapter for handler [&quot;</span> + handler +</span><br><span class="line">            <span class="string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="HandlerExecutionChain-applyPreHandle"><a href="#HandlerExecutionChain-applyPreHandle" class="headerlink" title="HandlerExecutionChain#applyPreHandle"></a>HandlerExecutionChain#applyPreHandle</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.HandlerExecutionChain#applyPreHandle</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取拦截器数组，然后循环调用执行preHandle, interceptorIndex 这个变量设计的比较巧妙，</span></span><br><span class="line"><span class="comment"> *  假设现在有3个拦截器，第3个拦截器的 preHandler 返回 false，那么 interceptorIndex 此时为1，会执行 triggerAfterCompletion 方法</span></span><br><span class="line"><span class="comment"> *  第1个开始往前 大于等于0的拦截器对应上面的例子就是第2和3的拦截器的afterCompletion方法会执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取拦截器数组</span></span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="comment">// 遍历拦截器数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">            <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">            <span class="comment">// 前置处理</span></span><br><span class="line">            <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">                <span class="comment">// 已完成处理拦截器</span></span><br><span class="line">                triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">// 返回false，前置处理失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记interceptorIndex位置</span></span><br><span class="line">            <span class="built_in">this</span>.interceptorIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> Exception ex)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获得拦截器数组</span></span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="comment">// 遍历拦截器数组，倒序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 已完成处理拦截器</span></span><br><span class="line">                interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">                <span class="comment">// 如果执行失败，仅仅会打印错误日志，不会结束循环</span></span><br><span class="line">                logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 源码之网络请求(3)</title>
    <url>/2020/10/26/SpringMVC/SpringMVC06/</url>
    <content><![CDATA[<h2 id="常见三种-HandlerAdapter"><a href="#常见三种-HandlerAdapter" class="headerlink" title="常见三种 HandlerAdapter"></a>常见三种 HandlerAdapter</h2><ul>
<li><code>SimpleControllerHandlerAdapter</code>  处理实现 Controller 接口的方法</li>
<li><code>HttpRequestHandlerAdapter</code>  处理实现 HttpRequestHandler 接口的方法</li>
<li><code>RequestMappingHandlerAdapter</code> 处理使用 @RequestMapping 注解的方法</li>
</ul>
<h3 id="SimpleControllerHandlerAdapter-handle"><a href="#SimpleControllerHandlerAdapter-handle" class="headerlink" title="SimpleControllerHandlerAdapter#handle"></a>SimpleControllerHandlerAdapter#handle</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter#handle</code>    </p>
</blockquote>
<p><strong>处理实现 Controller 接口的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// Controller 类型的调用</span></span><br><span class="line">    <span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HttpRequestHandlerAdapter-handle"><a href="#HttpRequestHandlerAdapter-handle" class="headerlink" title="HttpRequestHandlerAdapter#handle"></a>HttpRequestHandlerAdapter#handle</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter#handle</code></p>
</blockquote>
<p><strong>处理实现 HttpRequestHandler 接口的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// HttpRequestHandler 类型的调用</span></span><br><span class="line">    ((HttpRequestHandler) handler).handleRequest(request, response);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#handle</code><br><strong>定位</strong>: <code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#handleInternal</code></p>
</blockquote>
<p><strong>处理实现 Controller 接口的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">handleInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    ModelAndView mav;</span><br><span class="line">    <span class="comment">// 校验请求（HttpMethod 和 Session 的校验）</span></span><br><span class="line">    checkRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">    <span class="comment">// 如果synchronizeOnSession为true，则对session进行同步，否则不同步</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">        <span class="comment">// 同步相同 Session 的逻辑，默认情况false</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Session的锁对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">mutex</span> <span class="operator">=</span> WebUtils.getSessionMutex(session);</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">            mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">        mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应不包含&#x27;Cache-Control&#x27;头</span></span><br><span class="line">    <span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">            applyCacheSeconds(response, <span class="built_in">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            prepareResponse(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RequestMappingHandlerAdapter-invokeHandlerMethod"><a href="#RequestMappingHandlerAdapter-invokeHandlerMethod" class="headerlink" title="RequestMappingHandlerAdapter#invokeHandlerMethod"></a>RequestMappingHandlerAdapter#invokeHandlerMethod</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod</code></p>
</blockquote>
<blockquote>
<p>构造 Controller 方法的参数和执行方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用request和response创建ServletWebRequest对象</span></span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建WebDataBinderFactory对象，此对象用来创建WebDataBinder对象，进行参数绑定，</span></span><br><span class="line">        <span class="comment">// 实现参数跟String之间的类型转换，ArgumentResolver在进行参数解析的过程中会用到WebDataBinder</span></span><br><span class="line">        <span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">        <span class="comment">// 创建ModelFactory对象，此对象主要用来处理model，主要是两个功能，1是在处理器具体处理之前对model进行初始化，2是在处理完请求后对model参数进行更新</span></span><br><span class="line">        <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ServletInvocableHandlerMethod对象，并设置其相关属性，实际的请求处理就是通过此对象来完成的,参数绑定、处理请求以及返回值处理都在里边完成</span></span><br><span class="line">        <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        <span class="comment">// 设置参数处理器</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置返回值处理器</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置参数绑定工厂对象</span></span><br><span class="line">        invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">        <span class="comment">// 设置参数名称发现器</span></span><br><span class="line">        invocableMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ModelAndViewContainer对象，用于保存model和View对象</span></span><br><span class="line">        <span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">        <span class="comment">// 将flashmap中的数据设置到model中</span></span><br><span class="line">        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">        <span class="comment">// 使用modelFactory将sessionAttributes和注释了@ModelAttribute的方法的参数设置到model中</span></span><br><span class="line">        modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">        <span class="comment">// 根据配置对ignoreDefaultModelOnRedirect进行设置</span></span><br><span class="line">        mavContainer.setIgnoreDefaultModelOnRedirect(<span class="built_in">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建AsyncWebRequest异步请求对象</span></span><br><span class="line">        <span class="type">AsyncWebRequest</span> <span class="variable">asyncWebRequest</span> <span class="operator">=</span> WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">        asyncWebRequest.setTimeout(<span class="built_in">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建WebAsyncManager异步请求管理器对象</span></span><br><span class="line">        <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">        asyncManager.setTaskExecutor(<span class="built_in">this</span>.taskExecutor);</span><br><span class="line">        asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">        asyncManager.registerCallableInterceptors(<span class="built_in">this</span>.callableInterceptors);</span><br><span class="line">        asyncManager.registerDeferredResultInterceptors(<span class="built_in">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> asyncManager.getConcurrentResult();</span><br><span class="line">            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">            asyncManager.clearConcurrentResult();</span><br><span class="line">            LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行调用</span></span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理完请求后的后置处理，此处一共做了三件事，</span></span><br><span class="line">        <span class="comment">// 1、调用ModelFactory的updateModel方法更新model，包括设置SessionAttribute和给Model设置BinderResult</span></span><br><span class="line">        <span class="comment">// 2、根据mavContainer创建了ModelAndView</span></span><br><span class="line">        <span class="comment">// 3、如果mavContainer里的model是RedirectAttributes类型，则将其设置到FlashMap</span></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 标记请求完成</span></span><br><span class="line">        webRequest.requestCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RequestMappingHandlerAdapter-getDataBinderFactory"><a href="#RequestMappingHandlerAdapter-getDataBinderFactory" class="headerlink" title="RequestMappingHandlerAdapter#getDataBinderFactory"></a>RequestMappingHandlerAdapter#getDataBinderFactory</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getDataBinderFactory</code></p>
</blockquote>
<blockquote>
<p>处理 @InitBinder 注解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> WebDataBinderFactory <span class="title function_">getDataBinderFactory</span><span class="params">(HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span><br><span class="line">    <span class="comment">// 检查当前Handler中的initBinder方法是否已经存在于缓存中</span></span><br><span class="line">    Set&lt;Method&gt; methods = <span class="built_in">this</span>.initBinderCache.get(handlerType);</span><br><span class="line">    <span class="comment">// 如果没有则查找并设置到缓冲中</span></span><br><span class="line">    <span class="keyword">if</span> (methods == <span class="literal">null</span>) &#123;</span><br><span class="line">        methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS);<span class="comment">// 将当前Controller中所有被@InitBinder注解修饰的方法都获取到</span></span><br><span class="line">        <span class="built_in">this</span>.initBinderCache.put(handlerType, methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义保存InitBinder方法的临时变量</span></span><br><span class="line">    List&lt;InvocableHandlerMethod&gt; initBinderMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// Global methods first</span></span><br><span class="line">    <span class="comment">// 将所有符合条件的全局InitBinder方法添加到initBinderMethods</span></span><br><span class="line">    <span class="built_in">this</span>.initBinderAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> controllerAdviceBean.resolveBean();</span><br><span class="line">            <span class="keyword">for</span> (Method method : methodSet) &#123;</span><br><span class="line">                initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 将当前handler中的initBinder方法添加到initBinderMethods</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">// 创建当前方法对应的bean对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> handlerMethod.getBean();</span><br><span class="line">        <span class="comment">// 将method适配为可执行的invocableHandlerMethod</span></span><br><span class="line">        initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建DataBinderFactory并返回</span></span><br><span class="line">    <span class="keyword">return</span> createDataBinderFactory(initBinderMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="RequestMappingHandlerAdapter-getModelFactory"><a href="#RequestMappingHandlerAdapter-getModelFactory" class="headerlink" title="RequestMappingHandlerAdapter#getModelFactory"></a>RequestMappingHandlerAdapter#getModelFactory</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getModelFactory</code></p>
</blockquote>
<blockquote>
<p>处理 @ModelAttribute 注解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ModelFactory <span class="title function_">getModelFactory</span><span class="params">(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取sessionAttributesHandler</span></span><br><span class="line">    <span class="type">SessionAttributesHandler</span> <span class="variable">sessionAttrHandler</span> <span class="operator">=</span> getSessionAttributesHandler(handlerMethod);</span><br><span class="line">    <span class="comment">// 获取处理器类的类型</span></span><br><span class="line">    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span><br><span class="line">    <span class="comment">// 获取处理器类中注释了@modelAttribute而且没有注释@RequestMapping的类型，第一个获取后添加到缓存，以后直接从缓存中获取</span></span><br><span class="line">    Set&lt;Method&gt; methods = <span class="built_in">this</span>.modelAttributeCache.get(handlerType);</span><br><span class="line">    <span class="keyword">if</span> (methods == <span class="literal">null</span>) &#123;</span><br><span class="line">        methods = MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">        <span class="built_in">this</span>.modelAttributeCache.put(handlerType, methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注释了@ModelAttribute的方法</span></span><br><span class="line">    List&lt;InvocableHandlerMethod&gt; attrMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// Global methods first</span></span><br><span class="line">    <span class="comment">// 先添加全局的@ModelAttribute方法，后添加当前处理器定义的@ModelAttribute方法</span></span><br><span class="line">    <span class="built_in">this</span>.modelAttributeAdviceCache.forEach((controllerAdviceBean, methodSet) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (controllerAdviceBean.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> controllerAdviceBean.resolveBean();</span><br><span class="line">            <span class="keyword">for</span> (Method method : methodSet) &#123;</span><br><span class="line">                attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> handlerMethod.getBean();</span><br><span class="line">        attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新建ModelFactory对象，此处需要三个参数，第一个是注释了@ModelAttribute的方法，第二个是WebDataBinderFactory,第三个是SessionAttributeHandler</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelFactory</span>(attrMethods, binderFactory, sessionAttrHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ServletInvocableHandlerMethod-invokeAndHandle"><a href="#ServletInvocableHandlerMethod-invokeAndHandle" class="headerlink" title="ServletInvocableHandlerMethod#invokeAndHandle"></a>ServletInvocableHandlerMethod#invokeAndHandle</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle</code></p>
</blockquote>
<blockquote>
<p>执行方法, 处理返回值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">        Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类的invokeForRequest执行请求</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    <span class="comment">// 处理@ResponseStatus注解</span></span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理返回值，判断返回值是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// request的NotModified为true，有@ResponseStatus,RequestHandled为true，三个条件有一个成立，则设置请求处理完成并返回</span></span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="literal">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回值不为null，@ResponseStatus存在reason，这是请求处理完成并返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面都不成立，则设置RequestHandled为false即请求完成??????????</span></span><br><span class="line">    mavContainer.setRequestHandled(<span class="literal">false</span>);</span><br><span class="line">    Assert.state(<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用returnValueHandlers处理返回值</span></span><br><span class="line">        <span class="built_in">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="InvocableHandlerMethod-invokeForRequest"><a href="#InvocableHandlerMethod-invokeForRequest" class="headerlink" title="InvocableHandlerMethod#invokeForRequest"></a>InvocableHandlerMethod#invokeForRequest</h5><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest</code></p>
</blockquote>
<blockquote>
<p>执行方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">        Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备方法所需要的参数</span></span><br><span class="line">    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体调用method</span></span><br><span class="line">    <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">        Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取方法的参数</span></span><br><span class="line">    MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于保存解析出参数的值</span></span><br><span class="line">    Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">        <span class="type">MethodParameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">        <span class="comment">// 给parameter设置参数名解析器</span></span><br><span class="line">        parameter.initParameterNameDiscovery(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">        <span class="comment">// 如果相应类型的参数已经在providedArgs中提供了，则直接设置到parameter</span></span><br><span class="line">        args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (args[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用argumentResolvers解析参数</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            args[i] = <span class="built_in">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="built_in">this</span>.dataBinderFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// Leave stack trace for later, exception may actually be resolved and handled...</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">exMsg</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">                <span class="keyword">if</span> (exMsg != <span class="literal">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">                    logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//强制方法可调用</span></span><br><span class="line">    ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        <span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        assertTargetBean(getBridgedMethod(), getBean(), args);</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> (ex.getMessage() != <span class="literal">null</span> ? ex.getMessage() : <span class="string">&quot;Illegal argument&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatInvokeError(text, args), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">targetException</span> <span class="operator">=</span> ex.getTargetException();</span><br><span class="line">        <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatInvokeError(<span class="string">&quot;Invocation failure&quot;</span>, args), targetException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="HandlerMethodReturnValueHandlerComposite-handleReturnValue"><a href="#HandlerMethodReturnValueHandlerComposite-handleReturnValue" class="headerlink" title="HandlerMethodReturnValueHandlerComposite#handleReturnValue"></a>HandlerMethodReturnValueHandlerComposite#handleReturnValue</h5><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#handleReturnValue</code></p>
</blockquote>
<blockquote>
<p>处理返回值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 根据返回值确定 Handler</span></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandler</span> <span class="variable">handler</span> <span class="operator">=</span> selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 源码之网络请求(4)</title>
    <url>/2020/10/26/SpringMVC/SpringMVC07/</url>
    <content><![CDATA[<h3 id="DispatcherServlet-processDispatchResult"><a href="#DispatcherServlet-processDispatchResult" class="headerlink" title="DispatcherServlet#processDispatchResult"></a>DispatcherServlet#processDispatchResult</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#processDispatchResult</code>    </p>
</blockquote>
<blockquote>
<p>处理 ModelAndView; 或者将异常转换为 ModelAndView  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记是否为处理生成异常的ModelAndView对象</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求处理过程中有异常抛出则处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从ModelAndViewDefiningException中获得ModelAndView对象</span></span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理异常，生成ModelAndView对象</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> (mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="comment">// 是否进行页面渲染</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 渲染页面</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="comment">// 清理请求中的错误消息属性</span></span><br><span class="line">        <span class="comment">// 因为上述的情况中，processHandlerException会通过WebUtils设置错误消息属性，所以需要进行清理</span></span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果启动了异步处理则返回</span></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发出请求处理完成通知，触发Interceptor的afterCompletion</span></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Exception (if any) is already handled..</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DispatcherServlet-processHandlerException"><a href="#DispatcherServlet-processHandlerException" class="headerlink" title="DispatcherServlet#processHandlerException"></a>DispatcherServlet#processHandlerException</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.web.servlet.DispatcherServlet#processHandlerException</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">processHandlerException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Success and error responses may use different content types</span></span><br><span class="line">    <span class="comment">// 移除 PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE 属性</span></span><br><span class="line">    request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check registered HandlerExceptionResolvers...</span></span><br><span class="line">    <span class="comment">// 遍历 HandlerExceptionResolver 数组，解析异常，生成 ModelAndView 对象</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">exMv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerExceptionResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历 HandlerExceptionResolver 数组</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerExceptionResolver resolver : <span class="built_in">this</span>.handlerExceptionResolvers) &#123;</span><br><span class="line">            <span class="comment">// 解析异常，生成 ModelAndView 对象</span></span><br><span class="line">            exMv = resolver.resolveException(request, response, handler, ex);</span><br><span class="line">            <span class="comment">// 生成成功，结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况一，生成了 ModelAndView 对象，进行返回</span></span><br><span class="line">    <span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ModelAndView 对象为空，则返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (exMv.isEmpty()) &#123;</span><br><span class="line">            request.setAttribute(EXCEPTION_ATTRIBUTE, ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We might still need view name translation for a plain error model...</span></span><br><span class="line">        <span class="comment">// 没有视图则设置默认视图</span></span><br><span class="line">        <span class="keyword">if</span> (!exMv.hasView()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">defaultViewName</span> <span class="operator">=</span> getDefaultViewName(request);</span><br><span class="line">            <span class="keyword">if</span> (defaultViewName != <span class="literal">null</span>) &#123;</span><br><span class="line">                exMv.setViewName(defaultViewName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Using resolved error view: &quot;</span> + exMv, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Using resolved error view: &quot;</span> + exMv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置请求中的错误消息属性</span></span><br><span class="line">        WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());</span><br><span class="line">        <span class="keyword">return</span> exMv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未生成 ModelAndView 对象，则抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 源码之异步处理</title>
    <url>/2020/10/26/SpringMVC/SpringMVC08/</url>
    <content><![CDATA[<h3 id="SpringMVC-如何实现实现异步处理"><a href="#SpringMVC-如何实现实现异步处理" class="headerlink" title="SpringMVC 如何实现实现异步处理"></a>SpringMVC 如何实现实现异步处理</h3><p><a href="https://www.vnjohn.com/spring-mvc-async.html">原创文章</a></p>
<p>在 SpringMVC 中为了方便使用异步请求专门提供了 AsyncWebRequest 类型的 request，并且提供了处理异步请求的管理器 WebAsyncManager 和工具 WebAsyncUtils。</p>
<p>AsyncWebRequest：专门来处理异步请求的，会将原来的 HttpServletRequest 类型做一层封装</p>
<p>WebAsyncManager：SpringMVC 异步请求处理过程中最核心的类型，管理着整个异步处理的过程</p>
<p>WebAsyncUtils：异步工具类，用来获取 WebAsyncManager 以及创建 AsyncWebRequest 对象</p>
<p>在 SpringMVC 中，对异步请求的处理提供了四个地方的支持：</p>
<p>（1）FrameworkServlet 中给当前请求的 WebAsyncManager 添加了 CallableProcessingInterceptor 类型的拦截器-&gt;RequestBindingInterceptor，<br>目的是为了在请求处理前将当前请求的 LocaleContext 和 ServletRequestAttributes 设置到 LocaleContextHolder 和 RequestContextHolder 中，<br>并在请求处理完成后恢复，添加过程在 FrameworkServlet#processRequest 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> <span class="title class_">RequestBindingInterceptor</span>());</span><br></pre></td></tr></table></figure>

<p>（2）RequestMappingHandlerAdapter#invokeHandlerMethod 方法中提供了对异步请求的核心支持，其中做了时间跟异步处理相关的事情：</p>
<ul>
<li>创建 AsyncWebRequest，并设置了超时时间</li>
<li>对当前请求的 WebAsyncManager 设置四个属性</li>
<li>如果当前请求是异步请求而且已经处理出了结果，则将异步结果与之前保存到 WebAsyncManager 里的 ModelAndViewContainer 取出来，并将 WebAsyncManager 异步执行结果取出，然后调用 ServletInvocableHandlerMethod#wrapConcurrentResult 方法创建 ConcurrentResultHandlerMethod 子类来替换 ServletInvocableHandlerMethod，创建出来的 ConcurrentResultHandlerMethod 并不执行请求，主要是判断异步处理的结果是不是异常类型，如果是则抛出，如果不是则使用返回值处理器 HandlerMethodReturnValueHandler 对其进行解析并将处理后的结果返回</li>
<li>如果 requestMappingMethod#invokeAndHandler 方法执行完成后检查到当前请求已经启动了异步处理，则会直接返回 null</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 AsyncWebRequest 异步请求对象</span></span><br><span class="line"><span class="type">AsyncWebRequest</span> <span class="variable">asyncWebRequest</span> <span class="operator">=</span> WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">asyncWebRequest.setTimeout(<span class="built_in">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 WebAsyncManager 异步请求管理器对象</span></span><br><span class="line"><span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.setTaskExecutor(<span class="built_in">this</span>.taskExecutor);</span><br><span class="line">asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">asyncManager.registerCallableInterceptors(<span class="built_in">this</span>.callableInterceptors);</span><br><span class="line">asyncManager.registerDeferredResultInterceptors(<span class="built_in">this</span>.deferredResultInterceptors);</span><br><span class="line"><span class="comment">// 如果当前异步请求已经处理并得到结果，则将返回的结果放到 mavContainer 对象中，然后将 invocable 对象进行包装转换，转成需要的执行对象然后开始执行</span></span><br><span class="line"><span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> asyncManager.getConcurrentResult();</span><br><span class="line">    mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">    asyncManager.clearConcurrentResult();</span><br><span class="line">    LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 转换具体的invocable执行对象</span></span><br><span class="line">    invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行调用</span></span><br><span class="line">invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）返回值处理器：一个有四个处理异步请求的返回值处理器，分别是 AsyncTaskMethodReturnValueHandler、CallableMethodReturnValueHandler、DeferredResultMethodReturnValueHandler、ListenableFutureReturnValueHandler，每一种对应一种类型的返回值，主要作用是使用 WebAsyncManager 启动异步处理.</p>
<p>（4）在 DispatcherServlet#doDispatcher 方法中，当 HandlerAdpater 使用 handler 处理完请求时，会检查是否已经启动了异步处理器，如果启动了则不再往下处理，直接返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意处理流程如下</strong>：首先在处理器中返回需要启动异步处理的类型时，相应的返回值处理器会调用 WebAsyncManager 相关方法启动异步处理，<br>然后再 DispatcherServlet 中将原来请求直接返回，当异步处理完成后会重新发出一个相同的请求，这个是在 RequestMappingAdapter 中会使用特殊的 ServletInvocableHandlerMethod 来处理请求，处理方法是：如果是异步处理返回的结果是异常类型则抛出异常，否则直接返回异常处理结果，然后使用返回值处理器对其处理，接着返回 DispatcherServlet 中按正常流程往下处理。</p>
<h3 id="WebAsyncTask和Callable类型异步请求的处理过程及方法"><a href="#WebAsyncTask和Callable类型异步请求的处理过程及方法" class="headerlink" title="WebAsyncTask和Callable类型异步请求的处理过程及方法"></a>WebAsyncTask和Callable类型异步请求的处理过程及方法</h3><p>当处理器方法返回WebAsyncTask或者Callable类型时将自动启用异步处理，使用WebAsyncTask类型返回值的处理器AsyncTaskMethodReturnValueHandler，如果返回值为null，就会给mavContainer设置为请求已处理，然后返回，如果返回值不为空，调用WebAsyncManager的startCallableProcessing方法处理请求</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-test<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SpringMVC配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/web_async_task&quot;,produces = &quot;text/plain; charset=UTF-8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title function_">webAsyncTask</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;WebAsyncTask处理器主线程进入&quot;</span>);</span><br><span class="line">    WebAsyncTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">WebAsyncTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>*<span class="number">1000L</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;WebAsyncTask处理执行中。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;久等了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;WebAsyncTask处理器主线程退出&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/callable&quot;,produces = &quot;text/plain; charset=UTF-8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title function_">callable</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Callable处理器主线程进入&quot;</span>);</span><br><span class="line">    Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span> * <span class="number">1000L</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Callable处理执行中。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;久等了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;Callable处理器主线程退出&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>SpringMVC</tag>
        <tag>异步处理</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 源码之常用接口</title>
    <url>/2020/10/26/SpringMVC/SpringMVC09/</url>
    <content><![CDATA[<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="HandlerMethodArgumentResolver"><a href="#HandlerMethodArgumentResolver" class="headerlink" title="HandlerMethodArgumentResolver"></a>HandlerMethodArgumentResolver</h3><p><strong>作用</strong>: 用于解析调用Controller层方法的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断是否可以解析传入的参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 实际解析参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">			NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><ol>
<li>ServletRequestMethodArgumentResolver / ServletResponseMethodArgumentResolver<br>自动绑定 HttpServletRequest 和 HttpServletResponse</li>
<li>RequestParamMapMethodArgumentResolver<br>处理被 @RequestParam 修饰的参数</li>
<li>RequestHeaderMapMethodArgumentResolver<br>处理被 @RequestHeader 修饰的参数</li>
<li>PathVariableMapMethodArgumentResolver<br>处理被 @PathVariable 修饰的参数</li>
<li>ModelAttributeMethodProcessor<br>处理被 @ModelAttribute 修饰的参数</li>
<li>RequestResponseBodyMethodProcessor<br>处理被 @RequestBody 修饰的参数</li>
</ol>
<h3 id="HandlerMethodReturnValueHandler"><a href="#HandlerMethodReturnValueHandler" class="headerlink" title="HandlerMethodReturnValueHandler"></a>HandlerMethodReturnValueHandler</h3><p><strong>作用</strong>： 处理处理器执行后的返回值，主要有三个功能：</p>
<ul>
<li>1、将相应的参数添加到model中</li>
<li>2、设置view</li>
<li>3、如果请求已经处理完, 则设置 ModelAndViewContainer 的 requestHandled 为 true</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMethodReturnValueHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断是否支持</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">supportsReturnType</span><span class="params">(MethodParameter returnType)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 具体处理返回值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">			ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>ModelAttributeMethodProcessor<br>处理被 @ModelAttribute 修饰的方法</li>
<li>RequestResponseBodyMethodProcessor<br>处理被 @RequestBody 修饰的方法</li>
<li>ViewMethodReturnValueHandler<br>处理View类型返回值，如果是 redirect 类型则设置 mavContainer 的 redirectModelScenario</li>
</ol>
<h3 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h3><p><strong>作用</strong>: 转换HTTP请求体和响应体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpMessageConverter</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 能否读取(处理请求体)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">(Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> MediaType mediaType)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 能够写入(处理响应体)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">(Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> MediaType mediaType)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  获取支持的 MediaType</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;MediaType&gt; <span class="title function_">getSupportedMediaTypes</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 读取请求体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	T <span class="title function_">read</span><span class="params">(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, HttpMessageNotReadableException;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置响应体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">write</span><span class="params">(T t, <span class="meta">@Nullable</span> MediaType contentType, HttpOutputMessage outputMessage)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, HttpMessageNotWritableException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用实现类-1"><a href="#常用实现类-1" class="headerlink" title="常用实现类"></a>常用实现类</h4><ol>
<li>ByteArrayHttpMessageConverter</li>
<li>StringHttpMessageConverter</li>
<li>ResourceHttpMessageConverter</li>
<li>SourceHttpMessageConverter</li>
<li>AllEncompassingFormHttpMessageConverter</li>
<li>Jaxb2RootElementHttpMessageConverter</li>
<li>MappingJackson2HttpMessageConverter</li>
</ol>
<h3 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h3><p><strong>作用</strong>: Controller 层调用拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * preHandler 方法是在 Controller 处理之前调用，SpringMVC 的拦截器是链式的，可以同时存在多个 Interceptor，</span></span><br><span class="line"><span class="comment">	 * 然后 SpringMVC 会根据声明的顺序执行。SpringMVC 拦截器的链式是可以中断的，</span></span><br><span class="line"><span class="comment">	 * 当 preHandler 的返回值是 false 时整个请求就结束了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * postHandle 在 Controller 方法调用之后，在 DispatcherServlet 进行视图渲染之前执行，</span></span><br><span class="line"><span class="comment">	 * 也就是说在这个方法中可以操作 ModelAndView，也可以在 DispatcherServlet 中看到调用拦截器的 postHandler 是传入了 ModelAndView 参数。</span></span><br><span class="line"><span class="comment">	 * 这个方法的链式结构和声明的顺序是相反的，也就是先声明拦截器反而后执行</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * afterCompletion 在整个请求执行完之后执行，也就是 DispatcherServlet 视图渲染之后执行，这个方法主要作用是用于清理资源</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用实现类-2"><a href="#常用实现类-2" class="headerlink" title="常用实现类"></a>常用实现类</h3><ol>
<li>AbstractHandlerMapping.CorsInterceptor<br>处理跨域请求</li>
<li>UserRoleAuthorizationInterceptor<br>检查当前用户的授权情况</li>
</ol>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="ControllerAdvice"></a>ControllerAdvice</h3><p><strong>作用</strong>：此注解的Controller是一个增强的Controller，主要有三个功能<br>– 全局异常处理<br>– 全局数据绑定<br>– 全局数据预处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerAdviceController</span> &#123;</span><br><span class="line">    <span class="comment">//全局异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">customerException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">       <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">       mv.addObject(<span class="string">&quot;message&quot;</span>, e.getMessage());</span><br><span class="line">       mv.setViewName(<span class="string">&quot;myerror&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局数据绑定</span></span><br><span class="line">    <span class="meta">@ModelAttribute(name = &quot;mock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">mockData</span><span class="params">()</span> &#123;</span><br><span class="line">       HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">&quot;age&quot;</span>, <span class="number">99</span>);</span><br><span class="line">       map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局数据预处理</span></span><br><span class="line">    <span class="meta">@InitBinder(&quot;field&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defaultPrefix</span><span class="params">(WebDataBinder binder)</span> &#123;</span><br><span class="line">       binder.setFieldDefaultPrefix(<span class="string">&quot;field.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="ExceptionHandler"></a>ExceptionHandler</h3><p><strong>作用</strong>： 用于处理异常的注解。@ExceptionHandler是一个用于处理控制器中出现的异常的注解。它可以用于方法级别，用于指定处理控制器中出现的异常的方式。</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>SpringMVC</tag>
        <tag>常用接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码学习</title>
    <url>/2020/10/25/spring/Spring00/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本系列笔记从简单的 demo 出发，来阅读 Spring 的源码。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><a href="../Spring01">Spring源码之容器加载</a></p>
<p><a href="../Spring02">Spring 源码之核心加载方法(1)</a></p>
<p><a href="../Spring03">Spring 源码之核心加载方法(2) BeanFactory 创建</a></p>
<p><a href="../Spring04">Spring 源码之核心加载方法(2) 配置文件加载</a></p>
<p><a href="../Spring05">Spring 源码之核心加载方法(2) 配置文件加载2</a></p>
<p><a href="../Spring06">Spring 源码之核心加载方法(3) beanFactory 的准备工作</a></p>
<p><a href="../Spring07">Spring 源码之核心加载方法(4) 容器钩子方法</a></p>
<p><a href="../Spring08">Spring 源码之核心加载方法(5) 执行 BeanFactoryPostProcessor</a></p>
<p><a href="../Spring09">Spring 源码之核心加载方法(6) 注册 BeanPostProcessor</a></p>
<p><a href="../Spring10">Spring 源码之核心加载方法(7) 初始化消息资源</a></p>
<p><a href="../Spring11">Spring 源码之核心加载方法(8-10) 初始化和注册广播器</a></p>
<p><a href="../Spring12">Spring 源码之核心加载方法(11) 实例化对象</a></p>
<p><a href="../Spring13">Spring 源码之核心加载方法(12) 实例化对象</a></p>
<p><a href="../Spring14">Spring 源码之核心加载方法(13) finishRefresh</a></p>
<p><a href="../Spring15">Spring 源码之核心加载方法(14) 完成后清理</a></p>
<p><a href="../Spring16">Spring 源码之核心加载方法 常用扩展点接口</a></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://gitee.com/devinx3/learn-spring-framework5.2">源码注释</a></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之容器加载</title>
    <url>/2020/10/25/spring/Spring01/</url>
    <content><![CDATA[<h2 id="加载文件方式"><a href="#加载文件方式" class="headerlink" title="加载文件方式"></a>加载文件方式</h2><h3 id="xml-配置文件"><a href="#xml-配置文件" class="headerlink" title="xml 配置文件"></a>xml 配置文件</h3><h4 id="类路径获取配置文件"><a href="#类路径获取配置文件" class="headerlink" title="类路径获取配置文件"></a>类路径获取配置文件</h4><p><code>ApplicationContext applicationContext= new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);</code></p>
<h4 id="文件系统路径获取配置文件"><a href="#文件系统路径获取配置文件" class="headerlink" title="文件系统路径获取配置文件"></a>文件系统路径获取配置文件</h4><p><code>ApplicationContext applicationContext = new FileSystemXmlApplicationContext(&quot;/home/usr/learn-spring-framework5.2/spring-demo/src/main/resources/spring.xml&quot;);</code></p>
<h3 id="Java-配置类"><a href="#Java-配置类" class="headerlink" title="Java 配置类"></a>Java 配置类</h3><p><code>ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringDemoConfig.class);</code></p>
<h2 id="Spring-核心加载方法"><a href="#Spring-核心加载方法" class="headerlink" title="Spring 核心加载方法"></a>Spring 核心加载方法</h2><p><code>AbstractApplicationContext#refresh()</code>方法是 Spring 容器启动过程中的核心方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载或刷新配置的持久化表示，可能是XML文件、属性文件或关系数据库。</span></span><br><span class="line"><span class="comment"> * 由于这是一个启动方法，如果它调用失败，它应该销毁已创建的单例，以避免悬空资源。换句话说，在调用该方法之后，要么全部实例化，要么都不实例化。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 使用对象锁 startUpShutdownMonitor 进行同步控制:</span></span><br><span class="line"><span class="comment">     * 1、避免了多线程同时刷新 spring 配置,只对不能并发的代码块进行加锁, 提高了整体代码运行的效率;</span></span><br><span class="line"><span class="comment">     * 2、refresh() 方法和 close() 方法都使用了 startUpShutdownMonitor 对象锁加锁，</span></span><br><span class="line"><span class="comment">     *   这就保证了在调用 refresh() 方法的时候无法调用 close() 方法,避免了冲突;</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		<span class="comment">// 容器刷新前的准备工作</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 1. 设置容器的启动时间</span></span><br><span class="line"><span class="comment">		 * 2. 设置容器开启和关闭标志位</span></span><br><span class="line"><span class="comment">		 * 3. 获取 Environment 对象, 并加载当前系统的属性到 Environment 对象中</span></span><br><span class="line"><span class="comment">		 * 4. 准备监听器和事件的集合对象, 默认为空集合</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		<span class="comment">// 创建容器对象：DefaultListableBeanFactory</span></span><br><span class="line">		<span class="comment">// 解析xml配置文件的属性值封装到BeanDefinition对象中, 并注册到当前工厂中</span></span><br><span class="line">		<span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">		<span class="comment">// beanFactory的准备工作，对各种属性进行填充(为容器注册必要的系统级别的Bean)</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			<span class="comment">// 允许容器的子类去注册 postProcessor, 钩子方法</span></span><br><span class="line">			<span class="comment">// 子类覆盖方法做额外的处理, 可参考 web 中的代码</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">			<span class="comment">// 调用容器中的各种 beanFactory 的后置处理器</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">			<span class="comment">// 向容器注册 bean 的后置处理器，这里只是注册功能，真正调用的是 getBean 方法</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">			<span class="comment">// 为上下文初始化message源，即不同语言的消息体 (国际化处理)</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			<span class="comment">// 初始化事件监听多路广播器</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			<span class="comment">// 在单例 Bean 初始化之前预留子类初始化其他特殊 Bean 的口子, 钩子方法</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			<span class="comment">// 在所有注册的 bean 中查找 listener bean, 注册到消息广播器中</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">			<span class="comment">// 实例化所有剩余的（非懒加载）单例</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			<span class="comment">// 完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，</span></span><br><span class="line">			<span class="comment">// 同时发出 ContextRefreshEvent 事件通知别人</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            <span class="comment">// 销毁已经创建的Bean</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            <span class="comment">// 重置容器激活标签</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			<span class="comment">// 重置 Spring 内核中的公用缓存</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(1)</title>
    <url>/2020/10/25/spring/Spring02/</url>
    <content><![CDATA[<h2 id="1-prepareRefresh"><a href="#1-prepareRefresh" class="headerlink" title="1.  prepareRefresh"></a>1.  <code>prepareRefresh</code></h2><h5 id="定位-org-springframework-context-support-AbstractApplicationContext-prepareRefresh"><a href="#定位-org-springframework-context-support-AbstractApplicationContext-prepareRefresh" class="headerlink" title="定位: org.springframework.context.support.AbstractApplicationContext#prepareRefresh"></a>定位: <code>org.springframework.context.support.AbstractApplicationContext#prepareRefresh</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备刷新，设置应用开启的时间还有active标志，并且执行一些属性源的初始化工作</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Switch to active.</span></span><br><span class="line">   <span class="comment">// 设置容器启动实现</span></span><br><span class="line">   <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">// 设置容器的关闭标志位</span></span><br><span class="line">   <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">   <span class="comment">// 设置容器的开启标志位</span></span><br><span class="line">   <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">   <span class="comment">// 初始化placeholder属性, 默认未实现, 由子类实现</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">   <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">   <span class="comment">// 创建并获取环境对象，验证需要的属性文件是否都已经放入环境中</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">   <span class="comment">// 判断刷新前的应用程序监听器集合是否为空，如果为空，则将监听器添加到此集合中</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationListeners == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.earlyApplicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.applicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">      <span class="comment">// 如果不等于空，则清空集合元素对象</span></span><br><span class="line">      <span class="built_in">this</span>.applicationListeners.clear();</span><br><span class="line">      <span class="built_in">this</span>.applicationListeners.addAll(<span class="built_in">this</span>.earlyApplicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">   <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">   <span class="comment">// 允许应用启动之前的事件，当多播器一旦可用的时候，可用立刻响应发布的事件。</span></span><br><span class="line">   <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(2) BeanFactory 创建</title>
    <url>/2020/10/25/spring/Spring03/</url>
    <content><![CDATA[<h2 id="2-AbstractApplicationContext-obtainFreshBeanFactory"><a href="#2-AbstractApplicationContext-obtainFreshBeanFactory" class="headerlink" title="2. AbstractApplicationContext#obtainFreshBeanFactory"></a>2. AbstractApplicationContext#obtainFreshBeanFactory</h2><blockquote>
<p><strong>定位</strong>: <code>org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 告诉子类刷新内部 bean 工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化 BeanFactory, 并进行XML文件读取，并将获取的 BeanFactory 记录在当前实体的属性中</span></span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	<span class="comment">// 返回当前实体的 beanFactory 属性</span></span><br><span class="line">	<span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractRefreshableApplicationContext-refreshBeanFactory"><a href="#AbstractRefreshableApplicationContext-refreshBeanFactory" class="headerlink" title="AbstractRefreshableApplicationContext#refreshBeanFactory"></a>AbstractRefreshableApplicationContext#refreshBeanFactory</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此实现执行此上下文的底层bean工厂的实际刷新，关闭前一个bean工厂（如果有的话），并为上下文生命周期的下一个阶段初始化一个新的bean工厂。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// 判断是否存在 BeanFactory, 存在则销毁所有Beans，并且关闭BeanFactory</span></span><br><span class="line">   <span class="comment">// 目的是避免重复加载BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      <span class="comment">// 如果实例化了BeanFactory，则先销毁所有的单例Bean</span></span><br><span class="line">      destroyBeans();</span><br><span class="line">      <span class="comment">// 关闭BeanFactory，也就是将beanFactory的值置为null</span></span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建具体的 beanFactory，这里创建的是 DefaultListableBeanFactory</span></span><br><span class="line">      <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">      <span class="comment">// 为了序列化指定id，可以从id反序列化到beanFactory对象</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">      <span class="comment">// 定制beanFactory，设置相关属性，包括是否允许覆盖同名称的不同定义的对象以及循环依赖</span></span><br><span class="line">      <span class="comment">// 有默认实现, 钩子方法</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">      <span class="comment">// 加载配置文件(执行 xml, groovy 和注解方式)并生成 BeanDefinitions</span></span><br><span class="line">      <span class="comment">// 初始化 XmlBeanDefinitionReader, 并进行XML文件读取及解析, 默认命名空间的解析, 自定义标签的解析</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AbstractRefreshableApplicationContext-createBeanFactory"><a href="#AbstractRefreshableApplicationContext-createBeanFactory" class="headerlink" title="AbstractRefreshableApplicationContext#createBeanFactory"></a>AbstractRefreshableApplicationContext#createBeanFactory</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.context.support.AbstractRefreshableApplicationContext#createBeanFactory</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个默认 内部bean 工厂</span></span><br><span class="line"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title function_">createBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> DefaultListableBeanFactory <span class="keyword">extends</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">ConfigurableListableBeanFactory</span>, BeanDefinitionRegistry, Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultListableBeanFactory</span><span class="params">(<span class="meta">@Nullable</span> BeanFactory parentBeanFactory)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(parentBeanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> AbstractAutowireCapableBeanFactory <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactory</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">AutowireCapableBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractAutowireCapableBeanFactory</span><span class="params">(<span class="meta">@Nullable</span> BeanFactory parentBeanFactory)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>();</span><br><span class="line">		setParentBeanFactory(parentBeanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="comment">// 依赖项检查和自动装配时忽略的依赖项接口</span></span><br><span class="line">		ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">		ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">		ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h5 id="AbstractRefreshableApplicationContext-customizeBeanFactory"><a href="#AbstractRefreshableApplicationContext-customizeBeanFactory" class="headerlink" title="AbstractRefreshableApplicationContext#customizeBeanFactory"></a>AbstractRefreshableApplicationContext#customizeBeanFactory</h5><blockquote>
<p><strong>定位</strong>: <code>org.springframework.context.support.AbstractRefreshableApplicationContext#customizeBeanFactory</code></p>
</blockquote>
<p>用于给子类提供一个自由配置的机会，默认实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">	<span class="comment">// 如果属性allowBeanDefinitionOverriding不为空，设置给beanFactory对象相应属性，是否允许覆盖同名称的不同定义的对象</span></span><br><span class="line">	<span class="comment">// 默认false，不允许覆盖</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.allowBeanDefinitionOverriding != <span class="literal">null</span>) &#123;</span><br><span class="line">		beanFactory.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果属性allowCircularReferences不为空，设置给beanFactory对象相应属性，是否允许bean之间存在循环依赖</span></span><br><span class="line">	<span class="comment">// 默认false，不允许循环引用</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.allowCircularReferences != <span class="literal">null</span>) &#123;</span><br><span class="line">		beanFactory.setAllowCircularReferences(<span class="built_in">this</span>.allowCircularReferences);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(2) 配置文件加载</title>
    <url>/2020/10/25/spring/Spring04/</url>
    <content><![CDATA[<h2 id="2-1-loadBeanDefinitions"><a href="#2-1-loadBeanDefinitions" class="headerlink" title="2.1 loadBeanDefinitions"></a>2.1 loadBeanDefinitions</h2><h3 id="AbstractRefreshableApplicationContext-loadBeanDefinitions"><a href="#AbstractRefreshableApplicationContext-loadBeanDefinitions" class="headerlink" title="AbstractRefreshableApplicationContext#loadBeanDefinitions"></a>AbstractRefreshableApplicationContext#loadBeanDefinitions</h3><blockquote>
<p> <strong>定位</strong>: <code>org.springframework.context.support.AbstractRefreshableApplicationContext#loadBeanDefinitions</code></p>
</blockquote>
<p>加载配置文件(执行 xml, groovy 和注解方式)并生成 BeanDefinitions</p>
<h3 id="AbstractXmlApplicationContext-loadBeanDefinitions"><a href="#AbstractXmlApplicationContext-loadBeanDefinitions" class="headerlink" title="AbstractXmlApplicationContext#loadBeanDefinitions"></a>AbstractXmlApplicationContext#loadBeanDefinitions</h3><blockquote>
<p> <strong>定位</strong>: <code>org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载 xml 配置文件, 并注册 beanDefinition</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">   <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">   <span class="comment">// 创建一个 XmlBeanDefinitionReader, 并通过回调设置到 beanFactory 中</span></span><br><span class="line">   <span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">   <span class="comment">// resource loading environment.</span></span><br><span class="line">   <span class="comment">// 给 beanDefinitionReader 对象设置对象</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="built_in">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="built_in">this</span>);</span><br><span class="line">   <span class="comment">// 设置要用于解析的 SAX 实体解析器</span></span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">   <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">   <span class="comment">// 初始化 beanDefinitionReader 对象，此处设置配置文件是否要进行验证</span></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   <span class="comment">// 加载并注册 beanDefinition</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>定位</strong>: <code>org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(XmlBeanDefinitionReader)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   <span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 从指定的资源加载 BeanDefinition</span></span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 从指定的资源位置加载 BeanDefinition</span></span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="XmlBeanDefinitionReader-loadBeanDefinitions"><a href="#XmlBeanDefinitionReader-loadBeanDefinitions" class="headerlink" title="XmlBeanDefinitionReader#loadBeanDefinitions"></a>XmlBeanDefinitionReader#loadBeanDefinitions</h3><blockquote>
<p><strong>定位</strong>：<code>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(EncodedResource)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取已经加载的资源记录</span></span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">      currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 从 encodedResource 中获取已经封装的 Resource 对象, 并再次从 Resource 中获取其中的 inputStream</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 实际从指定的XML文件加载 BeanDefinition (核心处理步骤)</span></span><br><span class="line">         <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XmlBeanDefinitionReader-doLoadBeanDefinitions"><a href="#XmlBeanDefinitionReader-doLoadBeanDefinitions" class="headerlink" title="XmlBeanDefinitionReader#doLoadBeanDefinitions"></a>XmlBeanDefinitionReader#doLoadBeanDefinitions</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#doLoadBeanDefinitions</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 此解析过程是由 XmlBeanDefinitionReader 来完成,</span></span><br><span class="line"><span class="comment">    * 从 重载 loadBeanDefinitions方法 (String[] -&gt; string -&gt; Resource[] -&gt; resource) ,</span></span><br><span class="line"><span class="comment">    * 最终开始将 resource 读取成一个 document 文档，根据文档的节点信息封装成一个个的 BeanDefinition 对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 将inpustream转换成Document, 此处获取 xml 文件的 document 对象,</span></span><br><span class="line">      <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="comment">// 注册 xml 文件定义的 BeanDefinition</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">      <span class="comment">// ... 省略日志打印</span></span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">      <span class="comment">// ... 省略</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="XmlBeanDefinitionReader-registerBeanDefinitions"><a href="#XmlBeanDefinitionReader-registerBeanDefinitions" class="headerlink" title="XmlBeanDefinitionReader#registerBeanDefinitions"></a>XmlBeanDefinitionReader#registerBeanDefinitions</h5><blockquote>
<p><strong>定位</strong>: <code>org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="comment">// 委托模式，BeanDefinitionDocumentReader 委托这个类进行 document 的解析</span></span><br><span class="line">   <span class="comment">// 创建 BeanDefinitionDocumentReader, 以用于实际从XML文档读取bean定义</span></span><br><span class="line">   <span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">   <span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">   <span class="comment">// 从给定的DOM文档中读取bean定义，并将他们向注册到注册表中</span></span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="XmlBeanDefinitionReader-doRegisterBeanDefinitions"><a href="#XmlBeanDefinitionReader-doRegisterBeanDefinitions" class="headerlink" title="XmlBeanDefinitionReader#doRegisterBeanDefinitions"></a>XmlBeanDefinitionReader#doRegisterBeanDefinitions</h5><blockquote>
<p><strong>定位</strong>: <code>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建BeanDefinitionParserDelegate委托对象，交给parseBeanDefinitions处理</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">   <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">   <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">         <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">         <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">         <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                     <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析 xml 的前置逻辑(扩展点, 钩子方法)</span></span><br><span class="line">   preProcessXml(root);</span><br><span class="line">   <span class="comment">// 真正的解析方法, 处理默认命名空间的标签(&quot;import&quot;、&quot;alias&quot;、&quot;bean&quot;) 和 自定义的标签</span></span><br><span class="line">   parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">   <span class="comment">// 解析 xml 的后置处理逻辑(扩展点, 钩子方法)</span></span><br><span class="line">   postProcessXml(root);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="DefaultBeanDefinitionDocumentReader-parseBeanDefinitions"><a href="#DefaultBeanDefinitionDocumentReader-parseBeanDefinitions" class="headerlink" title="DefaultBeanDefinitionDocumentReader#parseBeanDefinitions"></a>DefaultBeanDefinitionDocumentReader#parseBeanDefinitions</h6><blockquote>
<p><strong>定位</strong>: <code>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseBeanDefinitions</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               <span class="comment">// 文件的命名空间为 http://www.springframework.org/schema/beans</span></span><br><span class="line">               <span class="comment">// 解析 &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;, &quot;beans&quot; 标签</span></span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 处理自定义的标签</span></span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(2) 配置文件加载2</title>
    <url>/2020/10/25/spring/Spring05/</url>
    <content><![CDATA[<h1 id="2-1-1-解析-xml-文件"><a href="#2-1-1-解析-xml-文件" class="headerlink" title="2.1.1 解析 xml 文件"></a>2.1.1 解析 xml 文件</h1><h2 id="DefaultBeanDefinitionDocumentReader-parseDefaultElement"><a href="#DefaultBeanDefinitionDocumentReader-parseDefaultElement" class="headerlink" title="DefaultBeanDefinitionDocumentReader#parseDefaultElement"></a>DefaultBeanDefinitionDocumentReader#parseDefaultElement</h2><p>解析默认标签</p>
<blockquote>
<p><strong>定位</strong>: <code>org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseDefaultElement</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认标签的解析</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 解析 import 标签</span></span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 解析 alias 标签</span></span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 解析 bean 标签</span></span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 解析 beans 标签 (递归调用)</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DefaultBeanDefinitionDocumentReader-processBeanDefinition"><a href="#DefaultBeanDefinitionDocumentReader-processBeanDefinition" class="headerlink" title="DefaultBeanDefinitionDocumentReader#processBeanDefinition"></a>DefaultBeanDefinitionDocumentReader#processBeanDefinition</h3><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#processBeanDefinition</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">   <span class="comment">// beanDefinitionHolder 是 beanDefinition 对象的封装类，封装了BeanDefinition, bean的名字和别名, 用它来完成向IOC容器的注册</span></span><br><span class="line">   <span class="comment">// new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray)</span></span><br><span class="line">   <span class="comment">// 得到 beanDefinitionHolder 就意味着 beanDefinition 是通过 BeanDefinitionParserDelegate 对 xml 元素的信息按照 spring 的 bean 规则进行解析得到的</span></span><br><span class="line">   <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">         <span class="comment">// 向ioc容器注册解析得到的 beanDefinition</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Send registration event.</span></span><br><span class="line">      <span class="comment">// 在 beanDefinition 向 ioc 容器注册完成之后发送消息</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeanDefinitionParserDelegate-parseBeanDefinitionElement"><a href="#BeanDefinitionParserDelegate-parseBeanDefinitionElement" class="headerlink" title="BeanDefinitionParserDelegate#parseBeanDefinitionElement"></a>BeanDefinitionParserDelegate#parseBeanDefinitionElement</h4><p>解析 bean 基本属性 (id, name, aliases)</p>
<blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(Element, BeanDefinition)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line">   <span class="comment">// 解析id属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">   <span class="comment">// 解析name属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">   <span class="comment">// 如果bean有别名，则将别名分割解析</span></span><br><span class="line">   List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">               <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果在解析bean定义期间发生问题, 则返回null</span></span><br><span class="line">   <span class="comment">// 对bean元素的详细解析</span></span><br><span class="line">   <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">   <span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 如果不存在 beanName，那么根据 spring 中提供的命名规则为当前 beanDefinition 生成对应的 beanName</span></span><br><span class="line">               <span class="comment">// beanName = (([parentName + $child]) | ([factoryBeanName + $created])) + beanClassName + # + ObjectUtils.getIdentityHexString(definition)</span></span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 生成 Spring 内部的 beanName 和 aliases</span></span><br><span class="line">               <span class="comment">// beanName = beanClassName + # + index(索引 0, 1, 2, 3 ...)</span></span><br><span class="line">               <span class="comment">// eg: beanName = com.devinx3.service.impl.UserServiceImpl#0</span></span><br><span class="line">               <span class="comment">// eg: aliases = com.devinx3.service.impl.UserServiceImpl</span></span><br><span class="line">               beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">               <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">               <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">               <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">               <span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">               logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BeanDefinitionParserDelegate-parseBeanDefinitionElement-1"><a href="#BeanDefinitionParserDelegate-parseBeanDefinitionElement-1" class="headerlink" title="BeanDefinitionParserDelegate#parseBeanDefinitionElement"></a>BeanDefinitionParserDelegate#parseBeanDefinitionElement</h5><p>解析 bean 的其他属性</p>
<blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(Element, String, BeanDefinition)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionElement</span><span class="params">(</span></span><br><span class="line"><span class="params">      Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">BeanEntry</span>(beanName));</span><br><span class="line">   <span class="comment">// 解析class属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析parent属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">      parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建装在bean信息的AbstractBeanDefinition对象，实际上创建了 GenericBeanDefinition 对象</span></span><br><span class="line">      <span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析bean标签的各种其他属性</span></span><br><span class="line">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">      <span class="comment">// 设置 description 信息</span></span><br><span class="line">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析元数据</span></span><br><span class="line">      parseMetaElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 lookup-method 属性</span></span><br><span class="line">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">      <span class="comment">// 解析 replaced-method 属性</span></span><br><span class="line">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析构造函数参数</span></span><br><span class="line">      parseConstructorArgElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 property 子元素</span></span><br><span class="line">      parsePropertyElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 qualifier 子元素</span></span><br><span class="line">      parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">      bd.setResource(<span class="built_in">this</span>.readerContext.getResource());</span><br><span class="line">      bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bd;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">      error(<span class="string">&quot;Class that bean class [&quot;</span> + className + <span class="string">&quot;] depends on not found&quot;</span>, ele, err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      error(<span class="string">&quot;Unexpected failure during bean definition parsing&quot;</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="BeanDefinitionParserDelegate-parseBeanDefinitionAttributes"><a href="#BeanDefinitionParserDelegate-parseBeanDefinitionAttributes" class="headerlink" title="BeanDefinitionParserDelegate#parseBeanDefinitionAttributes"></a>BeanDefinitionParserDelegate#parseBeanDefinitionAttributes</h6><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionAttributes</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析bean标签的各种其他属性</span></span><br><span class="line"><span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionAttributes</span><span class="params">(Element ele, String beanName,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> BeanDefinition containingBean, AbstractBeanDefinition bd)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析 singleton 属性, 在 1.x 后废弃</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class="line">      error(<span class="string">&quot;Old 1.x &#x27;singleton&#x27; attribute in use - upgrade to &#x27;scope&#x27; declaration&quot;</span>, ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析 scope 属性</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class="line">      bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Take default from containing bean in case of an inner bean definition.</span></span><br><span class="line">      <span class="comment">// 如果是内部BeanDefinition，则从 containingBean 中获取 scope 的值。</span></span><br><span class="line">      bd.setScope(containingBean.getScope());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析 abstract 属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class="line">      bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解析 lazy-init 属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">lazyInit</span> <span class="operator">=</span> ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">if</span> (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">      lazyInit = <span class="built_in">this</span>.defaults.getLazyInit();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有设置或者设置成其他字符都会被设置为false</span></span><br><span class="line">   bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析 autowire 属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">autowire</span> <span class="operator">=</span> ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class="line">   bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析 depends-on 属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">dependsOn</span> <span class="operator">=</span> ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class="line">      bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析 autowire-candidate 属性</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">autowireCandidate</span> <span class="operator">=</span> ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class="line">   <span class="keyword">if</span> (isDefaultValue(autowireCandidate)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">candidatePattern</span> <span class="operator">=</span> <span class="built_in">this</span>.defaults.getAutowireCandidates();</span><br><span class="line">      <span class="keyword">if</span> (candidatePattern != <span class="literal">null</span>) &#123;</span><br><span class="line">         String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class="line">         bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析 primary 属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class="line">      bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析 init-method 属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">initMethodName</span> <span class="operator">=</span> ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class="line">      bd.setInitMethodName(initMethodName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.defaults.getInitMethod() != <span class="literal">null</span>) &#123;</span><br><span class="line">      bd.setInitMethodName(<span class="built_in">this</span>.defaults.getInitMethod());</span><br><span class="line">      bd.setEnforceInitMethod(<span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析 destroy-method 属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">destroyMethodName</span> <span class="operator">=</span> ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class="line">      bd.setDestroyMethodName(destroyMethodName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.defaults.getDestroyMethod() != <span class="literal">null</span>) &#123;</span><br><span class="line">      bd.setDestroyMethodName(<span class="built_in">this</span>.defaults.getDestroyMethod());</span><br><span class="line">      bd.setEnforceDestroyMethod(<span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析 factory-method 属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">      bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解析 factory-bean 属性</span></span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class="line">      bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="BeanDefinitionParserDelegate-parseMetaElements"><a href="#BeanDefinitionParserDelegate-parseMetaElements" class="headerlink" title="BeanDefinitionParserDelegate#parseMetaElements"></a>BeanDefinitionParserDelegate#parseMetaElements</h6><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseMetaElements</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析元数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMetaElements</span><span class="params">(Element ele, BeanMetadataAttributeAccessor attributeAccessor)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取当前节点的所有子节点</span></span><br><span class="line">   <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> ele.getChildNodes();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">      <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">         <span class="comment">// meta 节点</span></span><br><span class="line">         <span class="type">Element</span> <span class="variable">metaElement</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">         <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> metaElement.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">         <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> metaElement.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">         <span class="comment">// 使用 key/value 构造 beanMetadataAttribute</span></span><br><span class="line">         <span class="type">BeanMetadataAttribute</span> <span class="variable">attribute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanMetadataAttribute</span>(key, value);</span><br><span class="line">         attribute.setSource(extractSource(metaElement));</span><br><span class="line">         <span class="comment">// 记录信息</span></span><br><span class="line">         attributeAccessor.addMetadataAttribute(attribute);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DefaultBeanDefinitionDocumentReader-parseDefaultElement-1"><a href="#DefaultBeanDefinitionDocumentReader-parseDefaultElement-1" class="headerlink" title="DefaultBeanDefinitionDocumentReader#parseDefaultElement"></a>DefaultBeanDefinitionDocumentReader#parseDefaultElement</h2><p>解析自定义标签</p>
<blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseCustomElement(Element,  BeanDefinition)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取标签对应的命名空间</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">namespaceUri</span> <span class="operator">=</span> getNamespaceURI(ele);</span><br><span class="line">   <span class="keyword">if</span> (namespaceUri == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// XmlBeanDefinitionReader#registerBeanDefinitions 创建的 namespaceHandlerResolver</span></span><br><span class="line">   <span class="comment">// 根据命名空间找到对应的 NamespaceHandler (对应关系文件 spring.schemas)</span></span><br><span class="line">   <span class="comment">// 通过继承 NamespaceHandlerSupport 来定制 NamespaceHandler</span></span><br><span class="line">   <span class="type">NamespaceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 调用定制的 NamespaceHandler 进行解析</span></span><br><span class="line">   <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> <span class="title class_">ParserContext</span>(<span class="built_in">this</span>.readerContext, <span class="built_in">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NamespaceHandler-parse"><a href="#NamespaceHandler-parse" class="headerlink" title="NamespaceHandler#parse"></a>NamespaceHandler#parse</h3><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.xml.NamespaceHandlerSupport#parse</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取自定义组件名 对应的解析方法</span></span><br><span class="line">   <span class="type">BeanDefinitionParser</span> <span class="variable">parser</span> <span class="operator">=</span> findParserForElement(element, parserContext);</span><br><span class="line">   <span class="comment">// 调用ComponentScanBeanDefinitionParser实现类中的 parse方法</span></span><br><span class="line">   <span class="keyword">return</span> (parser != <span class="literal">null</span> ? parser.parse(element, parserContext) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NamespaceHandlerSupport-findParserForElement"><a href="#NamespaceHandlerSupport-findParserForElement" class="headerlink" title="NamespaceHandlerSupport#findParserForElement"></a>NamespaceHandlerSupport#findParserForElement</h4><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.xml.NamespaceHandlerSupport#findParserForElement</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从map中根据组件名称获取绑定的解析方法</span></span><br><span class="line"><span class="keyword">private</span> BeanDefinitionParser <span class="title function_">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取组件名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">localName</span> <span class="operator">=</span> parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    <span class="comment">// this.parsers 成员变量定义: Map&lt;String, BeanDefinitionParser&gt; parsers = new HashMap&lt;&gt;();</span></span><br><span class="line">    <span class="type">BeanDefinitionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="built_in">this</span>.parsers.get(localName);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="literal">null</span>) &#123;</span><br><span class="line">        parserContext.getReaderContext().fatal(</span><br><span class="line">            <span class="string">&quot;Cannot locate BeanDefinitionParser for element [&quot;</span> + localName + <span class="string">&quot;]&quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(3) beanFactory 的准备工作</title>
    <url>/2020/10/25/spring/Spring06/</url>
    <content><![CDATA[<h2 id="3-prepareBeanFactory"><a href="#3-prepareBeanFactory" class="headerlink" title="3. prepareBeanFactory"></a>3. prepareBeanFactory</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">   <span class="comment">// 告知内部的bean工厂，使用上下文的类加载器</span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">   <span class="comment">// 设置 bean 表达式语言解析器</span></span><br><span class="line">   <span class="comment">// 默认 StandardBeanExpressionResolver 成员变量 expressionParser 是 SpelExpressionParser (即 spring el表达式) 类型</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   <span class="comment">// 添加 beanFactory 默认的 PropertyEditorRegistrar，主要是对 bean 的属性等设置管理的一个工具类</span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">   <span class="comment">// 添加 Bean 后置处理器</span></span><br><span class="line">   <span class="comment">// 初始化bean之前处理 Aware 接口, EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware 和 ApplicationContextAware</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">   <span class="comment">// 设置要忽略自动装配的接口</span></span><br><span class="line">   <span class="comment">// 为什么此处要对这些接口进行忽略，</span></span><br><span class="line">   <span class="comment">// 原因：这些接口的实现是由容器通过set方法进行注入的，所以在使用 autowire 进行注入的时候需要将这些接口进行忽略</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">   <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">   <span class="comment">// 设置几个自动装配的特殊规则,当在进行ioc初始化的如果有多个实现，那么就使用指定的对象进行注入</span></span><br><span class="line">   <span class="comment">// 在 Spring 自动装配的时候如果一个接口有多个实现类，使用 registerResolvableDependency 指定接口的实例</span></span><br><span class="line">   <span class="comment">// 类似作用的有使用 @Primary</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">   <span class="comment">// 添加 Bean 后置处理器</span></span><br><span class="line">   <span class="comment">// 初始化 bean 之后处理事件监听器</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">   <span class="comment">// 增加对 AspectJ 的支持，在 java 中织入分为三种方式，分为编译器织入，类加载器织入，运行期织入，编译器织入是指在java编译器，采用特殊的编译器，将切面织入到java类中，</span></span><br><span class="line">   <span class="comment">// 而类加载期织入则指通过特殊的类加载器，在类字节码加载到JVM时，织入切面，运行期织入则是采用 cglib 和 jdk 进行切面的织入</span></span><br><span class="line">   <span class="comment">// Aspectj 提供了两种织入方式，第一种是通过特殊编译器，在编译器，将 Aspectj 语言编写的切面类织入到 java 类中，第二种是类加载期织入，就是下面的l oad time weaving</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register default environment beans.</span></span><br><span class="line">   <span class="comment">// 注册默认的系统环境 bean 到一级缓存中</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="comment">// 环境变量</span></span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="comment">// 系统属性</span></span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="comment">// 系统环境变量</span></span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ResourceEditorRegistrar</code></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(4) 容器钩子方法</title>
    <url>/2020/10/25/spring/Spring07/</url>
    <content><![CDATA[<h2 id="4-postProcessBeanFactory"><a href="#4-postProcessBeanFactory" class="headerlink" title="4. postProcessBeanFactory"></a>4. postProcessBeanFactory</h2><p>按照标准修改应用上下文的内部 bean 工厂初始化。</p>
<p>所有 bean definition 都将被加载，但没有 bean 将被实例化。</p>
<p>这允许注册特殊的某些 ApplicationContext 实现中的 BeanPostProcessors 等。</p>
<blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#postProcessBeanFactory</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 钩子方法由子类实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(5) 执行 BeanFactoryPostProcessor</title>
    <url>/2020/10/25/spring/Spring08/</url>
    <content><![CDATA[<h2 id="5-invokeBeanFactoryPostProcessors"><a href="#5-invokeBeanFactoryPostProcessors" class="headerlink" title="5. invokeBeanFactoryPostProcessors"></a>5. invokeBeanFactoryPostProcessors</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化并调用所有注册的BeanFactoryPostProcessor Bean，并遵循显式顺序（如果给定的话）。 一定在单例实例化之前被调用。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// 1. 拿到当前应用上下文 beanFactoryPostProcessors 变量中的值</span></span><br><span class="line">   <span class="comment">// 2. 实例化并调用所有已注册的BeanFactoryPostProcessor</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 默认情况下，通过 getBeanFactoryPostProcessors() 来获取已经注册的 BeanFactoryPostProcessor,</span></span><br><span class="line"><span class="comment">    * 但是默认是空的, 可以 AbstractApplicationContext#postProcessBeanFactory 方法中添加</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">   <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 检测LoadTimeWeaver并准备编织（如果在此期间发现）</span></span><br><span class="line"><span class="comment">    * 例如 通过ConfigurationClassPostProcessor注册的@Bean方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-1-PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors"><a href="#5-1-PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors" class="headerlink" title="5.1 PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors"></a>5.1 PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</h3><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">   <span class="comment">// 无论是什么情况，优先执行 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">   <span class="comment">// 将已经执行过的 BeanFactoryPostProcessor 存储在 processedBeans 中，防止重复执行</span></span><br><span class="line">   Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Spring 默认创建的是 DefaultListableBeanFactory, 且实现了BeanDefinitionRegistry接口，所以为true</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123; <span class="comment">// beanFactory是BeanDefinitionRegistry实例</span></span><br><span class="line">      <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 两个接口是不同的, BeanDefinitionRegistryPostProcessor 是BeanFactoryPostProcessor 的子集</span></span><br><span class="line"><span class="comment">            * BeanFactoryPostProcessor 主要针对的操作对象是 BeanFactory,</span></span><br><span class="line"><span class="comment">            * 而 BeanDefinitionRegistryPostProcessor 主要针对的操作对象是 BeanDefinition</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// 用于存放普通的 BeanFactoryPostProcessor</span></span><br><span class="line">      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">// 用于存放 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历所有的 beanFactoryPostProcessors, 将 BeanDefinitionRegistryPostProcessor 和普通 BeanFactoryPostProcessor 区分开</span></span><br><span class="line">      <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">         <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">            <span class="comment">// 如果是 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">            <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">registryProcessor</span> <span class="operator">=</span></span><br><span class="line">                  (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">            <span class="comment">// 直接执行 BeanDefinitionRegistryPostProcessor 接口的 postProcessBeanDefinitionRegistry 方法</span></span><br><span class="line">            registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">            <span class="comment">// 添加到 registryProcessors，用于后续执行postProcessBeanFactory方法</span></span><br><span class="line">            registryProcessors.add(registryProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果只是普通的BeanFactoryPostProcessor，添加到regularPostProcessors,</span></span><br><span class="line">            <span class="comment">// 用于后续执行postProcessBeanFactory方法</span></span><br><span class="line">            regularPostProcessors.add(postProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">      <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">      <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">      <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">      <span class="comment">// 用于保存本次要执行的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">      <span class="comment">// 找出所有实现 PriorityOrdered 的 BeanDefinitionRegistryPostProcessor 接口的 Bean 的 beanName</span></span><br><span class="line">      String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">         <span class="comment">// 检测是否实现了PriorityOrdered接口</span></span><br><span class="line">         <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            <span class="comment">// 获取名字对应的 bean 实例，添加到 currentRegistryProcessors 中</span></span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">            <span class="comment">// 将要被执行的 BeanFactoryPostProcessor 名称添加到 processedBeans，避免后续重复执行</span></span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 按照优先级进行排序操作</span></span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      <span class="comment">// 添加到 registryProcessors 中，用于最后执行 postProcessBeanFactory 方法</span></span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      <span class="comment">// 遍历 currentRegistryProcessors，执行 postProcessBeanDefinitionRegistry 方法</span></span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      <span class="comment">// 执行完毕之后，清空 currentRegistryProcessors</span></span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">      <span class="comment">// 找出所有实现 Ordered 的 BeanDefinitionRegistryPostProcessor 接口的 Bean 的 beanName</span></span><br><span class="line">      <span class="comment">// 此处需要重复查找的原因在于上面的执行过程中可能会新增其他的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">         <span class="comment">// 检测是否实现了 Ordered 接口，并且还未执行过</span></span><br><span class="line">         <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            <span class="comment">// 获取名字对应的 bean 实例，添加到 currentRegistryProcessors中</span></span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">            <span class="comment">// 将要被执行的 BeanFactoryPostProcessor 名称添加到 processedBeans，避免后续重复执行</span></span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 按照优先级进行排序操作</span></span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      <span class="comment">// 添加到 registryProcessors 中，用于最后执行 postProcessBeanFactory 方法</span></span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      <span class="comment">// 遍历 currentRegistryProcessors，执行 postProcessBeanDefinitionRegistry 方法</span></span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      <span class="comment">// 执行完毕之后，清空 currentRegistryProcessors</span></span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">      <span class="comment">// 调用所有剩下的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">         reiterate = <span class="literal">false</span>;</span><br><span class="line">         <span class="comment">// 找出所有实现 BeanDefinitionRegistryPostProcessor 接口的类</span></span><br><span class="line">         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">         <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123; <span class="comment">// 跳过已经执行过的</span></span><br><span class="line">               <span class="comment">// 获取名字对应的 bean 实例，添加到 currentRegistryProcessors中</span></span><br><span class="line">               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">               <span class="comment">// 将要被执行的 BeanFactoryPostProcessor 名称添加到 processedBeans，避免后续重复执行</span></span><br><span class="line">               processedBeans.add(ppName);</span><br><span class="line">               reiterate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 按照优先级进行排序操作</span></span><br><span class="line">         sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">         <span class="comment">// 添加到 registryProcessors 中，用于最后执行 postProcessBeanFactory 方法</span></span><br><span class="line">         registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">         <span class="comment">// 遍历 currentRegistryProcessors，执行 postProcessBeanDefinitionRegistry 方法</span></span><br><span class="line">         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">         <span class="comment">// 执行完毕之后，清空 currentRegistryProcessors</span></span><br><span class="line">         currentRegistryProcessors.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">      <span class="comment">// 调用所有 BeanDefinitionRegistryPostProcessor#postProcessBeanFactory 方法</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">      <span class="comment">// 最后，调用入参 beanFactoryPostProcessors 中的普通 BeanFactoryPostProcessor#postProcessBeanFactory 方法</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">      <span class="comment">// 如果 beanFactory 不归属于 BeanDefinitionRegistry 类型，那么直接执行 postProcessBeanFactory 方法</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 到这里为止，入参 beanFactoryPostProcessors 和容器中的所有 BeanDefinitionRegistryPostProcessor 已经全部处理完毕.</span></span><br><span class="line">   <span class="comment">// 下面开始处理容器中所有的 BeanFactoryPostProcessor</span></span><br><span class="line">   <span class="comment">// 可能会包含一些实现类，只实现了 BeanFactoryPostProcessor，并没有实现 BeanDefinitionRegistryPostProcessor 接口</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">   <span class="comment">// 不要在这里初始化 FactoryBeans：我们需要保留所有未初始化的常规bean，以使bean工厂后处理器对其应用！</span></span><br><span class="line">   <span class="comment">// 找到所有实现 BeanFactoryPostProcessor 接口的类</span></span><br><span class="line">   String[] postProcessorNames =</span><br><span class="line">         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   <span class="comment">// 用于存放实现了 PriorityOrdered 接口的 BeanFactoryPostProcessor</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 用于存放实现了 Ordered 接口的 BeanFactoryPostProcessor 的 beanName</span></span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 用于存放普通 BeanFactoryPostProcessor 的 beanName</span></span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 遍历 postProcessorNames, 将 BeanFactoryPostProcessor 按实现PriorityOrdered接口、实现Ordered接口、普通三种区分开</span></span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">         <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">         <span class="comment">// 跳过已经执行过的 BeanFactoryPostProcessor</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">         <span class="comment">// 添加实现了 PriorityOrdered 接口的 BeanFactoryPostProcessor 到priorityOrderedPostProcessors</span></span><br><span class="line">         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">         <span class="comment">// 添加实现了 Ordered 接口的 BeanFactoryPostProcessor 的 beanName 到 orderedPostProcessorNames</span></span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 添加剩下的普通 BeanFactoryPostProcessor 的 beanName 到 nonOrderedPostProcessorNames</span></span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 调用实现了 PriorityOrdered 的 BeanFactoryPostProcessors</span></span><br><span class="line">   <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">   <span class="comment">// 对实现了 PriorityOrdered 接口的 BeanFactoryPostProcessor 进行排序</span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">   <span class="comment">// 遍历实现了 PriorityOrdered 接口的 BeanFactoryPostProcessor，执行 postProcessBeanFactory 方法</span></span><br><span class="line">   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">   <span class="comment">// 2. 调用实现了 Ordered 的 BeanFactoryPostProcessors</span></span><br><span class="line">   <span class="comment">// 创建存放实现了 Ordered 接口的 BeanFactoryPostProcessor 集合</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="comment">// 遍历存放实现了 Ordered 接口的 BeanFactoryPostProcessor 名字的集合</span></span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); <span class="comment">// 获取实例对象</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 对实现了 Ordered 接口的 BeanFactoryPostProcessor 进行排序操作</span></span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   <span class="comment">// 遍历实现了 Ordered 接口的 BeanFactoryPostProcessor，执行 postProcessBeanFactory 方法</span></span><br><span class="line">   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">   <span class="comment">// 3. 调用普通 BeanFactoryPostProcessors</span></span><br><span class="line">   <span class="comment">// 创建存放普通的BeanFactoryPostProcessor的集合</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="comment">// 遍历存放实现了普通 BeanFactoryPostProcessor 名字的集合</span></span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">      <span class="comment">// 将普通的 BeanFactoryPostProcessor 添加到集合中</span></span><br><span class="line">      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); <span class="comment">// 获取实例对象</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 遍历普通的 BeanFactoryPostProcessor，执行 postProcessBeanFactory 方法</span></span><br><span class="line">   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); <span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">   <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">   <span class="comment">// 清除元数据缓存（mergeBeanDefinitions、allBeanNamesByType、singletonBeanNameByType）</span></span><br><span class="line">   <span class="comment">// 因为后处理器可能已经修改了原始元数据，例如 替换值中的占位符...</span></span><br><span class="line">   beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-BeanFactoryPostProcessor-常用接口和实现类"><a href="#5-2-BeanFactoryPostProcessor-常用接口和实现类" class="headerlink" title="5.2 BeanFactoryPostProcessor 常用接口和实现类"></a>5.2 BeanFactoryPostProcessor 常用接口和实现类</h3><h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h4><p>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry 可以动态增删改查 BeanDefinition</p>
<h4 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h4><p><code>ConfigurationClassPostProcessor</code> 实现 <code>BeanDefinitionRegistryPostProcessor</code> 接口</p>
<p><img src="/images/20201025/img-spring08-1.png" alt="img"></p>
<blockquote>
<p><strong>定位</strong>:  ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定位、加载、解析、注册相关注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Derive further bean definitions from the configuration classes in the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">   <span class="comment">// 根据对应的 registry 对象生成 hashcode 值，此对象只会操作一次，如果之前处理过则抛出异常</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">registryId</span> <span class="operator">=</span> System.identityHashCode(registry);</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将马上要进行处理的 registry 对象的 id 值放到已经处理的集合对象中</span></span><br><span class="line">   <span class="built_in">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理配置类的 bean 定义信息</span></span><br><span class="line">   processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-1-ConfigurationClassPostProcessor-postProcessBeanFactory"><a href="#5-2-1-ConfigurationClassPostProcessor-postProcessBeanFactory" class="headerlink" title="5.2.1 ConfigurationClassPostProcessor#postProcessBeanFactory"></a>5.2.1 ConfigurationClassPostProcessor#postProcessBeanFactory</h4><blockquote>
<p><strong>定位</strong>:  ConfigurationClassPostProcessor#postProcessBeanFactory </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加 CGLIB 增强处理及 ImportAwareBeanPostProcessor 后置处理类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Prepare the Configuration classes for servicing bean requests at runtime</span></span><br><span class="line"><span class="comment"> * by replacing them with CGLIB-enhanced subclasses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">factoryId</span> <span class="operator">=</span> System.identityHashCode(beanFactory);</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">      <span class="comment">// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span></span><br><span class="line">      <span class="comment">// Simply call processConfigurationClasses lazily at this point then.</span></span><br><span class="line">      <span class="comment">// BeanDefinitionRegistryPostProcessor 埋点不支持, 此时调用 processConfigurationClasses 处理配置类的 bean 定义信息</span></span><br><span class="line">      processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 对添加 @Configuration注解的类, 生成cglib代理</span></span><br><span class="line">   enhanceConfigurationClasses(beanFactory);</span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ImportAwareBeanPostProcessor</span>(beanFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-1-2-ConfigurationClassPostProcessor-processConfigBeanDefinitions"><a href="#5-2-1-2-ConfigurationClassPostProcessor-processConfigBeanDefinitions" class="headerlink" title="5.2.1.2 ConfigurationClassPostProcessor.processConfigBeanDefinitions"></a>5.2.1.2 ConfigurationClassPostProcessor.processConfigBeanDefinitions</h5><blockquote>
<p><strong>定位</strong>:  ConfigurationClassPostProcessor#processConfigBeanDefinitions </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建和验证一个类是否被 <span class="doctag">@Configuration</span> 修饰，并做相关的解析工作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Build and validate a configuration model based on the registry of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration&#125; classes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">   <span class="comment">// 创建存放 BeanDefinitionHolder 的对象集合</span></span><br><span class="line">   List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 当前 registry 就是 DefaultListableBeanFactory，获取所有已经注册的 BeanDefinition 的 beanName</span></span><br><span class="line">   String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历所有要处理的 beanDefinition 的名称, 筛选对应的 beanDefinition（被注解修饰的）</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">      <span class="comment">// 获取指定名称的 BeanDefinition 对象</span></span><br><span class="line">      <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">      <span class="comment">// 如果 beanDefinition 中的 configurationClass 属性不等于空，那么意味着已经处理过，输出日志信息</span></span><br><span class="line">      <span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断当前 BeanDefinition 是否是一个配置类，并为 BeanDefinition 设置属性为 lite 或者 full，此处设置属性值是为了后续进行调用</span></span><br><span class="line">      <span class="comment">// 如果 Configuration 配置 proxyBeanMethods 代理为 true 则为 full</span></span><br><span class="line">      <span class="comment">// 如果加了 @Bean、@Component、@ComponentScan、@Import、@ImportResource 注解，则设置为 lite</span></span><br><span class="line">      <span class="comment">// 如果配置类上被 @Order 注解标注，则设置 BeanDefinition 的 order 属性值</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">         <span class="comment">// 添加到对应的集合对象中</span></span><br><span class="line">         configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">   <span class="comment">// 如果没有发现任何配置类，则直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line">   <span class="comment">// 如果适用，则按照先前确定的 @Order 的值排序</span></span><br><span class="line">   configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">      <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">      <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">   <span class="comment">// 判断当前类型是否是 SingletonBeanRegistry 类型</span></span><br><span class="line">   <span class="type">SingletonBeanRegistry</span> <span class="variable">sbr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">      <span class="comment">// 类型的强制转换</span></span><br><span class="line">      sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">      <span class="comment">// 判断是否有自定义的 beanName 生成器</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">         <span class="comment">// 获取自定义的 beanName 生成器</span></span><br><span class="line">         <span class="type">BeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> (BeanNameGenerator) sbr.getSingleton(</span><br><span class="line">               AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">         <span class="comment">// 如果有自定义的命名生成策略</span></span><br><span class="line">         <span class="keyword">if</span> (generator != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置组件扫描的 beanName 生成策略</span></span><br><span class="line">            <span class="built_in">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">            <span class="comment">// 设置 import bean name 生成策略</span></span><br><span class="line">            <span class="built_in">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果环境对象等于空，那么就重新创建新的环境对象</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.environment == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.environment = <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Parse each @Configuration class</span></span><br><span class="line">   <span class="comment">// 实例化 ConfigurationClassParser 类，并初始化相关的参数，完成配置类的解析工作</span></span><br><span class="line">   <span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(</span><br><span class="line">         <span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,</span><br><span class="line">         <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建两个集合对象</span></span><br><span class="line">   <span class="comment">// 存放相关的 BeanDefinitionHolder 对象</span></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line">   <span class="comment">// 存放扫描包下的所有 bean</span></span><br><span class="line">   Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 解析带有 @Controller、@Import、@ImportResource、@ComponentScan、@ComponentScans、@Bean 的 BeanDefinition</span></span><br><span class="line">      parser.parse(candidates);</span><br><span class="line">      <span class="comment">// 将解析完的 Configuration配置类进行校验，</span></span><br><span class="line">      <span class="comment">// 1、配置类不能是 final;</span></span><br><span class="line">      <span class="comment">// 2、@Bean 修饰的方法必须可以重写以支持 CGLIB</span></span><br><span class="line">      parser.validate();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取所有的 bean,包括扫描的 bean 对象，@Import 导入的 bean 对象</span></span><br><span class="line">      Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">      <span class="comment">// 清除掉已经解析处理过的配置类</span></span><br><span class="line">      configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">      <span class="comment">// 判断读取器是否为空，如果为空的话，就创建完全填充好的 ConfigurationClass 实例的读取器</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(</span><br><span class="line">               registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment,</span><br><span class="line">               <span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 核心方法，将完全填充好的 ConfigurationClass 实例转化为 BeanDefinition 注册入 IOC 容器</span></span><br><span class="line">      <span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">      <span class="comment">// 添加到已经处理的集合中</span></span><br><span class="line">      alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">      candidates.clear();</span><br><span class="line">      <span class="comment">// 这里判断 registry.getBeanDefinitionCount() &gt; candidateNames.length 的目的是为了知道 reader.loadBeanDefinitions(configClasses) 这一步有没有向 BeanDefinitionMap 中添加新的 BeanDefinition</span></span><br><span class="line">      <span class="comment">// 实际上就是看配置类(例如 AppConfig 类会向 BeanDefinitionMap 中添加 bean)</span></span><br><span class="line">      <span class="comment">// 如果有，registry.getBeanDefinitionCount() 就会大于 candidateNames.length</span></span><br><span class="line">      <span class="comment">// 这样就需要再次遍历新加入的 BeanDefinition，并判断这些 bean 是否已经被解析过了，如果未解析，需要重新进行解析</span></span><br><span class="line">      <span class="comment">// 这里的 AppConfig 类向容器中添加的 bean，实际上在 parser.parse() 这一步已经全部被解析了</span></span><br><span class="line">      <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">         String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">         Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">         Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">         <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 如果有未解析的类，则将其添加到 candidates 中，这样 candidates 不为空，就会进入到下一次的 while 的循环中</span></span><br><span class="line">         <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">               <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> registry.getBeanDefinition(candidateName);</span><br><span class="line">               <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="built_in">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                     !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                  candidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, candidateName));</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         candidateNames = newCandidateNames;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">   <span class="keyword">if</span> (sbr != <span class="literal">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">      <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">      <span class="comment">// for a shared cache since it&#x27;ll be cleared by the ApplicationContext.</span></span><br><span class="line">      ((CachingMetadataReaderFactory) <span class="built_in">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="5-2-1-1-ConfigurationClassParser-parse"><a href="#5-2-1-1-ConfigurationClassParser-parse" class="headerlink" title="5.2.1.1 ConfigurationClassParser#parse"></a>5.2.1.1 ConfigurationClassParser#parse</h6><blockquote>
<p><strong>定位</strong>:  ConfigurationClassParser#parse (Set<BeanDefinitionHolder>)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">   <span class="comment">// 循环遍历 configCandidates</span></span><br><span class="line">   <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">      <span class="comment">// 获取 BeanDefinition</span></span><br><span class="line">      <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">      <span class="comment">// 根据 BeanDefinition 类型的不同，调用 parse 不同的重载方法，实际上最终都是调用 processConfigurationClass() 方法</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 注解类型</span></span><br><span class="line">         <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 有 class 对象的</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">               <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 执行找到的 DeferredImportSelector</span></span><br><span class="line">   <span class="comment">// DeferredImportSelector 是 ImportSelector 的一个子类</span></span><br><span class="line">   <span class="comment">// ImportSelector 被设计成和 @Import 注解同样的效果，但是实现了 ImportSelector 的类可以条件性的决定导入某些配置</span></span><br><span class="line">   <span class="comment">// DeferredImportSelector 的设计都是在所有其他的配置类被处理后才进行处理</span></span><br><span class="line">   <span class="built_in">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定位</strong>:  ConfigurationClassParser#processConfigurationClass</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 第一次进入的时候，configurationClass 的 size 为 0，existingClass 肯定为 null，在此处处理 configuration 重复 import</span></span><br><span class="line">   <span class="comment">// 如果同一个配置类被处理两次，两次都属于被 import 的则合并导入类，返回，如果配置类不是被导入的，则移除旧的使用新的配置类</span></span><br><span class="line">   <span class="type">ConfigurationClass</span> <span class="variable">existingClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(configClass);</span><br><span class="line">   <span class="keyword">if</span> (existingClass != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">            <span class="comment">// 如果要处理的配置类 configClass 在已经分析处理的配置类记录中已存在，合并两者的 importBy 属性</span></span><br><span class="line">            existingClass.mergeImportedBy(configClass);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">         <span class="comment">// Let&#x27;s remove the old one and go with the new one.</span></span><br><span class="line">         <span class="built_in">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">         <span class="built_in">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理配置类，由于配置类可能存在父类(若父类的全类名是以java开头的，则除外)，所有需要将 configClass 变成 sourceClass 去解析，然后返回 sourceClass 的父类。</span></span><br><span class="line">   <span class="comment">// 如果此时父类为空，则不会进行 while 循环去解析，如果父类不为空，则会循环的去解析父类</span></span><br><span class="line">   <span class="comment">// SourceClass 的意义：简单的包装类，目的是为了以统一的方式去处理带有注解的类，不管这些类是如何加载的</span></span><br><span class="line">   <span class="comment">// 如果无法理解，可以把它当做一个黑盒，不会影响阅读 spring 源码的主流程</span></span><br><span class="line">   <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> asSourceClass(configClass);</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将解析的配置类存储起来，这样回到 parse 方法时，能取到值</span></span><br><span class="line">   <span class="built_in">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定位</strong>:  ConfigurationClassParser#doProcessConfigurationClass</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// @Configuration 继承了 @Component</span></span><br><span class="line">   <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">      <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">      processMemberClasses(configClass, sourceClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">   <span class="comment">// 如果配置类上加了 @PropertySource 注解，那么就解析加载 properties 文件，并将属性添加到 spring 上下文中</span></span><br><span class="line">   <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">         sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">         org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">         processPropertySource(propertySource);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">               <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">   <span class="comment">// 处理 @ComponentScan 或者 @ComponentScans 注解，并将扫描包下的所有 bean 转换成填充后的 ConfigurationClass</span></span><br><span class="line">   <span class="comment">// 此处就是将自定义的 bean 加载到 IOC 容器，因为扫描到的类可能也添加了 @ComponentScan 和 @ComponentScans 注解，因此需要进行递归解析</span></span><br><span class="line">   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">   <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">         !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">         <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">         <span class="comment">// 解析 @ComponentScan 和 @ComponentScans 配置的扫描的包所包含的类</span></span><br><span class="line">         <span class="comment">// 比如 basePackages = org.devin, 那么在这一步会扫描出这个包及子包下的 class，然后将其解析成 BeanDefinition</span></span><br><span class="line">         <span class="comment">// (BeanDefinition 可以理解为等价于 BeanDefinitionHolder)</span></span><br><span class="line">         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">               <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">         <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">         <span class="comment">// 通过上一步扫描包 org.devin，有可能扫描出来的bean中可能也添加了 ComponentScan 或者 ComponentScans 注解.</span></span><br><span class="line">         <span class="comment">//所以这里需要循环遍历一次，进行递归(parse)，继续解析，直到解析出的类上没有 ComponentScan 和 ComponentScans</span></span><br><span class="line">         <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">            <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">               bdCand = holder.getBeanDefinition();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否是一个配置类，并设置 full 或 lite 属性</span></span><br><span class="line">            <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">               <span class="comment">// 通过递归方法进行解析</span></span><br><span class="line">               parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @Import annotations</span></span><br><span class="line">   processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">   <span class="comment">// 处理 @ImportResource 注解，导入 spring 的配置文件</span></span><br><span class="line">   <span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">   <span class="keyword">if</span> (importResource != <span class="literal">null</span>) &#123;</span><br><span class="line">      String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">      Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">         configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process individual @Bean methods</span></span><br><span class="line">   <span class="comment">// 处理加了 @Bean 注解的方法，将 @Bean 方法转化为 BeanMethod 对象，保存再集合中</span></span><br><span class="line">   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">   <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">      configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process default methods on interfaces</span></span><br><span class="line">   <span class="comment">// 处理接口的默认方法实现，从 jdk8 开始，接口中的方法可以有自己的默认实现，因此如果这个接口的方法加了 @Bean 注解，也需要被解析</span></span><br><span class="line">   processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process superclass, if any</span></span><br><span class="line">   <span class="comment">// 解析父类，如果被解析的配置类继承了某个类，那么配置类的父类也会被进行解析</span></span><br><span class="line">   <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">      <span class="keyword">if</span> (superclass != <span class="literal">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">            !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">         <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">         <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定位</strong>:  ConfigurationClassParser#processImports</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">      Collection&lt;SourceClass&gt; importCandidates, <span class="type">boolean</span> checkForCircularImports)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果使用 @Import 注解修饰的类集合为空，那么直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 添加到栈中，用于处理循环引入的问题</span></span><br><span class="line">      <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 遍历每一个 @Import 注解的类</span></span><br><span class="line">         <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">            <span class="comment">// 检验配置类 Import 引入的类是否是 ImportSelector 子类</span></span><br><span class="line">            <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">               <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">               <span class="comment">// 候选类是一个导入选择器-&gt;委托来确定是否进行导入</span></span><br><span class="line">               Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">               <span class="comment">// 通过反射生成一个 ImportSelect 对象</span></span><br><span class="line">               <span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,</span><br><span class="line">                     <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">               <span class="comment">// 判断引用选择器是否是 DeferredImportSelector 接口的实例</span></span><br><span class="line">               <span class="comment">// 如果是则应用选择器将会在所有的配置类都加载完毕后加载</span></span><br><span class="line">               <span class="keyword">if</span> (selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">                  <span class="comment">// 将选择器添加到 deferredImportSelectorHandler 实例中，预留到所有的配置类加载完成后统一处理自动化配置类</span></span><br><span class="line">                  <span class="built_in">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 获取引入的类，然后使用递归方式将这些类中同样添加了 @Import 注解引用的类</span></span><br><span class="line">                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">                  Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">                  processImports(configClass, currentSourceClass, importSourceClasses, <span class="literal">false</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是实现了 ImportBeanDefinitionRegistrar 接口的 bd</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">               <span class="comment">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">               <span class="comment">// delegate to it to register additional bean definitions</span></span><br><span class="line">               <span class="comment">// 候选类是 ImportBeanDefinitionRegistrar  -&gt; 委托给当前注册器注册其他 bean</span></span><br><span class="line">               Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">               <span class="type">ImportBeanDefinitionRegistrar</span> <span class="variable">registrar</span> <span class="operator">=</span></span><br><span class="line">                     ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,</span><br><span class="line">                           <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 放到当前 configClass 的 importBeanDefinitionRegistrars 中</span></span><br><span class="line"><span class="comment">                * 在 ConfigurationClassPostProcessor 处理 configClass 时会随之一起处理</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">               <span class="comment">// process it as an @Configuration class</span></span><br><span class="line">               <span class="comment">// 候选类既不是 ImportSelector 也不是 ImportBeanDefinitionRegistrar --&gt;将其作为 @Configuration 配置类处理</span></span><br><span class="line">               <span class="built_in">this</span>.importStack.registerImport(</span><br><span class="line">                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">               processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">               <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">               configClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2-2-ConfigurationClassPostProcessor-postProcessBeanDefinitionRegistry"><a href="#5-2-2-ConfigurationClassPostProcessor-postProcessBeanDefinitionRegistry" class="headerlink" title="5.2.2 ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry"></a>5.2.2 ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry</h4><blockquote>
<p><strong>定位</strong>:  ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定位、加载、解析、注册相关注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Derive further bean definitions from the configuration classes in the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">   <span class="comment">// 根据对应的 registry 对象生成 hashcode 值，此对象只会操作一次，如果之前处理过则抛出异常</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">registryId</span> <span class="operator">=</span> System.identityHashCode(registry);</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将马上要进行处理的 registry 对象的 id 值放到已经处理的集合对象中</span></span><br><span class="line">   <span class="built_in">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理配置类的 bean 定义信息</span></span><br><span class="line">   processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(6) 注册 BeanPostProcessor</title>
    <url>/2020/10/25/spring/Spring09/</url>
    <content><![CDATA[<h2 id="6-registerBeanPostProcessors"><a href="#6-registerBeanPostProcessors" class="headerlink" title="6. registerBeanPostProcessors"></a>6. registerBeanPostProcessors</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#registerBeanPostProcessors</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化并注册所有BeanPostProcessor Bean，并遵守显式顺序（如果给定的话）。必须在应用程序Bean的任何实例化之前调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-1-PostProcessorRegistrationDelegate-registerBeanPostProcessors"><a href="#6-1-PostProcessorRegistrationDelegate-registerBeanPostProcessors" class="headerlink" title="6.1 PostProcessorRegistrationDelegate#registerBeanPostProcessors"></a>6.1 PostProcessorRegistrationDelegate#registerBeanPostProcessors</h3><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(ConfigurableListableBeanFactory, AbstractApplicationContext)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 找出所有实现了 BeanPostProcessor 接口的类的名称</span></span><br><span class="line">   String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">   <span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">   <span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">   <span class="comment">// 预计 BeanPostProcessor实现类 目标个数</span></span><br><span class="line">   <span class="comment">// 此处为什么要+1呢？ 原因: 在此方法的最后会添加一个 BeanPostProcessorChecker 的类</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">beanProcessorTargetCount</span> <span class="operator">=</span> beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">   <span class="comment">// 添加BeanPostProcessorChecker(主要用于记录信息)到beanFactory中</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   <span class="comment">// 存放实现了 PriorityOrdered 接口的 BeanPostProcessor 集合</span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 存放 Spring 内部实现了 BeanPostProcessor 的实例</span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 存放实现了 Ordered 接口的 BeanPostProcessor 的 beanName 集合</span></span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 存放普通(未实现排序接口)的 BeanPostProcessor 实例</span></span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="comment">// 如果 ppName 对应的 BeanPostProcessor 实例实现了 PriorityOrdered 接口，</span></span><br><span class="line">      <span class="comment">// 则获取到 ppName 对应的 BeanPostProcessor 的实例添加到 priorityOrderedPostProcessors 中</span></span><br><span class="line">      <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">         <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">         priorityOrderedPostProcessors.add(pp);</span><br><span class="line">         <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            <span class="comment">// Spring内部实现了BeanPostProcessor的实例</span></span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果 ppName 对应的 BeanPostProcessor 实例没有实现 PriorityOrdered 接口，但是实现了 Ordered 接口，</span></span><br><span class="line">      <span class="comment">// 那么则将 ppName 对应的 bean 实例添加到 orderedPostProcessorNames 中</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 将ppName添加到nonOrderedPostProcessorNames中</span></span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">   <span class="comment">// 1. 注册实现了 PriorityOrdered 接口的 BeanFactoryPostProcessors 实例对象</span></span><br><span class="line">   <span class="comment">// 对实现了 PriorityOrdered 接口的 BeanPostProcessor 实例集合进行排序操作</span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">   <span class="comment">// 注册实现了 PriorityOrdered 接口的 BeanPostProcessor 实例对象添加到 beanFactory 中</span></span><br><span class="line">   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">   <span class="comment">// 2. 注册实现 Ordered 的 BeanFactoryPostProcessors 实例对象</span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">      <span class="comment">// 根据 ppName 找到对应的 BeanPostProcessor 实例对象</span></span><br><span class="line">      <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">      <span class="comment">// 将实现了 Ordered 接口的 BeanPostProcessor 添加到 orderedPostProcessors 集合中</span></span><br><span class="line">      orderedPostProcessors.add(pp);</span><br><span class="line">      <span class="comment">// 如果 ppName 对应的 BeanPostProcessor 实例也实现了 MergedBeanDefinitionPostProcessor 接口，</span></span><br><span class="line">      <span class="comment">// 那么则将 ppName 对应的 bean 实例添加到 internalPostProcessors 中</span></span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">         <span class="comment">// Spring内部实现了 BeanPostProcessor 的实例</span></span><br><span class="line">         internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 对实现了 Ordered 接口的 BeanPostProcessor 实例集合进行排序操作</span></span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   <span class="comment">// 注册实现了 Ordered 接口的 BeanPostProcessor 实例对象添加到 beanFactory 中</span></span><br><span class="line">   registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">   <span class="comment">// 3. 注册普通(没有实现排序接口)的 BeanFactoryPostProcessors 实例对象</span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">      <span class="comment">// 根据 ppName 获取对应的 BeanPostProcessor 实例对象</span></span><br><span class="line">      <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">      <span class="comment">// 将普通的 BeanPostProcessor 添加到 nonOrderedPostProcessors 集合中</span></span><br><span class="line">      nonOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="comment">// 如果 ppName 对应的 BeanPostProcessor 实例也实现了 MergedBeanDefinitionPostProcessor 接口，</span></span><br><span class="line">      <span class="comment">// 那么则将 ppName 对应的 bean 实例添加到 internalPostProcessors 中</span></span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">         <span class="comment">// Spring 内部实现了 BeanPostProcessor 的实例</span></span><br><span class="line">         internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 注册普通的 BeanPostProcessor 实例添加到 beanFactory 中</span></span><br><span class="line">   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);  <span class="comment">// 注册</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">   <span class="comment">// 4. 注册所有 Spring 内部的 BeanPostProcessors 实例(实现了MergedBeanDefinitionPostProcessor接口)</span></span><br><span class="line">   sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">   <span class="comment">// Spring 内部的 BeanPostProcessors 实例(实现了 MergedBeanDefinitionPostProcessor 接口)</span></span><br><span class="line">   registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">   <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">   <span class="comment">// 最后，再置换一个新的ApplicationListenerDetector.  ApplicationListenerDetector 已重写 equals 方法.</span></span><br><span class="line">   <span class="comment">// 置换的原因是因为旧bean的属性singletonNames中已经存在有bdName了。</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(7) 初始化消息资源</title>
    <url>/2020/10/25/spring/Spring10/</url>
    <content><![CDATA[<h2 id="7-initMessageSource"><a href="#7-initMessageSource" class="headerlink" title="7.initMessageSource"></a>7.initMessageSource</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#initMessageSource</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">   <span class="comment">// 判断beanFactory中是否有名字为messageSource的bean (即使beanFactory的祖先beanFactory包含也获取不到)</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="comment">// 如果有，从beanFactory中获取</span></span><br><span class="line">      <span class="built_in">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">      <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">      <span class="comment">// 当父类 beanFactory 不为空，并且这个 bean 对象是 HierarchicalMessageSource 类型</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">         <span class="comment">// 类型强制转换，转换为 HierarchicalMessageSource 的类型</span></span><br><span class="line">         <span class="type">HierarchicalMessageSource</span> <span class="variable">hms</span> <span class="operator">=</span> (HierarchicalMessageSource) <span class="built_in">this</span>.messageSource;</span><br><span class="line">         <span class="comment">// 判断父类的 messageSource 是否为空，如果等于空，则设置父类的 messageSource</span></span><br><span class="line">         <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">            <span class="comment">// registered already.</span></span><br><span class="line">            hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">      <span class="comment">// 如果没有, 新建 DelegatingMessageSource 类作为 messageSource 的 bean</span></span><br><span class="line">      <span class="type">DelegatingMessageSource</span> <span class="variable">dms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingMessageSource</span>();</span><br><span class="line">      <span class="comment">// 给这个DelegatingMessageSource添加父类消息源</span></span><br><span class="line">      dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      <span class="built_in">this</span>.messageSource = dms;</span><br><span class="line">      <span class="comment">// 将这个messageSource实例注册到Bean工厂中</span></span><br><span class="line">      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="built_in">this</span>.messageSource);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(8-10) 初始化和注册广播器</title>
    <url>/2020/10/25/spring/Spring11/</url>
    <content><![CDATA[<h2 id="8-initApplicationEventMulticaster"><a href="#8-initApplicationEventMulticaster" class="headerlink" title="8.initApplicationEventMulticaster"></a>8.initApplicationEventMulticaster</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#initApplicationEventMulticaster</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化MessageSource。 如果在此上下文中未定义，则使用SimpleApplicationEventMulticaster。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">   <span class="comment">// 判断beanFactory中是否有名字为applicationEventMulticaster的bean (即使beanFactory的祖先beanFactory包含也获取不到)</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="comment">// 如果有，从beanFactory中获取</span></span><br><span class="line">      <span class="built_in">this</span>.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果没有，新建 SimpleApplicationEventMulticaster 类作为 applicationEventMulticaster 的 Bean;</span></span><br><span class="line">      <span class="built_in">this</span>.applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="built_in">this</span>.applicationEventMulticaster);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">               <span class="string">&quot;[&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-onRefresh"><a href="#9-onRefresh" class="headerlink" title="9.onRefresh"></a>9.onRefresh</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#onRefresh</p>
</blockquote>
<p>钩子方法, 由子类实现</p>
<h2 id="10-initApplicationEventMulticaster"><a href="#10-initApplicationEventMulticaster" class="headerlink" title="10.initApplicationEventMulticaster"></a>10.initApplicationEventMulticaster</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#initApplicationEventMulticaster</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">   <span class="comment">// 遍历应用程序中存在的监听器集合，并将对应的监听器添加到监听器的多路广播器中</span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">   <span class="comment">// 从 BeanFactory 中获取所有实现了 ApplicationListener 接口的 beanName，</span></span><br><span class="line">   <span class="comment">// 并且添加到 applicationEventMulticaster 的 listenerBean 中</span></span><br><span class="line">   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">   <span class="comment">// 有些事件可能要提前发出，将需要提前发出的事件发出并置空。同时将他们添加到 applicationEventMulticaster的multicastEvent中</span></span><br><span class="line">   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line">   <span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (earlyEventsToProcess != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">         getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(11) 实例化对象</title>
    <url>/2020/10/25/spring/Spring12/</url>
    <content><![CDATA[<h2 id="11-finishBeanFactoryInitialization"><a href="#11-finishBeanFactoryInitialization" class="headerlink" title="11.finishBeanFactoryInitialization"></a>11.finishBeanFactoryInitialization</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成此上下文的beanFactory的初始化，初始化所有剩余的单例对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">   <span class="comment">// beanFactory 初始化 conversionService (类型转换器)</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="comment">// 如果没有embedded的后置处理器, 则注册一个默认的embedded后置处理器。 主要用于解析注解属性值</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">   <span class="comment">// 尽早初始化LoadTimeWeaverAware Bean，以便尽早注册其转换器。</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   <span class="comment">// 清空临时ClassLoader (禁止使用临时类加载器进行类型匹配)</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">   <span class="comment">// 冻结所有的beanDefinition的metadata，不期被进一步的修改。</span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">   <span class="comment">// 初始化所有剩余的(非懒加载)的单例bean  ***重点***</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="11-1-DefaultListableBeanFactory-preInstantiateSingletons"><a href="#11-1-DefaultListableBeanFactory-preInstantiateSingletons" class="headerlink" title="11.1 DefaultListableBeanFactory#preInstantiateSingletons"></a>11.1 DefaultListableBeanFactory#preInstantiateSingletons</h3><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">   <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">   <span class="comment">// 遍历一个副本以允许使用init方法，这些方法依次注册新的bean定义。</span></span><br><span class="line">   <span class="comment">// 尽管这可能不是常规工厂引导程序的一部分，但可以正常运行。</span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">   <span class="comment">// 触发初始化所有非懒加载单例bean</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="comment">// 如果指定的bean对应一个子bean定义，遍历父BeanDefinition并合并成RootBeanDefinition</span></span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      <span class="comment">// RootBeanDefinition 不是抽象的、是单例的、不是懒加载的bean</span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">         <span class="comment">// 是否是FactoryBean</span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 返回 beanName 对应的 FactoryBean</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">               <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">               <span class="type">boolean</span> isEagerInit; <span class="comment">// 是否立即初始化</span></span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                              ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                        getAccessControlContext());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                  <span class="comment">// 初始化 bean</span></span><br><span class="line">                  getBean(beanName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化 bean</span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">   <span class="comment">// 遍历beanNames, 触发所有 SmartInitializingSingleton 的后初始化回调</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">      <span class="comment">// 判断singletonInstance是否实现了SmartInitializingSingleton接口</span></span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="comment">// 是否存在 Java安全管理器</span></span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 触发SmartInitializingSingleton实现类的afterSingletonsInstantiated方法</span></span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-1-1-AbstractBeanFactory-getMergedLocalBeanDefinition"><a href="#11-1-1-AbstractBeanFactory-getMergedLocalBeanDefinition" class="headerlink" title="11.1.1 AbstractBeanFactory#getMergedLocalBeanDefinition"></a>11.1.1 AbstractBeanFactory#getMergedLocalBeanDefinition</h4><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.support.AbstractBeanFactory#getMergedLocalBeanDefinition</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bean定义公共的抽象类是AbstractBeanDefinition，普通的Bean在Spring加载Bean定义的时候，实例化出来的是GenericBeanDefinition，</span></span><br><span class="line"><span class="comment"> * 而Spring上下文包括实例化所有Bean用的AbstractBeanDefinition是RootBeanDefinition，这时候就使用getMergedLocalBeanDefinition方法做了一次转化，</span></span><br><span class="line"><span class="comment"> * 将非RootBeanDefinition转换为RootBeanDefinition以供后续操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> RootBeanDefinition <span class="title function_">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">   <span class="comment">// 检查beanName对应的mergedBeanDefinitions是否存在于缓存中,此缓存是在beanFactoryPostProcessor中添加的</span></span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> <span class="built_in">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">   <span class="keyword">if</span> (mbd != <span class="literal">null</span> &amp;&amp; !mbd.stale) &#123;</span><br><span class="line">      <span class="comment">// mdb已获取到, 且mbd不需要重新合并定义</span></span><br><span class="line">      <span class="keyword">return</span> mbd;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果不存在与缓存中或者需要重新合并定义，则根据beanName和BeanDefinition，获取mergedBeanDefinitions</span></span><br><span class="line">   <span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-1-2-AbstractBeanFactory-getMergedBeanDefinition"><a href="#11-1-2-AbstractBeanFactory-getMergedBeanDefinition" class="headerlink" title="11.1.2 AbstractBeanFactory#getMergedBeanDefinition"></a>11.1.2 AbstractBeanFactory#getMergedBeanDefinition</h4><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.support.AbstractBeanFactory#getMergedBeanDefinition</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果给定的BeanDefinition是一个子BeanDefinition, 则需要合并父BeanDefinition，最后返回对于给定的bean的RootBeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> RootBeanDefinition <span class="title function_">getMergedBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">      String beanName, BeanDefinition bd, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">      <span class="comment">// 用于存储bd的MergedBeanDefinition</span></span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">previous</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check with full lock now in order to enforce the same merged instance.</span></span><br><span class="line">      <span class="comment">// 检查beanName对应的MergedBeanDefinition是否存在于缓存中</span></span><br><span class="line">      <span class="keyword">if</span> (containingBd == <span class="literal">null</span>) &#123;</span><br><span class="line">         mbd = <span class="built_in">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// mbd 为null 并且 mbd需要重新合并</span></span><br><span class="line">      <span class="keyword">if</span> (mbd == <span class="literal">null</span> || mbd.stale) &#123;</span><br><span class="line">         previous = mbd;</span><br><span class="line">         mbd = <span class="literal">null</span>;</span><br><span class="line">         <span class="comment">// 如果bd的parentName为空，代表bd没有父定义，无需与父定义进行合并操作</span></span><br><span class="line">         <span class="comment">// bean的ParentName</span></span><br><span class="line">         <span class="keyword">if</span> (bd.getParentName() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Use copy of given root bean definition.</span></span><br><span class="line">            <span class="comment">// 如果bd的类型为RootBeanDefinition，则bd的MergedBeanDefinition就是bd本身，则直接克隆一个副本</span></span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">               mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 否则，将bd作为参数，构建一个RootBeanDefinition。</span></span><br><span class="line">               <span class="comment">// 正常使用下，BeanDefinition在被加载后是GenericBeanDefinition或ScannedGenericBeanDefinition</span></span><br><span class="line">               mbd = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(bd);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Child bean definition: needs to be merged with parent.</span></span><br><span class="line">            <span class="comment">// bd存在父定义，需要与父定义合并</span></span><br><span class="line">            BeanDefinition pbd;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 获取父bean的名称，并进行转换</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">parentBeanName</span> <span class="operator">=</span> transformedBeanName(bd.getParentName());</span><br><span class="line">               <span class="comment">// 如果当前beanName和父beanName不相同，那么递归调用合并方法</span></span><br><span class="line">               <span class="keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">                  pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果父定义的beanName与bd的beanName相同，则拿到父BeanFactory，</span></span><br><span class="line">                  <span class="comment">// 只有在存在父BeanFactory的情况下，才允许父定义beanName与自己相同，否则就是将自己设置为父定义</span></span><br><span class="line">                  <span class="type">BeanFactory</span> <span class="variable">parent</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">                  <span class="comment">// 如果父BeanFactory是ConfigurableBeanFactory，则通过父BeanFactory获取父定义的MergedBeanDefinition</span></span><br><span class="line">                  <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">                     <span class="comment">// 从父BeanFactory获取BeanDefinition</span></span><br><span class="line">                     pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// 如果父BeanFactory不是ConfigurableBeanFactory，则抛异常</span></span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(parentBeanName,</span><br><span class="line">                           <span class="string">&quot;Parent name &#x27;&quot;</span> + parentBeanName + <span class="string">&quot;&#x27; is equal to bean name &#x27;&quot;</span> + beanName +</span><br><span class="line">                           <span class="string">&quot;&#x27;: cannot be resolved without an AbstractBeanFactory parent&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(bd.getResourceDescription(), beanName,</span><br><span class="line">                     <span class="string">&quot;Could not resolve parent bean definition &#x27;&quot;</span> + bd.getParentName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Deep copy with overridden values.</span></span><br><span class="line">            <span class="comment">// 根据父BeanFactory获取的BeanDefinition创建新的BeanDefinition</span></span><br><span class="line">            mbd = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(pbd);</span><br><span class="line">            <span class="comment">// 将原始的部分属性拷贝到mbd</span></span><br><span class="line">            mbd.overrideFrom(bd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Set default singleton scope, if not configured before.</span></span><br><span class="line">         <span class="comment">// 如果没有配置scope，则设置为默认的单例scope</span></span><br><span class="line">         <span class="keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">            mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// A bean contained in a non-singleton bean cannot be a singleton itself.</span></span><br><span class="line">         <span class="comment">// Let&#x27;s correct this on the fly here, since this might be the result of</span></span><br><span class="line">         <span class="comment">// parent-child merging for the outer bean, in which case the original inner bean</span></span><br><span class="line">         <span class="comment">// definition will not have inherited the merged outer bean&#x27;s singleton status.</span></span><br><span class="line">         <span class="comment">// 一个bean包含非单例bean, 则他不是一个单例bean</span></span><br><span class="line">         <span class="comment">// 我们在此时进行修改scope，因为这可能是外部bean的父子合并的结果，在这种情况下，原始内部beanDefinition将不会继承合并的外部bean的单例状态</span></span><br><span class="line">         <span class="keyword">if</span> (containingBd != <span class="literal">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">            mbd.setScope(containingBd.getScope());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Cache the merged bean definition for the time being</span></span><br><span class="line">         <span class="comment">// (it might still get re-merged later on in order to pick up metadata changes)</span></span><br><span class="line">         <span class="comment">// 将beanName与mbd放到mergedBeanDefinitions缓存，以便之后可以直接使用</span></span><br><span class="line">         <span class="keyword">if</span> (containingBd == <span class="literal">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (previous != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 拷贝相关的MergedBeanDefinition字段</span></span><br><span class="line">         copyRelevantMergedBeanDefinitionCaches(previous, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> mbd;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-1-3-AbstractBeanFactory-doGetBean"><a href="#11-1-3-AbstractBeanFactory-doGetBean" class="headerlink" title="11.1.3 AbstractBeanFactory#doGetBean"></a>11.1.3 AbstractBeanFactory#doGetBean</h4><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</p>
</blockquote>
<ul>
<li>根据传入的 beanName 转换成 Spring 中的 beanName</li>
<li>查询缓存中的 bean 单例对象</li>
<li></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 传入的 name 可能是 beanName, alias, &amp;beanName (FactoryBean)</span></span><br><span class="line">   <span class="comment">// 将 name 转换成 beanName</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">   Object bean;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">   <span class="comment">// 提前检查单例缓存中是否有手动注册的单例对象，跟循环依赖有关联</span></span><br><span class="line">   <span class="comment">// 从缓存中获取已实例化的单例对象</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                  <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回对象的实例</span></span><br><span class="line">      <span class="comment">// 当你实现了FactoryBean接口的对象，需要获取具体的对象的时候就需要此方法来进行获取了</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">      <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">      <span class="comment">// 当对象都是单例的时候会尝试解决循环依赖的问题，但是原型模式下如果存在循环依赖的情况，那么直接抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">      <span class="comment">// 检查该工厂中是否存在bean定义</span></span><br><span class="line">      <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                  nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">            <span class="comment">// 父级创建对象 bean 实例</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果不是做类型检查，那么表示要创建bean，此处在集合中做一个记录</span></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 此处做了BeanDefinition对象的转换,</span></span><br><span class="line">         <span class="comment">// 当我们从xml文件中加载 BeanDefinition 对象的时候，封装的对象是 GenericBeanDefinition,</span></span><br><span class="line">         <span class="comment">// 此处要做类型转换，如果是子类bean的话，会合并父类的相关属性</span></span><br><span class="line">         <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">         <span class="comment">// 确保当前bean依赖的bean的初始化</span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在依赖，则需要递归实例化依赖的bean</span></span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 注册各个bean的依赖关系，方便进行销毁</span></span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 先实例化引用的 bean 实例</span></span><br><span class="line">                  getBean(dep);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Create bean instance.</span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">// 创建单例对象</span></span><br><span class="line">            sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                  <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                  <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                  <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                  destroySingleton(beanName);</span><br><span class="line">                  <span class="keyword">throw</span> ex;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">// 原型模式的bean对象创建</span></span><br><span class="line">            <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 指定的scope上实例化bean</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                  beforePrototypeCreation(beanName);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">finally</span> &#123;</span><br><span class="line">                     afterPrototypeCreation(beanName);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">                     <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">   <span class="comment">// 检查所需的类型是否与实际bean实例的类型匹配。</span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 获取类型转换器，并且进行类型转换</span></span><br><span class="line">         <span class="type">T</span> <span class="variable">convertedBean</span> <span class="operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">         <span class="keyword">if</span> (convertedBean == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="11-1-3-1-DefaultSingletonBeanRegistry-getSingleton-String-boolean"><a href="#11-1-3-1-DefaultSingletonBeanRegistry-getSingleton-String-boolean" class="headerlink" title="11.1.3.1 DefaultSingletonBeanRegistry#getSingleton(String, boolean)"></a>11.1.3.1 DefaultSingletonBeanRegistry#getSingleton(String, boolean)</h5><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(String, boolean)</p>
</blockquote>
<p>从缓存中获取单例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">   <span class="comment">// 从单例对象缓存(一级缓存)中获取beanName对应的单例对象</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">   <span class="comment">// 如果单例对象缓存中没有，并且该beanName对应的单例bean正在创建中(下面的代码只有在存在循环引用才会调用)</span></span><br><span class="line">   <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">         <span class="comment">// 从早期单例对象缓存(二级缓存)中获取单例对象（之所称成为早期单例对象，</span></span><br><span class="line">         <span class="comment">// 是因为earlySingletonObjects里的对象的都是通过提前曝光的ObjectFactory创建出来的，</span></span><br><span class="line">         <span class="comment">// 还未进行属性填充等操作）</span></span><br><span class="line">         singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">         <span class="comment">// 如果在早期单例对象缓存(二级缓存)中也没有，并且允许创建早期单例对象引用</span></span><br><span class="line">         <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            <span class="comment">// 当某些方法需要提前初始化的时候则会调用addSingletonFactory方法,</span></span><br><span class="line">            <span class="comment">// 将对应的ObjectFactory初始化策略存储在三级缓存</span></span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 如果存在单例对象工厂，则通过工厂创建一个单例对象</span></span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               <span class="comment">// 记录在缓存中，二级缓存和三级缓存的对象不能同时存在</span></span><br><span class="line">               <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">               <span class="comment">// 从三级缓存中移除</span></span><br><span class="line">               <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="11-1-3-2-DefaultSingletonBeanRegistry-getObjectForBeanInstance"><a href="#11-1-3-2-DefaultSingletonBeanRegistry-getObjectForBeanInstance" class="headerlink" title="11.1.3.2 DefaultSingletonBeanRegistry#getObjectForBeanInstance"></a>11.1.3.2 DefaultSingletonBeanRegistry#getObjectForBeanInstance</h5><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getObjectForBeanInstance</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取给定bean实例的对象，即bean</span></span><br><span class="line"><span class="comment"> * 实例本身或其创建的对象（对于FactoryBean）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">      Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">   <span class="comment">// 通过beanName判断是否有factoryBean的前缀(即 name包含&amp;)</span></span><br><span class="line">   <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123; <span class="comment">//</span></span><br><span class="line">      <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">         <span class="keyword">return</span> beanInstance;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">         <span class="comment">// beanInstance 没有实现 FactoryBean 接口</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(beanName, beanInstance.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">         mbd.isFactoryBean = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">   <span class="comment">// If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">   <span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">   <span class="comment">// 当我们有了bean的实例之后，这个实例可能是正常的bean，也可能是FactoryBean，</span></span><br><span class="line">   <span class="comment">// 如果是FactoryBean那么就直接创建实例，</span></span><br><span class="line">   <span class="comment">// 但是如果用户想要直接获取工厂实例而不是工厂的getObject方法对应的实例，那么传入的参数应该加&amp;前缀</span></span><br><span class="line">   <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">      <span class="comment">// beanInstance 没有实现 FactoryBean 接口</span></span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建FactoryBean中的bean</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbd.isFactoryBean = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 尝试从缓存中加载bean</span></span><br><span class="line">      object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Return bean instance from factory.</span></span><br><span class="line">      <span class="comment">// 将beanInstance转换为FactoryBean类型</span></span><br><span class="line">      FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">      <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 将存储xml配置文件的 GenericBeanDefinition 转换为RootBeanDefinition，</span></span><br><span class="line">         <span class="comment">// 如果指定BeanName是子Bean的话，同时会合并父类的相关属性</span></span><br><span class="line">         mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断当前bean是否是用户定义的，而不是应用程序本身定义的</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">      object = getObjectFromFactoryBean(factory, beanName, !synthetic); <span class="comment">// factory::getObject</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="11-1-3-2-1-FactoryBeanRegistrySupport-getObjectFromFactoryBean"><a href="#11-1-3-2-1-FactoryBeanRegistrySupport-getObjectFromFactoryBean" class="headerlink" title="11.1.3.2.1 FactoryBeanRegistrySupport#getObjectFromFactoryBean"></a>11.1.3.2.1 FactoryBeanRegistrySupport#getObjectFromFactoryBean</h6><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getObjectForBeanInstance</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">         <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">         <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">            object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">            <span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">            <span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;</span><br><span class="line">               object = alreadyThere;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 需要处理</span></span><br><span class="line">               <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">                  <span class="comment">// 单例对象直接返回</span></span><br><span class="line">                  <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                     <span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">                     <span class="keyword">return</span> object;</span><br><span class="line">                  &#125;</span><br><span class="line">                  beforeSingletonCreation(beanName);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="comment">// 进行后置处理器处理</span></span><br><span class="line">                     object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">                           <span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">finally</span> &#123;</span><br><span class="line">                     afterSingletonCreation(beanName);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">                  <span class="comment">// 如果包含了FactoryBean,就将创建的对象缓存</span></span><br><span class="line">                  <span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> object;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// FactoryBean是原型的话</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">      <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用ObjectFactory的后置处理器</span></span><br><span class="line">            object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   Object object;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> getAccessControlContext();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">            <span class="keyword">throw</span> pae.getException();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 直接调用getObject方法，返回具体的对象</span></span><br><span class="line">         object = factory.getObject();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName, ex.toString());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not accept a null value for a FactoryBean that&#x27;s not fully</span></span><br><span class="line">   <span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line">   <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果是正在创建的FactoryBean,还没能获得bean，就报异常</span></span><br><span class="line">      <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(</span><br><span class="line">               beanName, <span class="string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      object = <span class="keyword">new</span> <span class="title class_">NullBean</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="11-1-3-3-DefaultSingletonBeanRegistry-registerDependentBean"><a href="#11-1-3-3-DefaultSingletonBeanRegistry-registerDependentBean" class="headerlink" title="11.1.3.3 DefaultSingletonBeanRegistry#registerDependentBean"></a>11.1.3.3 DefaultSingletonBeanRegistry#registerDependentBean</h5><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#registerDependentBean</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerDependentBean</span><span class="params">(String beanName, String dependentBeanName)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取name的最终别名或者是全类名</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> canonicalName(beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用存储bean名称到该bean名称要依赖的bean名称的Map作为锁，保证线程安全</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.dependentBeanMap) &#123;</span><br><span class="line">      <span class="comment">// 获取canonicalName对应的用于存储依赖Bean名的Set集合，如果没有就创建一个LinkeHashSet，</span></span><br><span class="line">      <span class="comment">// 并与canonicalName绑定到dependentBeans中</span></span><br><span class="line">      Set&lt;String&gt; dependentBeans =</span><br><span class="line">            <span class="built_in">this</span>.dependentBeanMap.computeIfAbsent(canonicalName, k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">      <span class="comment">// 如果dependentBeans已经添加过来了dependentBeanName，就结束该方法，不执行后面操作。</span></span><br><span class="line">      <span class="keyword">if</span> (!dependentBeans.add(dependentBeanName)) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用Bean依赖关系Map作为锁，保证线程安全</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.dependenciesForBeanMap) &#123;</span><br><span class="line">      <span class="comment">// 添加dependentBeanName依赖于canonicalName的映射关系到存储bean名到依赖于该bean名的bean名称的Map中</span></span><br><span class="line">      Set&lt;String&gt; dependenciesForBean =</span><br><span class="line">            <span class="built_in">this</span>.dependenciesForBeanMap.computeIfAbsent(dependentBeanName, k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">      dependenciesForBean.add(canonicalName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-1-3-4-DefaultSingletonBeanRegistry-getSingleton-String-ObjectFactory-lt-gt"><a href="#11-1-3-4-DefaultSingletonBeanRegistry-getSingleton-String-ObjectFactory-lt-gt" class="headerlink" title="11.1.3.4 DefaultSingletonBeanRegistry#getSingleton(String, ObjectFactory&lt;?&gt;)"></a>11.1.3.4 DefaultSingletonBeanRegistry#getSingleton(String, ObjectFactory&lt;?&gt;)</h5><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(String, ObjectFactory&lt;?&gt;)</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object getSingleton(<span class="keyword">String</span> beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;</span><br><span class="line">   Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">   <span class="comment">// 全局变量需要同步</span></span><br><span class="line">   synchronized (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 首先检查一级缓存中是否存在对应的bean</span></span><br><span class="line">      Object singletonObject = <span class="built_in">this</span>.singletonObjects.<span class="keyword">get</span>(beanName);</span><br><span class="line">      <span class="comment">// 如果对象不存在，才需要进行bean的实例化</span></span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 判断单例是否在销毁中，如果是，直接报异常</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">BeanCreationNotAllowedException</span>(beanName,</span><br><span class="line">                  <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 记录当前对象的加载状态，做个正在创建的标记</span></span><br><span class="line">         beforeSingletonCreation(beanName);</span><br><span class="line">         boolean <span class="keyword">new</span><span class="type">Singleton</span> = <span class="literal">false</span>;</span><br><span class="line">         boolean recordSuppressedExceptions = (<span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>);</span><br><span class="line">         <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">            <span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="type">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始进行bean对象的创建</span></span><br><span class="line">            singletonObject = singletonFactory.getObject();</span><br><span class="line">            <span class="comment">// 只要获取了就是新的单例对象</span></span><br><span class="line">            <span class="keyword">new</span><span class="type">Singleton</span> = <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">            <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">            singletonObject = <span class="built_in">this</span>.singletonObjects.<span class="keyword">get</span>(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">               <span class="keyword">for</span> (Exception suppressedException : <span class="type">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                  ex.addRelatedCause(suppressedException);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">         &#125;</span><br><span class="line">         finally &#123;</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">               <span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移除缓存中对该bean的正在加载状态的记录</span></span><br><span class="line">            afterSingletonCreation(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 加入到一级缓存中</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Singleton</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加单例对象到缓存, 并从二级和三级缓存移除单例对象</span></span><br><span class="line">            addSingleton(beanName, singletonObject);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> singletonObject;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 将单例对象放入一级缓存</span></span><br><span class="line">      <span class="built_in">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">      <span class="comment">// 将单例对象从三级缓存中移除</span></span><br><span class="line">      <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">      <span class="comment">// 将单例对象从二级缓存中移除</span></span><br><span class="line">      <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">      <span class="comment">// 将单例对象 beanName 添加到 已注册的集合中</span></span><br><span class="line">      <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(12) 实例化对象</title>
    <url>/2020/10/25/spring/Spring13/</url>
    <content><![CDATA[<h2 id="12-2-AbstractAutowireCapableBeanFactory-createBean"><a href="#12-2-AbstractAutowireCapableBeanFactory-createBean" class="headerlink" title="12.2 AbstractAutowireCapableBeanFactory#createBean"></a>12.2 AbstractAutowireCapableBeanFactory#createBean</h2><blockquote>
<p><strong>定位</strong>: org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">   <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">   <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">   <span class="comment">// 锁定class，根据设置的class属性或者根据className来解析class</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="comment">// 进行条件筛选，重新赋值RootBeanDefinition,并设置BeanClass属性</span></span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 重新创建一个RootBeanDefinition对象</span></span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      <span class="comment">// 设置BeanClass属性值</span></span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Prepare method overrides.</span></span><br><span class="line">   <span class="comment">// 验证及准备覆盖的方法,lookup-method  replace-method，</span></span><br><span class="line">   <span class="comment">// 当需要创建的bean对象中包含了lookup-method和replace-method标签的时候，会产生覆盖操作</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 验证以及准备覆盖的方法即Override方法</span></span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">      <span class="comment">// 返回代理来代替真正的实例：--------------应用实例化前的前置处理器</span></span><br><span class="line">      <span class="comment">// 给BeanPostProcessors一个机会来返回代理来替代真正的实例，应用实例化前的前置处理器</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">      <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">      <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-1-AbstractAutowireCapableBeanFactory-resolveBeforeInstantiation"><a href="#12-2-1-AbstractAutowireCapableBeanFactory-resolveBeforeInstantiation" class="headerlink" title="12.2.1 AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation"></a>12.2.1 AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation</h3><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 如果beforeInstantiationResolved值为null或者true，那么表示尚未被处理，进行后续的处理</span></span><br><span class="line">   <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">      <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">      <span class="comment">// 确认beanClass确实在此处进行处理</span></span><br><span class="line">      <span class="comment">// 判断当前mbd是否是合成的，只有在实现aop的时候synthetic的值才为true，</span></span><br><span class="line">      <span class="comment">// 并且是否实现了InstantiationAwareBeanPostProcessor接口</span></span><br><span class="line">      <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="comment">// 获取类型</span></span><br><span class="line">         Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">         <span class="keyword">if</span> (targetType != <span class="literal">null</span>) &#123;</span><br><span class="line">            bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">            <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">               bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 是否解析了</span></span><br><span class="line">      mbd.beforeInstantiationResolved = (bean != <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-2-AbstractAutowireCapableBeanFactory-doCreateBean"><a href="#12-2-2-AbstractAutowireCapableBeanFactory-doCreateBean" class="headerlink" title="12.2.2 AbstractAutowireCapableBeanFactory#doCreateBean"></a>12.2.2 AbstractAutowireCapableBeanFactory#doCreateBean</h3><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   <span class="comment">// 这个beanWrapper是用来持有创建出来的bean对象的</span></span><br><span class="line">   <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 获取factoryBean实例缓存</span></span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      <span class="comment">// 如果是单例对象，从factorybean实例缓存中移除当前bean定义信息</span></span><br><span class="line">      instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 没有就创建实例</span></span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建Bean对象，并且将对象包裹在 BeanWrapper 中</span></span><br><span class="line">      <span class="comment">// 根据执行bean使用对应的策略创建新的实例，如，工厂方法，构造函数主动注入、简单初始化</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 再从Wrapper中把Bean原始对象（非代理）  这个时候这个Bean就有地址值了，就能被引用了</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">   <span class="comment">// 获取具体的bean对象的Class属性</span></span><br><span class="line">   Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">   <span class="comment">// 如果不等于NullBean类型，那么修改目标类型</span></span><br><span class="line">   <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">      mbd.resolvedTargetType = beanType;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">   <span class="comment">// 允许 beanPostProcessor 去修改合并的 beanDefinition</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// MergedBeanDefinitionPostProcessor 后置处理器修改合并bean的定义</span></span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">   <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">   <span class="comment">// 判断当前bean是否需要提前曝光：单例&amp;允许循环依赖&amp;当前bean正在创建中，检测循环依赖</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">               <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 解决循环引用问题，需要提前暴露引用</span></span><br><span class="line">      <span class="comment">// 为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory加入工厂</span></span><br><span class="line">      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   <span class="comment">// 初始化bean实例</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 使用Bean定义中的属性值填充给定BeanWrapper中的Bean实例</span></span><br><span class="line">      <span class="comment">// 对bean的属性进行填充，将各个属性值注入，其中，可能存在依赖于其他bean的属性，则会递归初始化依赖的bean</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="comment">// 使用工厂回调以及初始化方法和bean后处理器初始化给定的bean实例。执行初始化逻辑</span></span><br><span class="line">      <span class="comment">// 1. BeanNameAware#setBeanName、BeanClassLoaderAware#setBeanClassLoader、BeanFactoryAware#setBeanFactory</span></span><br><span class="line">      <span class="comment">// 2. BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line">      <span class="comment">// 3. InitializingBean#afterPropertiesSet 和 调用配置的 initMethod 方法</span></span><br><span class="line">      <span class="comment">// 4. BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="comment">// 尝试从缓存中获取单例，注意后面的参数为false，表示不从第三级缓存singletonFactories中获取</span></span><br><span class="line">      <span class="comment">// 为什么呢？因为这里不允许循环依赖</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">      <span class="comment">// 如果不为null，就会进入if条件中，因为earlySingletonReference不为null，说明存在循环引用，</span></span><br><span class="line">      <span class="comment">// 为什么呢？因为第一个处理的时候，会将引用放到singletonFactories缓存中，当循环依赖注入的时候，</span></span><br><span class="line">      <span class="comment">// 会通过singletonFactories中拿到提前暴露的引用，然后放到第二级缓存earlySingletonObjects中。</span></span><br><span class="line">      <span class="comment">// 所以，在这里拿到了earlySingletonReference，表明存在循环引用。</span></span><br><span class="line">      <span class="comment">// earlySingletonReference只有在检测到有循环依赖的情况下才会不为空</span></span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 如果相等，那么就什么也不做，将earlySingletonReference返回回去即可</span></span><br><span class="line">         <span class="comment">// 如果exposedObject没有在初始化方法中被改变，也就是没有被增强</span></span><br><span class="line">         <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 如果不相等，并且有其它bean依赖这个bean</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 拿到依赖这个bean的所有bean</span></span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               <span class="comment">// 如果存在已经创建完的bean（已经创建完的bean依赖该bean）</span></span><br><span class="line">               <span class="comment">// 返回false说明依赖还没实例化好</span></span><br><span class="line">               <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               <span class="comment">// 防止对象被改变，造成的已创建对象中持有的对象和这个对象不一致。</span></span><br><span class="line">               <span class="comment">// 因为bean创建后所依赖的bean一定是已经创建的</span></span><br><span class="line">               <span class="comment">// actualDependentBeans不为空则表示当前bean创建后其依赖的bean却没有全部创建完，也就是说存在循环依赖</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                     <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean as disposable.</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 注册 DisposableBean 和 解析配置的 destroyMethod 方法</span></span><br><span class="line">      <span class="comment">// 注册bean对象，方便后续在容器销毁的时候销毁对象</span></span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="12-2-2-1-AbstractAutowireCapableBeanFactory-createBeanInstance"><a href="#12-2-2-1-AbstractAutowireCapableBeanFactory-createBeanInstance" class="headerlink" title="12.2.2.1 AbstractAutowireCapableBeanFactory#createBeanInstance"></a>12.2.2.1 AbstractAutowireCapableBeanFactory#createBeanInstance</h4><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> &#123;</span><br><span class="line">   <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">   <span class="comment">// 确认需要创建的bean实例的类可以实例化</span></span><br><span class="line">   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断当前beanDefinition中是否包含实例供应器，此处相当于一个回调方法，利用回调方法来创建bean</span></span><br><span class="line">   Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">   <span class="keyword">if</span> (instanceSupplier != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果工厂方法不为空则使用工厂方法初始化策略</span></span><br><span class="line">   <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 一个类可能有多个构造器，所以Spring得根据参数个数、类型确定需要调用的构造器</span></span><br><span class="line">   <span class="comment">// 在使用构造器创建实例后，Spring会将解析过后确定下来的构造器或工厂方法保存在缓存中，避免再次创建相同bean时再次解析</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">   <span class="comment">// 标记下，防止重复创建同一个bean</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">// 是否需要自动装配</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">// 如果没有参数</span></span><br><span class="line">   <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">         <span class="comment">// 因为一个类可能由多个构造函数，所以需要根据配置文件中配置的参数或传入的参数来确定最终调用的构造函数。</span></span><br><span class="line">         <span class="comment">// 因为判断过程会比较，所以spring会将解析、确定好的构造函数缓存到BeanDefinition中的resolvedConstructorOrFactoryMethod字段中。</span></span><br><span class="line">         <span class="comment">// 在下次创建相同时直接从RootBeanDefinition中的属性resolvedConstructorOrFactoryMethod缓存的值获取，避免再次解析</span></span><br><span class="line">         <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">            resolved = <span class="literal">true</span>;</span><br><span class="line">            autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 有构造参数的或者工厂方法</span></span><br><span class="line">   <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">      <span class="comment">// 构造器有参数</span></span><br><span class="line">      <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">         <span class="comment">// 构造函数自动注入</span></span><br><span class="line">         <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 使用默认构造函数构造</span></span><br><span class="line">         <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">   <span class="comment">// 从bean后置处理器中为自动装配寻找构造方法, 有且仅有一个有参构造或者有且仅有@Autowired注解构造</span></span><br><span class="line">   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">   <span class="comment">// 以下情况符合其一即可进入</span></span><br><span class="line">   <span class="comment">// 1、存在可选构造方法</span></span><br><span class="line">   <span class="comment">// 2、自动装配模型为构造函数自动装配</span></span><br><span class="line">   <span class="comment">// 3、给BeanDefinition中设置了构造参数值</span></span><br><span class="line">   <span class="comment">// 4、有参与构造函数参数列表的参数</span></span><br><span class="line">   <span class="keyword">if</span> (ctors != <span class="literal">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">   <span class="comment">// 找出最合适的默认构造方法</span></span><br><span class="line">   ctors = mbd.getPreferredConstructors();</span><br><span class="line">   <span class="keyword">if</span> (ctors != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">   <span class="comment">// 使用默认无参构造函数创建对象，如果没有无参构造且存在多个有参构造且没有@AutoWired注解构造，会报错</span></span><br><span class="line">   <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-2-2-1-1-ConstructorResolver-autowireConstructor"><a href="#12-2-2-1-1-ConstructorResolver-autowireConstructor" class="headerlink" title="12.2.2.1.1 ConstructorResolver#autowireConstructor"></a>12.2.2.1.1 ConstructorResolver#autowireConstructor</h4><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.ConstructorResolver#autowireConstructor</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanWrapper <span class="title function_">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 实例化BeanWrapper。是包装bean的容器</span></span><br><span class="line">   <span class="type">BeanWrapperImpl</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>();</span><br><span class="line">   <span class="comment">// 给包装对象设置一些属性</span></span><br><span class="line">   <span class="built_in">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// spring对这个bean进行实例化使用的构造函数</span></span><br><span class="line">   Constructor&lt;?&gt; constructorToUse = <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// spring执行构造函数使用的是参数封装类</span></span><br><span class="line">   <span class="type">ArgumentsHolder</span> <span class="variable">argsHolderToUse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 参与构造函数实例化过程的参数</span></span><br><span class="line">   Object[] argsToUse = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果传入参数的话，就直接使用传入的参数</span></span><br><span class="line">   <span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 让argsToUse引用explicitArgs</span></span><br><span class="line">      argsToUse = explicitArgs;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 没有传入参数的话就走else</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//声明一个要解析的参数值数组，默认为null</span></span><br><span class="line">      Object[] argsToResolve = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">         <span class="comment">// 获取BeanDefinition中解析完成的构造函数</span></span><br><span class="line">         constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">         <span class="comment">// BeanDefinition中存在构造函数并且存在构造函数的参数，赋值进行使用</span></span><br><span class="line">         <span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">            <span class="comment">// Found a cached constructor...</span></span><br><span class="line">            <span class="comment">// 从缓存中找到了构造器，那么继续从缓存中寻找缓存的构造器参数</span></span><br><span class="line">            argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">            <span class="keyword">if</span> (argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 没有缓存的参数，就需要获取配置文件中配置的参数</span></span><br><span class="line">               argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果缓存中没有缓存的参数的话，即argsToResolve不为空，就需要解析配置的参数</span></span><br><span class="line">      <span class="keyword">if</span> (argsToResolve != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 解析参数类型，比如将配置的String类型转换为list、boolean等类型</span></span><br><span class="line">         argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果constructorToUse为null或者argsToUser为null</span></span><br><span class="line">   <span class="keyword">if</span> (constructorToUse == <span class="literal">null</span> || argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Take specified constructors, if any.</span></span><br><span class="line">      <span class="comment">// 如果传入的构造器数组不为空，就使用传入的过后早期参数，否则通过反射获取class中定义的构造器</span></span><br><span class="line">      Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line">      <span class="comment">// 如果candidates为null</span></span><br><span class="line">      <span class="keyword">if</span> (candidates == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 获取mbd的Bean类</span></span><br><span class="line">         Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用public的构造器或者所有构造器</span></span><br><span class="line">            candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">                  beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 捕捉获取beanClass的构造函数发出的异常</span></span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;Resolution of declared constructors on bean Class [&quot;</span> + beanClass.getName() +</span><br><span class="line">                  <span class="string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="string">&quot;] failed&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果candidateList只有一个元素 且 没有传入构造函数值 且 mbd也没有构造函数参数值</span></span><br><span class="line">      <span class="keyword">if</span> (candidates.length == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="literal">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">         <span class="comment">// 获取candidates中唯一的方法</span></span><br><span class="line">         Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="number">0</span>];</span><br><span class="line">         <span class="comment">// 如果uniqueCandidate不需要参数</span></span><br><span class="line">         <span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用mdb的构造函数字段的通用锁【&#123;@link RootBeanDefinition#constructorArgumentLock&#125;】进行加锁以保证线程安全</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">               <span class="comment">// 让mbd缓存已解析的构造函数或工厂方法</span></span><br><span class="line">               mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">               <span class="comment">// 让mbd标记构造函数参数已解析</span></span><br><span class="line">               mbd.constructorArgumentsResolved = <span class="literal">true</span>;</span><br><span class="line">               <span class="comment">// 让mbd缓存完全解析的构造函数参数</span></span><br><span class="line">               mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用constructorToUse生成与beanName对应的Bean对象,并将该Bean对象保存到bw中</span></span><br><span class="line">            bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line">            <span class="comment">// 将bw返回出去</span></span><br><span class="line">            <span class="keyword">return</span> bw;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Need to resolve the constructor.</span></span><br><span class="line">      <span class="comment">// 自动装配标识，以下有一种情况成立则为true，</span></span><br><span class="line">      <span class="comment">// 1、传进来构造函数，证明spring根据之前代码的判断，知道应该用哪个构造函数，</span></span><br><span class="line">      <span class="comment">// 2、BeanDefinition中设置为构造函数注入模型</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">autowiring</span> <span class="operator">=</span> (chosenCtors != <span class="literal">null</span> ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">      <span class="comment">// 定义一个用于存放解析后的构造函数参数值的ConstructorArgumentValues对象</span></span><br><span class="line">      <span class="type">ConstructorArgumentValues</span> <span class="variable">resolvedValues</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构造函数的最小参数个数</span></span><br><span class="line">      <span class="type">int</span> minNrOfArgs;</span><br><span class="line">      <span class="comment">// 如果传入了参与构造函数实例化的参数值，那么参数的数量即为最小参数个数</span></span><br><span class="line">      <span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// minNrOfArgs引用 explicitArgs 的数组长度</span></span><br><span class="line">         minNrOfArgs = explicitArgs.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 提取配置文件中的配置的构造函数参数</span></span><br><span class="line">         <span class="type">ConstructorArgumentValues</span> <span class="variable">cargs</span> <span class="operator">=</span> mbd.getConstructorArgumentValues();</span><br><span class="line">         <span class="comment">// 用于承载解析后的构造函数参数的值</span></span><br><span class="line">         resolvedValues = <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>();</span><br><span class="line">         <span class="comment">// 能解析到的参数个数</span></span><br><span class="line">         minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对候选的构造函数进行排序，先是访问权限后是参数个数</span></span><br><span class="line">      <span class="comment">// public权限参数数量由多到少</span></span><br><span class="line">      AutowireUtils.sortConstructors(candidates);</span><br><span class="line">      <span class="comment">// 定义一个差异变量，变量的大小决定着构造函数是否能够被使用</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">minTypeDiffWeight</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">      <span class="comment">// 不明确的构造函数集合，正常情况下差异值不可能相同</span></span><br><span class="line">      Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 定义一个用于UnsatisfiedDependencyException的列表</span></span><br><span class="line">      LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 循环候选的构造函数</span></span><br><span class="line">      <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line">         <span class="comment">// 获取参数的个数</span></span><br><span class="line">         Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果已经找到选用的构造函数或者需要的参数个数小于当前的构造函数参数个数则终止，前面已经经过了排序操作</span></span><br><span class="line">         <span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; argsToUse != <span class="literal">null</span> &amp;&amp; argsToUse.length &gt; paramTypes.length) &#123;</span><br><span class="line">            <span class="comment">// Already found greedy constructor that can be satisfied -&gt;</span></span><br><span class="line">            <span class="comment">// do not look any further, there are only less greedy constructors left.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 如果本构造函数的参数列表数量小于要求的最小数量，则遍历下一个</span></span><br><span class="line">         <span class="keyword">if</span> (paramTypes.length &lt; minNrOfArgs) &#123;</span><br><span class="line">            <span class="comment">// 参数个数不相等</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 存放构造函数解析完成的参数列表</span></span><br><span class="line">         ArgumentsHolder argsHolder;</span><br><span class="line">         <span class="comment">// 存在需要解析的构造函数参数</span></span><br><span class="line">         <span class="keyword">if</span> (resolvedValues != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 获取构造函数上的ConstructorProperties注解中的参数</span></span><br><span class="line">               String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);</span><br><span class="line">               <span class="comment">// 如果没有上面的注解，则获取构造函数参数列表中属性的名称</span></span><br><span class="line">               <span class="keyword">if</span> (paramNames == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 获取参数名称探索器</span></span><br><span class="line">                  <span class="type">ParameterNameDiscoverer</span> <span class="variable">pnd</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">                  <span class="keyword">if</span> (pnd != <span class="literal">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 获取指定构造函数的参数名称</span></span><br><span class="line">                     paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 根据名称和数据类型创建参数持有者</span></span><br><span class="line">               argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">                     getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">               <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                  logger.trace(<span class="string">&quot;Ignoring constructor [&quot;</span> + candidate + <span class="string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Swallow and try next constructor.</span></span><br><span class="line">               <span class="comment">// 吞下并尝试下一个重载的构造函数</span></span><br><span class="line">               <span class="comment">// 如果cause为null</span></span><br><span class="line">               <span class="keyword">if</span> (causes == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 对cause进行实例化成LinkedList对象</span></span><br><span class="line">                  causes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 将ex添加到causes中</span></span><br><span class="line">               causes.add(ex);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 不存在构造函数参数列表需要解析的参数</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line">            <span class="comment">// 如果参数列表的数量与传入进来的参数数量不相等，继续遍历，否则构造参数列表封装对象</span></span><br><span class="line">            <span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构造函数没有参数的情况</span></span><br><span class="line">            argsHolder = <span class="keyword">new</span> <span class="title class_">ArgumentsHolder</span>(explicitArgs);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 计算差异量，根据要参与构造函数的参数列表和本构造函数的参数列表进行计算</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">typeDiffWeight</span> <span class="operator">=</span> (mbd.isLenientConstructorResolution() ?</span><br><span class="line">               argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">         <span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line">         <span class="comment">// 本次的构造函数差异值小于上一个构造函数，则进行构造函数更换</span></span><br><span class="line">         <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">            <span class="comment">// 将确定使用的构造函数设置为本构造</span></span><br><span class="line">            constructorToUse = candidate;</span><br><span class="line">            <span class="comment">// 更换使用的构造函数参数封装类</span></span><br><span class="line">            argsHolderToUse = argsHolder;</span><br><span class="line">            <span class="comment">// 更换参与构造函数实例化的参数</span></span><br><span class="line">            argsToUse = argsHolder.arguments;</span><br><span class="line">            <span class="comment">// 差异值更换</span></span><br><span class="line">            minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">            <span class="comment">// 不明确的构造函数列表清空为null</span></span><br><span class="line">            ambiguousConstructors = <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 差异值相等，则表明构造函数不正常，放入异常集合</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">            <span class="comment">// 如果ambiguousFactoryMethods为null</span></span><br><span class="line">            <span class="keyword">if</span> (ambiguousConstructors == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 初始化ambiguousFactoryMethods为LinkedHashSet实例</span></span><br><span class="line">               ambiguousConstructors = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">               <span class="comment">// 将constructorToUse添加到ambiguousFactoryMethods中</span></span><br><span class="line">               ambiguousConstructors.add(constructorToUse);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将candidate添加到ambiguousFactoryMethods中</span></span><br><span class="line">            ambiguousConstructors.add(candidate);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 以下两种情况会抛异常</span></span><br><span class="line">      <span class="comment">// 1、没有确定使用的构造函数</span></span><br><span class="line">      <span class="comment">// 2、存在模糊的构造函数并且不允许存在模糊的构造函数</span></span><br><span class="line">      <span class="keyword">if</span> (constructorToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (causes != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">UnsatisfiedDependencyException</span> <span class="variable">ex</span> <span class="operator">=</span> causes.removeLast();</span><br><span class="line">            <span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line">               <span class="built_in">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">               <span class="string">&quot;Could not resolve matching constructor &quot;</span> +</span><br><span class="line">               <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="literal">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">               <span class="string">&quot;Ambiguous constructor matches found in bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; &quot;</span> +</span><br><span class="line">               <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +</span><br><span class="line">               ambiguousConstructors);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 没有传入参与构造函数参数列表的参数时，对构造函数缓存到BeanDefinition中</span></span><br><span class="line"><span class="comment">       *     1、缓存BeanDefinition进行实例化时使用的构造函数</span></span><br><span class="line"><span class="comment">       *     2、缓存BeanDefinition代表的Bean的构造函数已解析完标识</span></span><br><span class="line"><span class="comment">       *     3、缓存参与构造函数参数列表值的参数列表</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (explicitArgs == <span class="literal">null</span> &amp;&amp; argsHolderToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 将解析的构造函数加入缓存</span></span><br><span class="line">         argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Assert.state(argsToUse != <span class="literal">null</span>, <span class="string">&quot;Unresolved constructor arguments&quot;</span>);</span><br><span class="line">   <span class="comment">// 将构造的实例加入BeanWrapper中</span></span><br><span class="line">   bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));</span><br><span class="line">   <span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-2-2-1-2-AbstractAutowireCapableBeanFactory-instantiateBean"><a href="#12-2-2-1-2-AbstractAutowireCapableBeanFactory-instantiateBean" class="headerlink" title="12.2.2.1.2 AbstractAutowireCapableBeanFactory#instantiateBean"></a>12.2.2.1.2 AbstractAutowireCapableBeanFactory#instantiateBean</h4><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#instantiateBean</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Object beanInstance;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">BeanFactory</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">         beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">               getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">               getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 获取实例化策略并且进行实例化操作</span></span><br><span class="line">         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 包装成BeanWrapper</span></span><br><span class="line">      <span class="type">BeanWrapper</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(beanInstance);</span><br><span class="line">      initBeanWrapper(bw);</span><br><span class="line">      <span class="keyword">return</span> bw;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="12-2-2-1-3-AbstractAutowireCapableBeanFactory-determineConstructorsFromBeanPostProcessors"><a href="#12-2-2-1-3-AbstractAutowireCapableBeanFactory-determineConstructorsFromBeanPostProcessors" class="headerlink" title="12.2.2.1.3 AbstractAutowireCapableBeanFactory#determineConstructorsFromBeanPostProcessors"></a>12.2.2.1.3 AbstractAutowireCapableBeanFactory#determineConstructorsFromBeanPostProcessors</h4><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#determineConstructorsFromBeanPostProcessors</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(<span class="meta">@Nullable</span> Class&lt;?&gt; beanClass, String beanName)</span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="comment">// 从SmartInstantiationAwareBeanPostProcessor判断</span></span><br><span class="line">            <span class="type">SmartInstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);</span><br><span class="line">            <span class="keyword">if</span> (ctors != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> ctors;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="12-2-2-2-DefaultSingletonBeanRegistry-addSingletonFactory"><a href="#12-2-2-2-DefaultSingletonBeanRegistry-addSingletonFactory" class="headerlink" title="12.2.2.2 DefaultSingletonBeanRegistry#addSingletonFactory"></a>12.2.2.2 DefaultSingletonBeanRegistry#addSingletonFactory</h4><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingletonFactory</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">   Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 放到单例工厂里</span></span><br><span class="line">         <span class="built_in">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">         <span class="comment">// 删除早期单例</span></span><br><span class="line">         <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">         <span class="comment">// 添加到已注册</span></span><br><span class="line">         <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="12-2-2-3-AbstractAutowireCapableBeanFactory-populateBean"><a href="#12-2-2-3-AbstractAutowireCapableBeanFactory-populateBean" class="headerlink" title="12.2.2.3 AbstractAutowireCapableBeanFactory#populateBean"></a>12.2.2.3 AbstractAutowireCapableBeanFactory#populateBean</h4><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">   <span class="comment">// 如果beanWrapper为空</span></span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果mbd有需要设置的属性</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">         <span class="comment">// 抛出bean创建异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="comment">// 没有可填充的属性，直接跳过</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">   <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">   <span class="comment">// to support styles of field injection.</span></span><br><span class="line">   <span class="comment">// 给任何实现了InstantiationAwareBeanPostProcessors的子类机会去修改bean的状态再设置属性之前，可以被用来支持类型的字段注入</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 否是&quot;synthetic&quot;。一般是指只有AOP相关的pointCut配置或者Advice配置才会将 synthetic设置为true</span></span><br><span class="line">   <span class="comment">// 如果mdb是不是&#x27;synthetic&#x27; 且 工厂拥有InstantiationAwareBeanPostProcessor</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="comment">// 遍历工厂中的BeanPostProcessor对象</span></span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="comment">// 如果 bp 是 InstantiationAwareBeanPostProcessor 实例</span></span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">// postProcessAfterInstantiation：一般用于设置属性</span></span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// PropertyValues：包含以一个或多个PropertyValue对象的容器，通常包括针对特定目标Bean的一次更新</span></span><br><span class="line">   <span class="comment">// 如果mdb有PropertyValues就获取其PropertyValues</span></span><br><span class="line">   <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取 mbd 的 自动装配模式</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">resolvedAutowireMode</span> <span class="operator">=</span> mbd.getResolvedAutowireMode();</span><br><span class="line">   <span class="comment">// 如果 自动装配模式 为 按名称自动装配bean属性 或者 按类型自动装配bean属性</span></span><br><span class="line">   <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      <span class="comment">// MutablePropertyValues：PropertyValues接口的默认实现。允许对属性进行简单操作，并提供构造函数来支持从映射 进行深度复制和构造</span></span><br><span class="line">      <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">      <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">      <span class="comment">// 根据autotowire的名称(如适用)添加属性值</span></span><br><span class="line">      <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         <span class="comment">// 通过bw的PropertyDescriptor属性名，查找出对应的Bean对象，将其添加到newPvs中</span></span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">      <span class="comment">// 根据自动装配的类型(如果适用)添加属性值</span></span><br><span class="line">      <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         <span class="comment">// 通过bw的PropertyDescriptor属性类型，查找出对应的Bean对象，将其添加到newPvs中</span></span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 让pvs重新引用newPvs,newPvs此时已经包含了pvs的属性值以及通过AUTOWIRE_BY_NAME，AUTOWIRE_BY_TYPE自动装配所得到的属性值</span></span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//工厂是否拥有InstantiationAwareBeanPostProcessor</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="comment">// mbd.getDependencyCheck()，默认返回 DEPENDENCY_CHECK_NONE，表示 不检查</span></span><br><span class="line">   <span class="comment">// 是否需要依赖检查</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 经过筛选的PropertyDescriptor数组,存放着排除忽略的依赖项或忽略项上的定义的属性</span></span><br><span class="line">   PropertyDescriptor[] filteredPds = <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 如果工厂拥有InstantiationAwareBeanPostProcessor,那么处理对应的流程，主要是对几个注解的赋值工作包含的两个关键子类是CommonAnnoationBeanPostProcessor,AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 尝试获取mbd的PropertyValues</span></span><br><span class="line">         pvs = mbd.getPropertyValues();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 遍历工厂内的所有后置处理器</span></span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="comment">// 如果 bp 是 InstantiationAwareBeanPostProcessor 的实例</span></span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="comment">// 将 bp 强转成 InstantiationAwareBeanPostProcessor 对象</span></span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">// postProcessProperties:在工厂将给定的属性值应用到给定Bean之前，对它们进行后处理，不需要任何属性扫描符。该回调方法在未来的版本会被删掉。</span></span><br><span class="line">            <span class="comment">// -- 取而代之的是 postProcessPropertyValues 回调方法。</span></span><br><span class="line">            <span class="comment">// 让ibp对pvs增加对bw的Bean对象的propertyValue，或编辑pvs的propertyValue</span></span><br><span class="line">            <span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// mbd.allowCaching:是否允许缓存，默认时允许的。缓存除了可以提高效率以外，还可以保证在并发的情况下，返回的PropertyDesciptor[]永远都是同一份</span></span><br><span class="line">                  <span class="comment">// 从bw提取一组经过筛选的PropertyDescriptor,排除忽略的依赖项或忽略项上的定义的属性</span></span><br><span class="line">                  filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// postProcessPropertyValues:一般进行检查是否所有依赖项都满足，例如基于&quot;Require&quot;注释在 bean属性 setter，</span></span><br><span class="line">               <span class="comment">//     -- 替换要应用的属性值，通常是通过基于原始的PropertyValues创建一个新的MutablePropertyValue实例， 添加或删除特定的值</span></span><br><span class="line">               <span class="comment">//     -- 返回的PropertyValues 将应用于bw包装的bean实例 的实际属性值（添加PropertyValues实例到pvs 或者 设置为null以跳过属性填充）</span></span><br><span class="line">               <span class="comment">// 回到ipd的postProcessPropertyValues方法</span></span><br><span class="line">               pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="comment">// 如果pvsToUse为null，将终止该方法精致，以跳过属性填充</span></span><br><span class="line">               <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 让pvs引用pvsToUse</span></span><br><span class="line">            pvs = pvsToUse;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果需要依赖检查</span></span><br><span class="line">   <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">      <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 从bw提取一组经过筛选的PropertyDescriptor,排除忽略的依赖项或忽略项上的定义的属性</span></span><br><span class="line">         filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查依赖项：主要检查pd的setter方法需要赋值时,pvs中有没有满足其pd的需求的属性值可供其赋值</span></span><br><span class="line">      checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 应用给定的属性值，解决任何在这个bean工厂运行时其他bean的引用。必须使用深拷贝，所以我们 不会永久地修改这个属性</span></span><br><span class="line">      applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="12-2-2-3-1-AbstractAutowireCapableBeanFactory-autowireByName"><a href="#12-2-2-3-1-AbstractAutowireCapableBeanFactory-autowireByName" class="headerlink" title="12.2.2.3.1 AbstractAutowireCapableBeanFactory#autowireByName"></a>12.2.2.3.1 AbstractAutowireCapableBeanFactory#autowireByName</h5><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#autowireByName</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">autowireByName</span><span class="params">(</span></span><br><span class="line"><span class="params">      String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取bw中有setter方法 &amp;&amp; 非简单类型属性 &amp;&amp; mbd的PropertyValues中没有该pd的属性名的 PropertyDescriptor 属性名数组</span></span><br><span class="line">   String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">   <span class="comment">// 遍历属性名</span></span><br><span class="line">   <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">      <span class="comment">// 如果该bean工厂有propertyName的beanDefinition或外部注册的singleton实例</span></span><br><span class="line">      <span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line">         <span class="comment">// 获取该工厂中propertyName的bean对象</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(propertyName);</span><br><span class="line">         <span class="comment">// 将propertyName,bean添加到pvs中</span></span><br><span class="line">         pvs.add(propertyName, bean);</span><br><span class="line">         <span class="comment">// 注册propertyName与beanName的依赖关系</span></span><br><span class="line">         registerDependentBean(propertyName, beanName);</span><br><span class="line">         <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Added autowiring by name from bean name &#x27;&quot;</span> + beanName +</span><br><span class="line">                  <span class="string">&quot;&#x27; via property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Not autowiring property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; of bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                  <span class="string">&quot;&#x27; by name: no matching bean found&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="12-2-2-3-2-AbstractAutowireCapableBeanFactory-autowireByType"><a href="#12-2-2-3-2-AbstractAutowireCapableBeanFactory-autowireByType" class="headerlink" title="12.2.2.3.2 AbstractAutowireCapableBeanFactory#autowireByType"></a>12.2.2.3.2 AbstractAutowireCapableBeanFactory#autowireByType</h5><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#autowireByType</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">autowireByType</span><span class="params">(</span></span><br><span class="line"><span class="params">      String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取工厂的自定义类型转换器</span></span><br><span class="line">   <span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getCustomTypeConverter();</span><br><span class="line">   <span class="comment">// 如果没有配置自定义类型转换器</span></span><br><span class="line">   <span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 使用bw作为类型转换器</span></span><br><span class="line">      converter = bw;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 存放所有候选Bean名的集合</span></span><br><span class="line">   Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">   <span class="comment">// 获取bw中有setter方法 &amp;&amp; 非简单类型属性 &amp;&amp; mbd的PropertyValues中没有该pd的属性名的 PropertyDescriptor 属性名数组</span></span><br><span class="line">   String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">   <span class="comment">// 遍历属性名数组</span></span><br><span class="line">   <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// PropertyDescriptor:表示JavaBean类通过存储器导出一个属性</span></span><br><span class="line">         <span class="comment">// 从bw中获取propertyName对应的PropertyDescriptor</span></span><br><span class="line">         <span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> bw.getPropertyDescriptor(propertyName);</span><br><span class="line">         <span class="comment">// Don&#x27;t try autowiring by type for type Object: never makes sense,</span></span><br><span class="line">         <span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line">         <span class="comment">// 不要尝试按类型自动装配对象：永远是有意义的，即使它在技术上是一个不满意，复杂属性</span></span><br><span class="line">         <span class="comment">// 如果pd的属性值类型不是 Object</span></span><br><span class="line">         <span class="keyword">if</span> (Object.class != pd.getPropertyType()) &#123;</span><br><span class="line">            <span class="comment">// 获取pd属性的Setter方法的方法参数包装对象</span></span><br><span class="line">            <span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">            <span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line">            <span class="comment">// 判断bean对象是否是PriorityOrder实例，如果不是就允许急于初始化来进行类型匹配。</span></span><br><span class="line">            <span class="comment">// eager为true时会导致初始化lazy-init单例和由FactoryBeans(或带有&quot;factory-bean&quot;引用的工厂方法)创建 的对象以进行类型检查</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">eager</span> <span class="operator">=</span> !PriorityOrdered.class.isInstance(bw.getWrappedInstance());</span><br><span class="line">            <span class="comment">// AutowireByTypeDependencyDescriptor:根据类型依赖自动注入的描述符，重写了 getDependencyName() 方法，使其永远返回null</span></span><br><span class="line">            <span class="comment">// 将 methodParam 封装包装成AutowireByTypeDependencyDescriptor对象</span></span><br><span class="line">            <span class="type">DependencyDescriptor</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowireByTypeDependencyDescriptor</span>(methodParam, eager);</span><br><span class="line">            <span class="comment">// 根据据desc的依赖类型解析出与descriptor所包装的对象匹配的候选Bean对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">autowiredArgument</span> <span class="operator">=</span> resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">            <span class="comment">// 如果autowiredArgument不为null</span></span><br><span class="line">            <span class="keyword">if</span> (autowiredArgument != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 将propertyName.autowiredArgument作为键值添加到pvs中</span></span><br><span class="line">               pvs.add(propertyName, autowiredArgument);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历所有候选Bean名集合</span></span><br><span class="line">            <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">               <span class="comment">// 注册beanName与dependentBeanNamed的依赖关系</span></span><br><span class="line">               registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">               <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                  logger.trace(<span class="string">&quot;Autowiring by type from bean name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; via property &#x27;&quot;</span> +</span><br><span class="line">                        propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + autowiredBeanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将候选Bean名集合清空</span></span><br><span class="line">            autowiredBeanNames.clear();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="comment">// 捕捉自动装配时抛出的Bean异常，重新抛出 不满足依赖异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedDependencyException</span>(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="12-2-2-3-3-AbstractAutowireCapableBeanFactory-applyPropertyValues"><a href="#12-2-2-3-3-AbstractAutowireCapableBeanFactory-applyPropertyValues" class="headerlink" title="12.2.2.3.3 AbstractAutowireCapableBeanFactory#applyPropertyValues"></a>12.2.2.3.3 AbstractAutowireCapableBeanFactory#applyPropertyValues</h5><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyPropertyValues</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果有安全管理器，且bw是BeanWrapperImpl的实例</span></span><br><span class="line">   <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">      <span class="comment">// 设置bw的安全上下文为工厂的访问控制上下文</span></span><br><span class="line">      ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// MutablePropertyValues：PropertyValues接口的默认实现。</span></span><br><span class="line">   <span class="comment">// 允许对属性进行简单操作，并提供构造函数来支持从映射 进行深度复制和构造</span></span><br><span class="line">   <span class="type">MutablePropertyValues</span> <span class="variable">mpvs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 原始属性列表</span></span><br><span class="line">   List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果pvs是MutablePropertyValues</span></span><br><span class="line">   <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">      <span class="comment">// 类型强制转换</span></span><br><span class="line">      mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">      <span class="comment">// isConverted:返回该holder是否只包含转换后的值(true),或者是否仍然需要转换这些值</span></span><br><span class="line">      <span class="comment">// 如果mpvs只包含转换后的值</span></span><br><span class="line">      <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">         <span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 已完成，直接返回</span></span><br><span class="line">            bw.setPropertyValues(mpvs);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">//捕捉Bean异常，重新抛出Bean创佳异常：错误设置属性值。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                  mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取mpvs的PropertyValue列表</span></span><br><span class="line">      original = mpvs.getPropertyValueList();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 获取pvs的PropertyValue对象数组，并将其转换成列表</span></span><br><span class="line">      original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取用户自定义类型转换器</span></span><br><span class="line">   <span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getCustomTypeConverter();</span><br><span class="line">   <span class="comment">// 如果转换器为空，则直接把包装类赋值给converter</span></span><br><span class="line">   <span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">      converter = bw;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// BeanDefinitionValueResolver:在bean工厂实现中使用Helper类，它将beanDefinition对象中包含的值解析为应用于 目标bean实例的实际值</span></span><br><span class="line">   <span class="type">BeanDefinitionValueResolver</span> <span class="variable">valueResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionValueResolver</span>(<span class="built_in">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">   <span class="comment">// 创建一个深拷贝，解析任何值引用</span></span><br><span class="line">   List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(original.size());</span><br><span class="line">   <span class="comment">//是否还需要解析标记</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">resolveNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">// 遍历属性，将属性转换为对应类的对应属性的类型</span></span><br><span class="line">   <span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">      <span class="comment">// 如果该属性已经解析过</span></span><br><span class="line">      <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">         <span class="comment">// 将pv添加到deepCopy中</span></span><br><span class="line">         deepCopy.add(pv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果属性没有被解析过</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 获取属性的名字</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> pv.getName();</span><br><span class="line">         <span class="comment">// 获取未经类型转换的值</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">originalValue</span> <span class="operator">=</span> pv.getValue();</span><br><span class="line">         <span class="comment">// AutowiredPropertyMarker.INSTANCE：自动生成标记的规范实例</span></span><br><span class="line">         <span class="keyword">if</span> (originalValue == AutowiredPropertyMarker.INSTANCE) &#123;</span><br><span class="line">            <span class="comment">// 获取propertyName在bw中的setter方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">writeMethod</span> <span class="operator">=</span> bw.getPropertyDescriptor(propertyName).getWriteMethod();</span><br><span class="line">            <span class="comment">// 如果setter方法为null</span></span><br><span class="line">            <span class="keyword">if</span> (writeMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 抛出非法参数异常：自动装配标记属性没有写方法。</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Autowire marker for property without write method: &quot;</span> + pv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将writerMethod封装到DependencyDescriptor对象</span></span><br><span class="line">            originalValue = <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(writeMethod, <span class="number">0</span>), <span class="literal">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 交由valueResolver根据pv解析出originalValue所封装的对象</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">resolvedValue</span> <span class="operator">=</span> valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">         <span class="comment">// 默认转换后的值是刚解析出来的值</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">convertedValue</span> <span class="operator">=</span> resolvedValue;</span><br><span class="line">         <span class="comment">// 可转换标记: propertyName是否bw中的可写属性 &amp;&amp; prepertyName不是表示索引属性或嵌套属性（如果propertyName中有&#x27;.&#x27;||&#x27;[&#x27;就认为是索引属性或嵌套属性）</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">convertible</span> <span class="operator">=</span> bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">               !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">         <span class="comment">// 如果可转换</span></span><br><span class="line">         <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">            <span class="comment">// 将resolvedValue转换为指定的目标属性对象</span></span><br><span class="line">            convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Possibly store converted value in merged bean definition,</span></span><br><span class="line">         <span class="comment">// in order to avoid re-conversion for every created bean instance.</span></span><br><span class="line">         <span class="comment">// 可以将转换后的值存储合并后BeanDefinition中，以避免对每个创建的Bean实例进行重新转换</span></span><br><span class="line">         <span class="comment">// 如果resolvedValue与originalValue是同一个对象</span></span><br><span class="line">         <span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">            <span class="comment">// 如果可转换</span></span><br><span class="line">            <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">               <span class="comment">// 将convertedValue设置到pv中</span></span><br><span class="line">               pv.setConvertedValue(convertedValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将pv添加到deepCopy中</span></span><br><span class="line">            deepCopy.add(pv);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// TypedStringValue:类型字符串的Holder,这个holder将只存储字符串值和目标类型。实际得转换将由Bean工厂执行</span></span><br><span class="line">         <span class="comment">// 如果可转换 &amp;&amp; originalValue是TypedStringValue的实例 &amp;&amp; orginalValue不是标记为动态【即不是一个表达式】&amp;&amp;</span></span><br><span class="line">         <span class="comment">//     convertedValue不是Collection对象 或 数组</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">               !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">               !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">            <span class="comment">// 将convertedValue设置到pv中</span></span><br><span class="line">            pv.setConvertedValue(convertedValue);</span><br><span class="line">            <span class="comment">// 将pv添加到deepCopy中</span></span><br><span class="line">            deepCopy.add(pv);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 标记还需要解析</span></span><br><span class="line">            resolveNecessary = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 根据pv,convertedValue构建PropertyValue对象，并添加到deepCopy中</span></span><br><span class="line">            deepCopy.add(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(pv, convertedValue));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// mpvs不为null &amp;&amp; 已经不需要解析</span></span><br><span class="line">   <span class="keyword">if</span> (mpvs != <span class="literal">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">      <span class="comment">// 将此holder标记为只包含转换后的值</span></span><br><span class="line">      mpvs.setConverted();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set our (possibly massaged) deep copy.</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 按原样使用deepCopy构造一个新的MutablePropertyValues对象然后设置到bw中以对bw的属性值更新</span></span><br><span class="line">      bw.setPropertyValues(<span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(deepCopy));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-2-2-4-AbstractAutowireCapableBeanFactory-initializeBean"><a href="#12-2-2-4-AbstractAutowireCapableBeanFactory-initializeBean" class="headerlink" title="12.2.2.4 AbstractAutowireCapableBeanFactory#initializeBean"></a>12.2.2.4 AbstractAutowireCapableBeanFactory#initializeBean</h4><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">   <span class="comment">// Aware接口处理器, 调用 BeanNameAware#setBeanName、BeanClassLoaderAware#setBeanClassLoader、BeanFactoryAware#setBeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 以特权的方式执行回调bean中的Aware接口方法</span></span><br><span class="line">      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">         invokeAwareMethods(beanName, bean);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">   <span class="comment">// 如果mdb不为null || mbd不是&quot;synthetic&quot;。一般是指只有AOP相关的prointCut配置或者Advice配置才会将 synthetic设置为true</span></span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// 将BeanPostProcessors应用到给定的现有Bean实例，调用它们的postProcessBeforeInitialization初始化方法。</span></span><br><span class="line">      <span class="comment">// 返回的Bean实例可能是原始Bean包装器</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 InitializingBean#afterPropertiesSet</span></span><br><span class="line">   <span class="comment">// 反射调用配置的 initMethod 方法</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用初始化方法，先调用bean的InitializingBean接口方法，后调用bean的自定义初始化方法</span></span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            (mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">            beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 调用 BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// 将BeanPostProcessors应用到给定的现有Bean实例，调用它们的postProcessAfterInitialization方法。</span></span><br><span class="line">      <span class="comment">// 返回的Bean实例可能是原始Bean包装器</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回包装后的Bean</span></span><br><span class="line">   <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="12-2-2-4-1-AbstractAutowireCapableBeanFactory-invokeAwareMethods"><a href="#12-2-2-4-1-AbstractAutowireCapableBeanFactory-invokeAwareMethods" class="headerlink" title="12.2.2.4.1 AbstractAutowireCapableBeanFactory#invokeAwareMethods"></a>12.2.2.4.1 AbstractAutowireCapableBeanFactory#invokeAwareMethods</h5><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeAwareMethods</p>
</blockquote>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">private void invokeAwareMethods(final String <span class="keyword">beanName, </span>final Object <span class="keyword">bean) </span>&#123;</span><br><span class="line">   if (<span class="keyword">bean </span><span class="keyword">instanceof </span>Aware) &#123;</span><br><span class="line">      if (<span class="keyword">bean </span><span class="keyword">instanceof </span><span class="keyword">BeanNameAware) </span>&#123;</span><br><span class="line">         ((<span class="keyword">BeanNameAware) </span><span class="keyword">bean).setBeanName(beanName);</span></span><br><span class="line"><span class="keyword"></span>      &#125;</span><br><span class="line">      if (<span class="keyword">bean </span><span class="keyword">instanceof </span><span class="keyword">BeanClassLoaderAware) </span>&#123;</span><br><span class="line">         ClassLoader <span class="keyword">bcl </span>= getBeanClassLoader();</span><br><span class="line">         if (<span class="keyword">bcl </span>!= null) &#123;</span><br><span class="line">            ((<span class="keyword">BeanClassLoaderAware) </span><span class="keyword">bean).setBeanClassLoader(bcl);</span></span><br><span class="line"><span class="keyword"></span>         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (<span class="keyword">bean </span><span class="keyword">instanceof </span><span class="keyword">BeanFactoryAware) </span>&#123;</span><br><span class="line">         ((<span class="keyword">BeanFactoryAware) </span><span class="keyword">bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</span></span><br><span class="line"><span class="keyword"></span>      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="12-2-2-4-2-AbstractAutowireCapableBeanFactory-applyBeanPostProcessorsBeforeInitialization"><a href="#12-2-2-4-2-AbstractAutowireCapableBeanFactory-applyBeanPostProcessorsBeforeInitialization" class="headerlink" title="12.2.2.4.2 AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization"></a>12.2.2.4.2 AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</h5><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化返回结果为existingBean</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line">   <span class="comment">// 遍历该工厂创建的bean的BeanPostProcessors列表</span></span><br><span class="line">   <span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="comment">// postProcessBeforeInitialization：在任何Bean初始化回调之前(如初始化Bean的afterPropertiesSet或自定义的init方法)</span></span><br><span class="line">      <span class="comment">// 将此BeanPostProcessor 应用到给定的新Bean实例。Bean已经填充了属性值。返回的Bean实例可能时原始Bean的包装器。</span></span><br><span class="line">      <span class="comment">// 默认实现按原样返回给定的 Bean</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">current</span> <span class="operator">=</span> processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 直接返回result，中断其后续的BeanPostProcessor处理</span></span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 让result引用processor的返回结果,使其经过所有BeanPostProcess对象的后置处理的层层包装</span></span><br><span class="line">      result = current;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回经过所有BeanPostProcess对象的后置处理的层层包装后的result</span></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="12-2-2-4-2-AbstractAutowireCapableBeanFactory-invokeInitMethods"><a href="#12-2-2-4-2-AbstractAutowireCapableBeanFactory-invokeInitMethods" class="headerlink" title="12.2.2.4.2 AbstractAutowireCapableBeanFactory#invokeInitMethods"></a>12.2.2.4.2 AbstractAutowireCapableBeanFactory#invokeInitMethods</h5><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span><br><span class="line">      <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// isInitializingBean:当Bean的所有属性都被BeanFactory设置好后，Bean需要执行相应的接口：例如执行自定义初始化，或者仅仅是检查所有强制属性是否已经设置好。</span></span><br><span class="line">   <span class="comment">// bean是InitializingBean实例标记</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isInitializingBean</span> <span class="operator">=</span> (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">   <span class="comment">// isExternallyManagedInitMethod是否外部受管理的Init方法名</span></span><br><span class="line">   <span class="comment">// 如果 bean是InitializingBean实例 &amp;&amp; (mdb为null || &#x27;afterPropertiesSet&#x27; 不是外部受管理的Init方法名)</span></span><br><span class="line">   <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="literal">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 以特权方式调用 bean的 afterPropertiesSet 方法</span></span><br><span class="line">            AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">            <span class="keyword">throw</span> pae.getException();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 调用 bean 的 afterPropertiesSet 方法</span></span><br><span class="line">         ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果mbd不为null &amp;&amp; bean不是NullBean类</span></span><br><span class="line">   <span class="keyword">if</span> (mbd != <span class="literal">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">      <span class="comment">// 获取mbd指定的初始化方法名</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">initMethodName</span> <span class="operator">=</span> mbd.getInitMethodName();</span><br><span class="line">      <span class="comment">// 如果initMethodName不为null &amp;&amp; (bean不是InitializingBean实例 &amp;&amp; &#x27;afterPropertiesSet&#x27;是初始化方法名）</span></span><br><span class="line">      <span class="comment">// &amp;&amp; initMethodName不是外部受管理的Init方法名</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">            !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">            !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">         <span class="comment">// 在bean上调用指定的自定义init方法</span></span><br><span class="line">         invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeCustomInitMethod</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span></span><br><span class="line">		<span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取初始化方法名称</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">initMethodName</span> <span class="operator">=</span> mbd.getInitMethodName();</span><br><span class="line">	Assert.state(initMethodName != <span class="literal">null</span>, <span class="string">&quot;No init method set&quot;</span>);</span><br><span class="line">	<span class="comment">// 获取初始化方法</span></span><br><span class="line">	<span class="type">Method</span> <span class="variable">initMethod</span> <span class="operator">=</span> (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">			BeanUtils.findMethod(bean.getClass(), initMethodName) :</span><br><span class="line">			ClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mbd.isEnforceInitMethod()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionValidationException</span>(<span class="string">&quot;Could not find an init method named &#x27;&quot;</span> +</span><br><span class="line">					initMethodName + <span class="string">&quot;&#x27; on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;No default init method named &#x27;&quot;</span> + initMethodName +</span><br><span class="line">						<span class="string">&quot;&#x27; found on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Ignore non-existent default lifecycle methods.</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Invoking init method  &#x27;&quot;</span> + initMethodName + <span class="string">&quot;&#x27; on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Method</span> <span class="variable">methodToInvoke</span> <span class="operator">=</span> ClassUtils.getInterfaceMethodIfPossible(initMethod);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">		AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">			ReflectionUtils.makeAccessible(methodToInvoke);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt;</span><br><span class="line">					methodToInvoke.invoke(bean), getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">			<span class="type">InvocationTargetException</span> <span class="variable">ex</span> <span class="operator">=</span> (InvocationTargetException) pae.getException();</span><br><span class="line">			<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ReflectionUtils.makeAccessible(methodToInvoke);</span><br><span class="line">			<span class="comment">// 反射执行</span></span><br><span class="line">			methodToInvoke.invoke(bean);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-2-2-4-3-AbstractAutowireCapableBeanFactory-applyBeanPostProcessorsAfterInitialization"><a href="#12-2-2-4-3-AbstractAutowireCapableBeanFactory-applyBeanPostProcessorsAfterInitialization" class="headerlink" title="12.2.2.4.3 AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization"></a>12.2.2.4.3 AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization</h5><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化结果对象为result，默认引用existingBean</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line">   <span class="comment">// 遍历该工厂创建的bean的BeanPostProcessors列表</span></span><br><span class="line">   <span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="comment">// 回调BeanPostProcessor#postProcessAfterInitialization来对现有的bean实例进行包装</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">current</span> <span class="operator">=</span> processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">      <span class="comment">// 一般processor对不感兴趣的bean会回调直接返回result，使其能继续回调后续的BeanPostProcessor；</span></span><br><span class="line">      <span class="comment">// 但有些processor会返回null来中断其后续的BeanPostProcessor</span></span><br><span class="line">      <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 如果current为null，直接返回result，中断其后续的BeanPostProcessor处理</span></span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 让result引用processor的返回结果,使其经过所有BeanPostProcess对象的后置处理的层层包装</span></span><br><span class="line">      result = current;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回经过所有BeanPostProcess对象的后置处理的层层包装后的result</span></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-2-2-5-AbstractAutowireCapableBeanFactory-registerDisposableBeanIfNecessary"><a href="#12-2-2-5-AbstractAutowireCapableBeanFactory-registerDisposableBeanIfNecessary" class="headerlink" title="12.2.2.5 AbstractAutowireCapableBeanFactory#registerDisposableBeanIfNecessary"></a>12.2.2.5 AbstractAutowireCapableBeanFactory#registerDisposableBeanIfNecessary</h4><blockquote>
<p>**定位: ** org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#registerDisposableBeanIfNecessary</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerDisposableBeanIfNecessary</span><span class="params">(String beanName, Object bean, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">   <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> (System.getSecurityManager() != <span class="literal">null</span> ? getAccessControlContext() : <span class="literal">null</span>);</span><br><span class="line">   <span class="comment">// 有销毁接口</span></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) &#123;</span><br><span class="line">      <span class="comment">// 单例的情况，注册销毁回调</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">         <span class="comment">// Register a DisposableBean implementation that performs all destruction</span></span><br><span class="line">         <span class="comment">// work for the given bean: DestructionAwareBeanPostProcessors,</span></span><br><span class="line">         <span class="comment">// DisposableBean interface, custom destroy method.</span></span><br><span class="line">         registerDisposableBean(beanName,</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">DisposableBeanAdapter</span>(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// A bean with a custom scope...</span></span><br><span class="line">         <span class="comment">// 自定义的，注册Scope</span></span><br><span class="line">         <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(mbd.getScope());</span><br><span class="line">         <span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + mbd.getScope() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         scope.registerDestructionCallback(beanName,</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">DisposableBeanAdapter</span>(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(14) 完成后清理</title>
    <url>/2020/10/25/spring/Spring15/</url>
    <content><![CDATA[<h2 id="14-AbstractApplicationContext-destroyBeans"><a href="#14-AbstractApplicationContext-destroyBeans" class="headerlink" title="14 AbstractApplicationContext#destroyBeans"></a>14 AbstractApplicationContext#destroyBeans</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#destroyBeans</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">destroyBeans</span><span class="params">()</span> &#123;</span><br><span class="line">   getBeanFactory().destroySingletons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroySingletons</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.destroySingletons();</span><br><span class="line">    updateManualSingletonNames(Set::clear, set -&gt; !set.isEmpty());</span><br><span class="line">    clearByTypeCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-AbstractApplicationContext-cancelRefresh"><a href="#15-AbstractApplicationContext-cancelRefresh" class="headerlink" title="15 AbstractApplicationContext#cancelRefresh"></a>15 AbstractApplicationContext#cancelRefresh</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#cancelRefresh</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cancelRefresh</span>(<span class="params">BeansException ex</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">this</span>.active.<span class="keyword">set</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="16-AbstractApplicationContext-resetCommonCaches"><a href="#16-AbstractApplicationContext-resetCommonCaches" class="headerlink" title="16 AbstractApplicationContext#resetCommonCaches"></a>16 AbstractApplicationContext#resetCommonCaches</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#resetCommonCaches</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">resetCommonCaches</span><span class="params">()</span> &#123;</span><br><span class="line">   ReflectionUtils.clearCache();</span><br><span class="line">   AnnotationUtils.clearCache();</span><br><span class="line">   ResolvableType.clearCache();</span><br><span class="line">   CachedIntrospectionResults.clearClassLoader(getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法 常用扩展点接口</title>
    <url>/2020/10/25/spring/Spring16/</url>
    <content><![CDATA[<h2 id="1-核心接口-BeanPostProcessor"><a href="#1-核心接口-BeanPostProcessor" class="headerlink" title="1. 核心接口 BeanPostProcessor"></a>1. 核心接口 BeanPostProcessor</h2>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-常用接口"><a href="#1-2-常用接口" class="headerlink" title="1.2 常用接口"></a>1.2 常用接口</h3><h4 id="1-2-1-BeanDefinitionRegistryPostProcessor"><a href="#1-2-1-BeanDefinitionRegistryPostProcessor" class="headerlink" title="1.2.1 BeanDefinitionRegistryPostProcessor"></a>1.2.1 BeanDefinitionRegistryPostProcessor</h4><p><strong>调用方法</strong>: PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</p>
<p><strong>时机</strong>: <code>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry</code> 会优先于 <code>BeanPostProcessor #postProcessBeanFactory</code> 方法的执行</p>
<p><strong>作用</strong>: 所有 BeanDefinition 加载完成之后, 提供增删改查 BeanDefinitionRegistry (注册表) 的埋点</p>
<h3 id="1-3-常用实现类"><a href="#1-3-常用实现类" class="headerlink" title="1.3 常用实现类"></a>1.3 常用实现类</h3><h4 id="1-3-1-ConfigurationClassPostProcessor"><a href="#1-3-1-ConfigurationClassPostProcessor" class="headerlink" title="1.3.1 ConfigurationClassPostProcessor"></a>1.3.1 ConfigurationClassPostProcessor</h4><p><strong>作用</strong>: 它是用来解析配置类的,  可解析类注解 @Configuration, @CompentScan 等</p>
<h2 id="2-核心接口-BeanPostProcessor"><a href="#2-核心接口-BeanPostProcessor" class="headerlink" title="2. 核心接口 BeanPostProcessor"></a>2. 核心接口 BeanPostProcessor</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">default</span> <span class="built_in">Object</span> <span class="title function_">postProcessBeforeInitialization</span>(<span class="built_in">Object</span> bean, <span class="built_in">String</span> beanName) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">default</span> <span class="built_in">Object</span> <span class="title function_">postProcessAfterInitialization</span>(<span class="built_in">Object</span> bean, <span class="built_in">String</span> beanName) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-常用接口"><a href="#2-2-常用接口" class="headerlink" title="2.2 常用接口"></a>2.2 常用接口</h3><ol>
<li>SmartInstantiationAwareBeanPostProcessor</li>
<li>MergedBeanDefinitionPostProcessor</li>
<li>InstantiationAwareBeanPostProcessor</li>
<li>DestructionAwareBeanPostProcessor</li>
</ol>
<h3 id="2-3-常用接口执行顺序"><a href="#2-3-常用接口执行顺序" class="headerlink" title="2.3 常用接口执行顺序"></a>2.3 常用接口执行顺序</h3><h5 id="2-3-1-InstantiationAwareBeanPostProcessor-postProcessBeforeInstantiation"><a href="#2-3-1-InstantiationAwareBeanPostProcessor-postProcessBeforeInstantiation" class="headerlink" title="2.3.1 InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation"></a>2.3.1 InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</h5><p><strong>调用方法</strong>:<code>AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation ===&gt;&gt;&gt; #applyBeanPostProcessorsBeforeInstantiation</code></p>
<p><strong>作用</strong>: 在实例化目标 bean 之前调用这个 BeanPostProcessor。返回的 bean 对象可以是一个代理来代替目标 bean，有效地抑制了目标 bean 的默认实例化。</p>
<h5 id="2-3-2-SmartInstantiationAwareBeanPostProcessor-determineCandidateConstructors"><a href="#2-3-2-SmartInstantiationAwareBeanPostProcessor-determineCandidateConstructors" class="headerlink" title="2.3.2 SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors"></a>2.3.2 SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors</h5><p><strong>调用方法</strong>:<code>AbstractAutowireCapableBeanFactory#determineConstructorsFromBeanPostProcessors</code></p>
<p><strong>作用</strong>: 检测Bean的构造器，可以检测出多个候选构造器，再有相应的策略决定使用哪一个，如AutowiredAnnotationBeanPostProcessor实现将自动扫描通过@Autowired/@Value注解的构造器从而可以完成构造器注入</p>
<h5 id="2-3-3-MergedBeanDefinitionPostProcessor-postProcessMergedBeanDefinition"><a href="#2-3-3-MergedBeanDefinitionPostProcessor-postProcessMergedBeanDefinition" class="headerlink" title="2.3.3 MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition"></a>2.3.3 MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition</h5><p><strong>调用方法</strong>: <code>AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors</code></p>
<p><strong>作用</strong>: 在Bean实例化完毕后调用 可以用来修改Merged BeanDefinition的一些properties 或者用来给后续回调中缓存一些meta信息, 这是将Merged BeanDefinition暴露出来的一个回调</p>
<h5 id="2-3-4-SmartInstantiationAwareBeanPostProcessor-getEarlyBeanReference"><a href="#2-3-4-SmartInstantiationAwareBeanPostProcessor-getEarlyBeanReference" class="headerlink" title="2.3.4 SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference"></a>2.3.4 SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference</h5><p><strong>调用方法</strong>: <code>AbstractAutowireCapableBeanFactory#getEarlyBeanReference</code></p>
<p><strong>作用</strong>: 获取早期访问指定 bean 的引用，通常用于解析循环引用。此回调使后处理器有机会尽早公开包装实例，即在目标 bean 实例完全初始化之前。</p>
<h5 id="2-3-5-InstantiationAwareBeanPostProcessor-postProcessAfterInstantiation"><a href="#2-3-5-InstantiationAwareBeanPostProcessor-postProcessAfterInstantiation" class="headerlink" title="2.3.5 InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation"></a>2.3.5 InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</h5><p><strong>调用方法</strong>: <code>AbstractAutowireCapableBeanFactory#populateBean</code></p>
<p><strong>作用</strong>:  在 bean 实例化之后，通过构造函数或工厂方法，但在 Spring 属性填充（从显式属性或自动连接）发生之前，执行操作。这是在 Spring 的自动注入开始之前，在给定 bean 实例上执行<strong>自定义字段注入</strong>的回调。返回值可以终止属性填充。</p>
<h5 id="2-3-6-InstantiationAwareBeanPostProcessor-postProcessProperties"><a href="#2-3-6-InstantiationAwareBeanPostProcessor-postProcessProperties" class="headerlink" title="2.3.6 InstantiationAwareBeanPostProcessor#postProcessProperties"></a>2.3.6 InstantiationAwareBeanPostProcessor#postProcessProperties</h5><p><strong>调用方法</strong>: <code>AbstractAutowireCapableBeanFactory#populateBean</code></p>
<p><strong>作用</strong>:  在工厂将给定的属性值赋值到 bean 实例之前，对其进行后处理，而不需要任何属性描述符。</p>
<h5 id="2-3-7-BeanPostProcessor-postProcessBeforeInitialization"><a href="#2-3-7-BeanPostProcessor-postProcessBeforeInitialization" class="headerlink" title="2.3.7 BeanPostProcessor#postProcessBeforeInitialization"></a>2.3.7 BeanPostProcessor#postProcessBeforeInitialization</h5><p><strong>调用方法</strong>: <code>AbstractAutowireCapableBeanFactory#initializeBean  ===&gt;&gt;&gt; #applyBeanPostProcessorsBeforeInitialization</code></p>
<p><strong>作用</strong>:  在任何 bean 初始化回调（如InitializingBean的AfterPropertieSet或自定义init方法）<strong>之前</strong>，将此BeanPostProcessor应用于给定的新bean实例。</p>
<h5 id="2-3-8-InitializingBean-afterPropertiesSet"><a href="#2-3-8-InitializingBean-afterPropertiesSet" class="headerlink" title="2.3.8 InitializingBean#afterPropertiesSet"></a>2.3.8 InitializingBean#afterPropertiesSet</h5><p><strong>调用方法</strong>: <code>AbstractAutowireCapableBeanFactory#invokeInitMethods</code></p>
<p><strong>作用</strong>:  bean 的初始化方法, 执行完成之后才会执行 自定义的 init 方法</p>
<h5 id="2-3-9-BeanPostProcessor-postProcessAfterInitialization"><a href="#2-3-9-BeanPostProcessor-postProcessAfterInitialization" class="headerlink" title="2.3.9 BeanPostProcessor#postProcessAfterInitialization"></a>2.3.9 BeanPostProcessor#postProcessAfterInitialization</h5><p><strong>调用方法</strong>: <code>AbstractAutowireCapableBeanFactory#initializeBean ===&gt;&gt;&gt; #applyBeanPostProcessorsAfterInitialization</code></p>
<p><strong>作用</strong>:  在任何bean初始化回调（如InitializingBean的AfterPropertieSet或自定义init方法）<strong>之后</strong>，将此BeanPostProcessor应用于给定的新bean实例。</p>
<h5 id="2-3-10-DestructionAwareBeanPostProcessor-postProcessBeforeDestruction"><a href="#2-3-10-DestructionAwareBeanPostProcessor-postProcessBeforeDestruction" class="headerlink" title="2.3.10 DestructionAwareBeanPostProcessor#postProcessBeforeDestruction"></a>2.3.10 DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</h5><p><strong>调用方法</strong>: <code>AbstractAutowireCapableBeanFactory#destroyBean ===&gt;&gt;&gt; DisposableBeanAdapter#destroy</code></p>
<p><strong>作用</strong>:  在给定bean实例被销毁之前，将此BeanPostProcessor应用于该实例，例如调用自定义销毁回调。与DisposableBean的destroy和自定义destroy方法一样，此回调将仅适用于容器完全管理其生命周期的bean。单例bean和作用域bean通常都是这样。</p>
<h5 id="2-3-10-DisposableBean-destroy"><a href="#2-3-10-DisposableBean-destroy" class="headerlink" title="2.3.10 DisposableBean#destroy"></a>2.3.10 DisposableBean#destroy</h5><p><strong>调用方法</strong>: <code>AbstractAutowireCapableBeanFactory#destroyBean ===&gt;&gt;&gt; DisposableBeanAdapter#destroy</code></p>
<p><strong>作用</strong>:  bean 的销毁方法, 执行完成之后才会执行自定义的 destroy 方法</p>
<h3 id="2-4-接口无执行顺序"><a href="#2-4-接口无执行顺序" class="headerlink" title="2.4 接口无执行顺序"></a>2.4 接口无执行顺序</h3><h5 id="2-4-1-SmartInstantiationAwareBeanPostProcessor-predictBeanType"><a href="#2-4-1-SmartInstantiationAwareBeanPostProcessor-predictBeanType" class="headerlink" title="2.4.1 SmartInstantiationAwareBeanPostProcessor#predictBeanType"></a>2.4.1 SmartInstantiationAwareBeanPostProcessor#predictBeanType</h5><p><strong>调用方法</strong>: <code>AbstractAutowireCapableBeanFactory#predictBeanType</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext#refresh</span></span><br><span class="line"><span class="comment">//   ==&gt; AbstractApplicationContext#registerListeners</span></span><br><span class="line"><span class="comment">//         ==&gt; AbstractApplicationContext#getBeanNamesForType</span></span><br><span class="line"><span class="comment">//               ==&gt;  DefaultListableBeanFactory#doGetBeanNamesForType</span></span><br><span class="line"><span class="comment">//                      ==&gt; AbstractAutowireCapableBeanFactory#predictBeanType</span></span><br><span class="line"><span class="comment">// 被此逻辑触发</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>:  用来预判类型的</p>
<h2 id="3-接口-SmartInitializingSingleton"><a href="#3-接口-SmartInitializingSingleton" class="headerlink" title="3. 接口 SmartInitializingSingleton"></a>3. 接口 SmartInitializingSingleton</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmartInitializingSingleton</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">afterSingletonsInstantiated</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-org-springframework-beans-factory-SmartInitializingSingleton"><a href="#3-1-org-springframework-beans-factory-SmartInitializingSingleton" class="headerlink" title="3.1 org.springframework.beans.factory.SmartInitializingSingleton"></a>3.1 org.springframework.beans.factory.SmartInitializingSingleton</h3><p><strong>调用方法</strong>: <code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code></p>
<p><strong>作用</strong>: 所有单例对象加载完成后调用，可以使用此接口回调处理逻辑</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAOP 源码学习</title>
    <url>/2020/10/22/spring-aop/spring-aop00/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>阅读 Spring AOP 源码，是深入理解 Spring 框架核心机制的一次重要学习经历。通过研究 AOP（面向切面编程）的实现，能够窥探 Spring 如何处理横切关注点。</p>
<h2 id="AOP-概念"><a href="#AOP-概念" class="headerlink" title="AOP 概念"></a>AOP 概念</h2><p><img src="/images/20201023/spring-aop00-1.png" alt="img"></p>
<p>引用博客: <a href="https://blog.csdn.net/qq_31960623/article/details/119964881">https://blog.csdn.net/qq_31960623/article/details/119964881</a></p>
<p>在那些类的那个方法(pointcut), 的那个地方(advice before/after/around)， 处理什么逻辑(advice method)</p>
<h2 id="源码流程图"><a href="#源码流程图" class="headerlink" title="源码流程图"></a>源码流程图</h2><p><a href="https://www.processon.com/view/link/658454b4e2e8734477e1f1d6">https://www.processon.com/view/link/658454b4e2e8734477e1f1d6</a></p>
<iframe id="embed_dom" name="embed_dom" frameborder="0" style="width:489px; height:275px;" src="https://www.processon.com/embed/65843200e2e8734477e1bb53"></iframe>


<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="../spring-aop01.md">SpringAOP 源码之配置</a></p>
<p><a href="../spring-aop02.md">SpringAOP 源码之 bean 创建</a></p>
<p><a href="../spring-aop03.md">SpringAOP 源码之创建代理对象及执行</a></p>
<p><a href="../spring-aop04.md">SpringAOP 源码之常用的 Advice</a></p>
<p><a href="../spring-aop05.md">SpringAOP 源码之事务</a></p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
        <tag>SpringAOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAOP 源码之配置</title>
    <url>/2020/10/22/spring-aop/spring-aop01/</url>
    <content><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p><strong>简单的 xml 配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logUtil&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.devinx3.demo.aop.xml.util.LogUtil&quot;</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.devinx3.demo.aop.xml.service.DemoService&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果已经配置了 aop:config, 则无需此标签 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;aop:aspectj-autoproxy /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;logUtil&quot;</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;logPoint&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">expression</span>=<span class="string">&quot;execution( Object com.devinx3.demo.aop.xml.service.DemoService.* (..))&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;logPoint&quot;</span>/&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;start&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;logPoint&quot;</span>/&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;logFinally&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;logPoint&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;stop&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;logPoint&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;result&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;logException&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;logPoint&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;e&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="解析-AOP-配置文件"><a href="#解析-AOP-配置文件" class="headerlink" title="解析 AOP 配置文件"></a>解析 AOP 配置文件</h3><h4 id="AopNamespaceHandler"><a href="#AopNamespaceHandler" class="headerlink" title="AopNamespaceHandler"></a>AopNamespaceHandler</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.config.AopNamespaceHandler</code></p>
</blockquote>
<p>注册 aop 标签的解析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;  </span><br><span class="line">  <span class="comment">// In 2.0 XSD as well as in 2.5+ XSDs  </span></span><br><span class="line">  registerBeanDefinitionParser(<span class="string">&quot;config&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConfigBeanDefinitionParser</span>());  </span><br><span class="line">  registerBeanDefinitionParser(<span class="string">&quot;aspectj-autoproxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">AspectJAutoProxyBeanDefinitionParser</span>());  </span><br><span class="line">  registerBeanDefinitionDecorator(<span class="string">&quot;scoped-proxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">ScopedProxyBeanDefinitionDecorator</span>());  </span><br><span class="line">  <span class="comment">// Only in 2.0 XSD: moved to context namespace in 2.5+  </span></span><br><span class="line">  registerBeanDefinitionParser(<span class="string">&quot;spring-configured&quot;</span>, <span class="keyword">new</span> <span class="title class_">SpringConfiguredBeanDefinitionParser</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="config-标签解析器"><a href="#config-标签解析器" class="headerlink" title="config 标签解析器"></a>config 标签解析器</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.config.ConfigBeanDefinitionParser</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">	<span class="type">CompositeComponentDefinition</span> <span class="variable">compositeDef</span> <span class="operator">=</span></span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">CompositeComponentDefinition</span>(element.getTagName(), parserContext.extractSource(element));</span><br><span class="line">	parserContext.pushContainingComponent(compositeDef);</span><br><span class="line">	<span class="comment">// 注册自动代理模式创建器, AspectjAwareAdvisorAutoProxyCreator (aspectj-autoproxy)</span></span><br><span class="line">	configureAutoProxyCreator(parserContext, element);</span><br><span class="line">	<span class="comment">// 解析 aop:config 子节点下的 aop:pointcut/aop:advice/aop:aspect</span></span><br><span class="line">	List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line">	<span class="keyword">for</span> (Element elt: childElts) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">localName</span> <span class="operator">=</span> parserContext.getDelegate().getLocalName(elt);</span><br><span class="line">		<span class="keyword">if</span> (POINTCUT.equals(localName)) &#123;</span><br><span class="line">			parsePointcut(elt, parserContext);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ADVISOR.equals(localName)) &#123;</span><br><span class="line">			parseAdvisor(elt, parserContext);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">			parseAspect(elt, parserContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	parserContext.popAndRegisterContainingComponent();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解析-pointcut-标签"><a href="#解析-pointcut-标签" class="headerlink" title="解析 pointcut 标签"></a>解析 pointcut 标签</h5><p>解析 pointcut 并构造 AspectJExpressionPointcut 元信息, 注册到 ben 工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AbstractBeanDefinition <span class="title function_">parsePointcut</span><span class="params">(Element pointcutElement, ParserContext parserContext)</span> &#123;</span><br><span class="line">	<span class="comment">// 切入点的唯一标识</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> pointcutElement.getAttribute(ID);</span><br><span class="line">	<span class="comment">// 获取切入点的表达式</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> pointcutElement.getAttribute(EXPRESSION);</span><br><span class="line">	<span class="type">AbstractBeanDefinition</span> <span class="variable">pointcutDefinition</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 采用栈保存切入点</span></span><br><span class="line">		<span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">PointcutEntry</span>(id));</span><br><span class="line">		<span class="comment">// 创建切入点bean对象</span></span><br><span class="line">		<span class="comment">// beanClass为AspectJExpressionPointcut.class。并且设置属性expression到该beanClass</span></span><br><span class="line">		pointcutDefinition = createPointcutDefinition(expression);</span><br><span class="line">		pointcutDefinition.setSource(parserContext.extractSource(pointcutElement));</span><br><span class="line">		<span class="type">String</span> <span class="variable">pointcutBeanName</span> <span class="operator">=</span> id;</span><br><span class="line">		<span class="comment">// 注册 BeanDefinition </span></span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(pointcutBeanName)) &#123;</span><br><span class="line">			parserContext.getRegistry().registerBeanDefinition(pointcutBeanName, pointcutDefinition);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		    <span class="comment">// 生成 BeanDefinition 的名称</span></span><br><span class="line">			pointcutBeanName = parserContext.getReaderContext().registerWithGeneratedName(pointcutDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		parserContext.registerComponent(</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">PointcutComponentDefinition</span>(pointcutBeanName, pointcutDefinition, expression));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 创建后移除</span></span><br><span class="line">		<span class="built_in">this</span>.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pointcutDefinition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 pointcut 的 bean 元信息</span></span><br><span class="line"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title function_">createPointcutDefinition</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">	<span class="type">RootBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(AspectJExpressionPointcut.class);</span><br><span class="line">	beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">	beanDefinition.setSynthetic(<span class="literal">true</span>);</span><br><span class="line">	beanDefinition.getPropertyValues().add(EXPRESSION, expression);</span><br><span class="line">	<span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解析-advice-标签"><a href="#解析-advice-标签" class="headerlink" title="解析 advice 标签"></a>解析 advice 标签</h5><p>包含 <code>around, before, after, after-returning, after-throwing</code></p>
<p>解析 pointcut 并构造 AspectJExpressionPointcut 元信息,<br>解析 <code>around, before, after, after-returning, after-throwing</code> 并构造  <code>AspectJMethodBeforeAdvice</code>, <code>AspectJAfterAdvice</code>, <code>AspectJAfterReturningAdvice</code>, <code>AspectJAfterThrowingAdvice</code>, <code>AspectJAroundAdvice</code> 元信息<br>同时构造 AspectJPointcutAdvisor 元信息，并注册到 bean 工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析通知类并注册到 bean 工厂(org.springframework.aop.aspectj.AspectJPointcutAdvisor)</span></span><br><span class="line"><span class="keyword">private</span> AbstractBeanDefinition <span class="title function_">parseAdvice</span><span class="params">(</span></span><br><span class="line"><span class="params">		String aspectName, <span class="type">int</span> order, Element aspectElement, Element adviceElement, ParserContext parserContext,</span></span><br><span class="line"><span class="params">		List&lt;BeanDefinition&gt; beanDefinitions, List&lt;BeanReference&gt; beanReferences)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">AdviceEntry</span>(parserContext.getDelegate().getLocalName(adviceElement)));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// create the method factory bean</span></span><br><span class="line">		<span class="comment">// 解析 advice 节点中的 &quot;method&quot; 属性，并包装为 MethodLocatingFactoryBean 对象</span></span><br><span class="line">		<span class="type">RootBeanDefinition</span> <span class="variable">methodDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(MethodLocatingFactoryBean.class);</span><br><span class="line">		methodDefinition.getPropertyValues().add(<span class="string">&quot;targetBeanName&quot;</span>, aspectName);</span><br><span class="line">		methodDefinition.getPropertyValues().add(<span class="string">&quot;methodName&quot;</span>, adviceElement.getAttribute(<span class="string">&quot;method&quot;</span>));</span><br><span class="line">		methodDefinition.setSynthetic(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// create instance factory definition</span></span><br><span class="line">		<span class="comment">// 关联 aspectName，包装为 SimpleBeanFactoryAwareAspectInstanceFactory 对象</span></span><br><span class="line">		<span class="type">RootBeanDefinition</span> <span class="variable">aspectFactoryDef</span> <span class="operator">=</span></span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(SimpleBeanFactoryAwareAspectInstanceFactory.class);</span><br><span class="line">		aspectFactoryDef.getPropertyValues().add(<span class="string">&quot;aspectBeanName&quot;</span>, aspectName);</span><br><span class="line">		aspectFactoryDef.setSynthetic(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// register the pointcut</span></span><br><span class="line">		<span class="comment">// 涉及 point-cut 属性的解析，并结合上述的两个 bean 最终包装为 AbstractAspectJAdvice通知对象</span></span><br><span class="line">		<span class="type">AbstractBeanDefinition</span> <span class="variable">adviceDef</span> <span class="operator">=</span> createAdviceDefinition(</span><br><span class="line">				adviceElement, parserContext, aspectName, order, methodDefinition, aspectFactoryDef,</span><br><span class="line">				beanDefinitions, beanReferences);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// configure the advisor</span></span><br><span class="line">		<span class="comment">// 最终包装为 AspectJPointcutAdvisor 对象</span></span><br><span class="line">		<span class="type">RootBeanDefinition</span> <span class="variable">advisorDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(AspectJPointcutAdvisor.class);</span><br><span class="line">		advisorDefinition.setSource(parserContext.extractSource(adviceElement));</span><br><span class="line">		advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef);</span><br><span class="line">		<span class="keyword">if</span> (aspectElement.hasAttribute(ORDER_PROPERTY)) &#123;</span><br><span class="line">			advisorDefinition.getPropertyValues().add(</span><br><span class="line">					ORDER_PROPERTY, aspectElement.getAttribute(ORDER_PROPERTY));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// register the final advisor</span></span><br><span class="line">		parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> advisorDefinition;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建通知 的 bean 元信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AbstractBeanDefinition <span class="title function_">createAdviceDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">		Element adviceElement, ParserContext parserContext, String aspectName, <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">		RootBeanDefinition methodDef, RootBeanDefinition aspectFactoryDef,</span></span><br><span class="line"><span class="params">		List&lt;BeanDefinition&gt; beanDefinitions, List&lt;BeanReference&gt; beanReferences)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先根据adviceElement节点分析出是什么类型的Advice</span></span><br><span class="line">	<span class="type">RootBeanDefinition</span> <span class="variable">adviceDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(getAdviceClass(adviceElement, parserContext));</span><br><span class="line">	adviceDefinition.setSource(parserContext.extractSource(adviceElement));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置aspectName属性和declarationOrder属性</span></span><br><span class="line">	adviceDefinition.getPropertyValues().add(ASPECT_NAME_PROPERTY, aspectName);</span><br><span class="line">	adviceDefinition.getPropertyValues().add(DECLARATION_ORDER_PROPERTY, order);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析节点是否含有`returning`/`throwing`/`arg-names`，有则设置</span></span><br><span class="line">	<span class="keyword">if</span> (adviceElement.hasAttribute(RETURNING)) &#123;</span><br><span class="line">		adviceDefinition.getPropertyValues().add(</span><br><span class="line">				RETURNING_PROPERTY, adviceElement.getAttribute(RETURNING));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (adviceElement.hasAttribute(THROWING)) &#123;</span><br><span class="line">		adviceDefinition.getPropertyValues().add(</span><br><span class="line">				THROWING_PROPERTY, adviceElement.getAttribute(THROWING));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (adviceElement.hasAttribute(ARG_NAMES)) &#123;</span><br><span class="line">		adviceDefinition.getPropertyValues().add(</span><br><span class="line">				ARG_NAMES_PROPERTY, adviceElement.getAttribute(ARG_NAMES));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置构造函数的入参变量</span></span><br><span class="line">	<span class="comment">// Method/AspectJExpressionPointcut/AspectInstanceFactory三个入参</span></span><br><span class="line">	<span class="type">ConstructorArgumentValues</span> <span class="variable">cav</span> <span class="operator">=</span> adviceDefinition.getConstructorArgumentValues();</span><br><span class="line">	cav.addIndexedArgumentValue(METHOD_INDEX, methodDef);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 pointcut 属性</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">pointcut</span> <span class="operator">=</span> parsePointcutProperty(adviceElement, parserContext);</span><br><span class="line">	<span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">		cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcut);</span><br><span class="line">		beanDefinitions.add((BeanDefinition) pointcut);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">		<span class="type">RuntimeBeanReference</span> <span class="variable">pointcutRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>((String) pointcut);</span><br><span class="line">		cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcutRef);</span><br><span class="line">		beanReferences.add(pointcutRef);</span><br><span class="line">	&#125;</span><br><span class="line">	cav.addIndexedArgumentValue(ASPECT_INSTANCE_FACTORY_INDEX, aspectFactoryDef);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> adviceDefinition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据不同的标签使用对应的 advice </span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdviceClass(Element adviceElement, ParserContext parserContext) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">elementName</span> <span class="operator">=</span> parserContext.getDelegate().getLocalName(adviceElement);</span><br><span class="line">	<span class="keyword">if</span> (BEFORE.equals(elementName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> AspectJMethodBeforeAdvice.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (AFTER.equals(elementName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> AspectJAfterAdvice.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (AFTER_RETURNING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> AspectJAfterReturningAdvice.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (AFTER_THROWING_ELEMENT.equals(elementName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> AspectJAfterThrowingAdvice.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (AROUND.equals(elementName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> AspectJAroundAdvice.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown advice kind [&quot;</span> + elementName + <span class="string">&quot;].&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解析-advisor-标签"><a href="#解析-advisor-标签" class="headerlink" title="解析 advisor 标签"></a>解析 advisor 标签</h5><p>解析 advisor 并构造 DefaultBeanFactoryPointcutAdvisor 元信息, 注册到 ben 工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseAdvisor</span><span class="params">(Element advisorElement, ParserContext parserContext)</span> &#123;</span><br><span class="line">	<span class="comment">// 解析 &lt;aop:advisor&gt; 节点，最终创建的 beanClass 为 DefaultBeanFactoryPointcutAdvisor</span></span><br><span class="line">	<span class="comment">// 另外 advice-ref 属性必须定义，其与内部属性 adviceBeanName 对应</span></span><br><span class="line">	<span class="type">AbstractBeanDefinition</span> <span class="variable">advisorDef</span> <span class="operator">=</span> createAdvisorBeanDefinition(advisorElement, parserContext);</span><br><span class="line">	<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> advisorElement.getAttribute(ID);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">AdvisorEntry</span>(id));</span><br><span class="line">		<span class="type">String</span> <span class="variable">advisorBeanName</span> <span class="operator">=</span> id;</span><br><span class="line">		<span class="comment">// 注册到 bean 工厂</span></span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(advisorBeanName)) &#123;</span><br><span class="line">			parserContext.getRegistry().registerBeanDefinition(advisorBeanName, advisorDef);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			advisorBeanName = parserContext.getReaderContext().registerWithGeneratedName(advisorDef);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解析 pointcut 属性并赋值到 DefaultBeanFactoryPointcutAdvisor#pointcut 内部属性</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">pointcut</span> <span class="operator">=</span> parsePointcutProperty(advisorElement, parserContext);</span><br><span class="line">		<span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> BeanDefinition) &#123;</span><br><span class="line">			advisorDef.getPropertyValues().add(POINTCUT, pointcut);</span><br><span class="line">			parserContext.registerComponent(</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">AdvisorComponentDefinition</span>(advisorBeanName, advisorDef, (BeanDefinition) pointcut));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pointcut <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">			advisorDef.getPropertyValues().add(POINTCUT, <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>((String) pointcut));</span><br><span class="line">			parserContext.registerComponent(</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">AdvisorComponentDefinition</span>(advisorBeanName, advisorDef));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
        <tag>SpringAOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAOP 源码之 bean 创建</title>
    <url>/2020/10/22/spring-aop/spring-aop02/</url>
    <content><![CDATA[<h2 id="AspectJAwareAdvisorAutoProxyCreator"><a href="#AspectJAwareAdvisorAutoProxyCreator" class="headerlink" title="AspectJAwareAdvisorAutoProxyCreator"></a>AspectJAwareAdvisorAutoProxyCreator</h2><p><img src="/images/20201023/spring-aop02-1.png" alt="img"></p>
<blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator</code></p>
</blockquote>
<h3 id="AbstractAutoProxyCreator"><a href="#AbstractAutoProxyCreator" class="headerlink" title="AbstractAutoProxyCreator"></a>AbstractAutoProxyCreator</h3><h4 id="getEarlyBeanReference"><a href="#getEarlyBeanReference" class="headerlink" title="getEarlyBeanReference"></a>getEarlyBeanReference</h4><blockquote>
<p> <strong>定位</strong>: <code>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#getEarlyBeanReference</code></p>
</blockquote>
<p>三级缓存使用到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 放到集合中，然后判断要不要包装，其实就是在循环依赖注入属性的时候如果有AOP代理的话，也会进行代理，然后返回  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);  </span><br><span class="line">    <span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);  </span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="postProcessBeforeInstantiation"><a href="#postProcessBeforeInstantiation" class="headerlink" title="postProcessBeforeInstantiation"></a>postProcessBeforeInstantiation</h4><blockquote>
<p> <strong>定位</strong>: <code>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessBeforeInstantiation</code></p>
</blockquote>
<p>bean 实例化之前, 对 自定义的 TargetSource 进行代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="comment">//查缓存，是否有处理过了，不管是不是需要通知增强的，只要处理过了就会放里面</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">            <span class="comment">// 要跳过的直接设置FALSE</span></span><br><span class="line">            <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line">    <span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line">    <span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line">    <span class="comment">// 如果我们有自定义的TargetSource，请在此处创建代理；抑制不必要的目标bean的默认实例化, TargetSource将以自定义方式处理目标实例。</span></span><br><span class="line">    <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> getCustomTargetSource(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (targetSource != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">        <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h4><blockquote>
<p> <strong>定位</strong>: <code>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization</code></p>
</blockquote>
<p>初始化完成后创建代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前 bean 的缓存 key：如果 beanName 不为空，则以 beanName 为 key，如果为FactoryBean 类型，前面会添加 &amp; 符号；如果 beanName 为空，则以当前 bean 对应的 class 为 key</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="comment">// 判断当前 bean 是否正在被代理，如果正在被代理则不进行封装</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="comment">// 如果它需要被代理，则需要封装指定的 bean</span></span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="wrapIfNecessary"><a href="#wrapIfNecessary" class="headerlink" title="wrapIfNecessary"></a>wrapIfNecessary</h4><blockquote>
<p><strong>定位</strong>: <code> org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#wrapIfNecessary</code></p>
</blockquote>
<p>先判断是否已经处理过，是否需要跳过，跳过的话直接就放进advisedBeans里，表示不进行代理，如果这个bean处理过了，获取通知拦截器，然后开始进行代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果已经处理过，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里 advisedBeans 缓存了已经进行了代理的 bean ，如果缓存中存在，则可以直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里 isInfrastructureClass() 用于判断当前 bean 是否为 Spring 容器内部的 bean，内部的bean 是不用进行代理的；shouldSkip() 则用于判断当前 bean 是否应该被跳过</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="comment">// 对当前bean进行缓存</span></span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    <span class="comment">// 获取当前 bean 的 Advices 和 Advisors</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 对当前bean的代理状态进行缓存</span></span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="comment">// 对当前 bean 的代理状态进行缓存</span></span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 根据获取到的Advices和Advisors为当前bean生成代理对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">        <span class="comment">// 缓存生成的代理bean的类型，并且返回生成的代理bean</span></span><br><span class="line">        <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createProxy"><a href="#createProxy" class="headerlink" title="createProxy"></a>createProxy</h4><blockquote>
<p> <strong>定位</strong>: <code>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy</code></p>
</blockquote>
<p>进行代理工厂的创建，然后判断是否需要设置 proxyTargetClass，以便于后面决定是不是要进行 jdk动态代理还是 cglib 的动态代理, 然后把通知器 advisors 包装下，加入到代理工厂，获取代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给bean定义设置暴露属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理工厂</span></span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    <span class="comment">// 获取当前类中相关属性</span></span><br><span class="line">    proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 决定对于给定的bean是否应该使用targetClass而不是他的接口代理，检查proxyTargetClass设置以及preserverTargetClass属性</span></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="comment">// 判断是 使用jdk动态代理 还是cglib代理</span></span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 添加代理接口</span></span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建增强器</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    <span class="comment">// 设置到要代理的类</span></span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    <span class="comment">// 定制代理</span></span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制代理工厂被配置之后，是否还允许修改通知，默认值是 false</span></span><br><span class="line">    proxyFactory.setFrozen(<span class="built_in">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 真正创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Advisor[] buildAdvisors(<span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> Object[] specificInterceptors) &#123;</span><br><span class="line">    <span class="comment">// Handle prototypes correctly...</span></span><br><span class="line">    <span class="comment">// 解析注册的所有interceptorName</span></span><br><span class="line">    Advisor[] commonInterceptors = resolveInterceptorNames();</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; allInterceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 加入拦截器</span></span><br><span class="line">        allInterceptors.addAll(Arrays.asList(specificInterceptors));</span><br><span class="line">        <span class="keyword">if</span> (commonInterceptors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.applyCommonInterceptorsFirst) &#123;</span><br><span class="line">                allInterceptors.addAll(<span class="number">0</span>, Arrays.asList(commonInterceptors));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                allInterceptors.addAll(Arrays.asList(commonInterceptors));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nrOfCommonInterceptors</span> <span class="operator">=</span> commonInterceptors.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nrOfSpecificInterceptors</span> <span class="operator">=</span> (specificInterceptors != <span class="literal">null</span> ? specificInterceptors.length : <span class="number">0</span>);</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating implicit proxy for bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; with &quot;</span> + nrOfCommonInterceptors +</span><br><span class="line">                <span class="string">&quot; common interceptors and &quot;</span> + nrOfSpecificInterceptors + <span class="string">&quot; specific interceptors&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Advisor[] advisors = <span class="keyword">new</span> <span class="title class_">Advisor</span>[allInterceptors.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; allInterceptors.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 拦截器进行封装转化为Advisor</span></span><br><span class="line">        advisors[i] = <span class="built_in">this</span>.advisorAdapterRegistry.wrap(allInterceptors.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="advisorAdapterRegistry-wrap"><a href="#advisorAdapterRegistry-wrap" class="headerlink" title="advisorAdapterRegistry#wrap"></a>advisorAdapterRegistry#wrap</h4><p>org.springframework.aop.framework.adapter.DefaultAdvisorAdapterRegistry#wrap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Advisor <span class="title function_">wrap</span><span class="params">(Object adviceObject)</span> <span class="keyword">throws</span> UnknownAdviceTypeException &#123;</span><br><span class="line">	<span class="comment">// 如果要封装的对象本身就是Advisor类型，那么无须做任何处理</span></span><br><span class="line">	<span class="keyword">if</span> (adviceObject <span class="keyword">instanceof</span> Advisor) &#123;</span><br><span class="line">		<span class="keyword">return</span> (Advisor) adviceObject;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果类型不是 Advisor 和 Advice 两种类型的数据，那么将不能进行封装</span></span><br><span class="line">	<span class="keyword">if</span> (!(adviceObject <span class="keyword">instanceof</span> Advice)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownAdviceTypeException</span>(adviceObject);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> (Advice) adviceObject;</span><br><span class="line">	<span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">		<span class="comment">// So well-known it doesn&#x27;t even need an adapter.</span></span><br><span class="line">		<span class="comment">// 如果是 MethodInterceptor 类型则使用 DefaultPointcutAdvisor 封装</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(advice);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果存在 Advisor 的适配器那么也同样需要进行封装</span></span><br><span class="line">	<span class="keyword">for</span> (AdvisorAdapter adapter : <span class="built_in">this</span>.adapters) &#123;</span><br><span class="line">		<span class="comment">// Check that it is supported.</span></span><br><span class="line">		<span class="comment">// 默认支持这 3 种 MethodBeforeAdviceAdapter  / AfterReturningAdviceAdapter / ThrowsAdviceAdapter</span></span><br><span class="line">		<span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(advice);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownAdviceTypeException</span>(advice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ProxyProcessorSupport"><a href="#ProxyProcessorSupport" class="headerlink" title="ProxyProcessorSupport"></a>ProxyProcessorSupport</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.framework.ProxyProcessorSupport</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断接口是不是需要设置 ProxyTargetClass = true，判断它的接口不是内部的回调接口和内部语言接口，就添加接口否则就设置 ProxyTargetClass = true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">evaluateProxyInterfaces</span><span class="params">(Class&lt;?&gt; beanClass, ProxyFactory proxyFactory)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, getProxyClassLoader());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasReasonableProxyInterface</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; ifc : targetInterfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isConfigurationCallbackInterface(ifc) &amp;&amp; !isInternalLanguageInterface(ifc) &amp;&amp;</span><br><span class="line">                ifc.getMethods().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用接口代理，也就是jdk</span></span><br><span class="line">            hasReasonableProxyInterface = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有接口</span></span><br><span class="line">    <span class="keyword">if</span> (hasReasonableProxyInterface) &#123;</span><br><span class="line">        <span class="comment">// Must allow for introductions; can&#x27;t just set interfaces to the target&#x27;s interfaces only.</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; ifc : targetInterfaces) &#123;</span><br><span class="line">            proxyFactory.addInterface(ifc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没接口就设置 true</span></span><br><span class="line">        proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是不是 Spring 容器内部的接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isConfigurationCallbackInterface</span><span class="params">(Class&lt;?&gt; ifc)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (InitializingBean.class == ifc || DisposableBean.class == ifc || Closeable.class == ifc ||</span><br><span class="line">            AutoCloseable.class == ifc || ObjectUtils.containsElement(ifc.getInterfaces(), Aware.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是不是一些已知的内部语言接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isInternalLanguageInterface</span><span class="params">(Class&lt;?&gt; ifc)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (ifc.getName().equals(<span class="string">&quot;groovy.lang.GroovyObject&quot;</span>) ||</span><br><span class="line">            ifc.getName().endsWith(<span class="string">&quot;.cglib.proxy.Factory&quot;</span>) ||</span><br><span class="line">            ifc.getName().endsWith(<span class="string">&quot;.bytebuddy.MockAccess&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractAdvisorAutoProxyCreator"><a href="#AbstractAdvisorAutoProxyCreator" class="headerlink" title="AbstractAdvisorAutoProxyCreator"></a>AbstractAdvisorAutoProxyCreator</h3><h4 id="getAdvicesAndAdvisorsForBean"><a href="#getAdvicesAndAdvisorsForBean" class="headerlink" title="getAdvicesAndAdvisorsForBean"></a>getAdvicesAndAdvisorsForBean</h4><blockquote>
<p> <strong>定位</strong>: <code>org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">        Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找合适的增强器对象</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="comment">// 若为空表示没找到</span></span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="findEligibleAdvisors"><a href="#findEligibleAdvisors" class="headerlink" title="findEligibleAdvisors"></a>findEligibleAdvisors</h4><blockquote>
<p> <strong>定位</strong>: <code>org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#findEligibleAdvisors</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前容器中所有的切面类的切面逻辑进行封装，从而得到目标 Advisor 实例</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// 对获取到的所有 Advisor 进行判断，看其切面定义是否可以应用到当前 bean，从而得到最终需要应用的 Advisor</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    <span class="comment">// 提供的 hook 方法，用于对目标 Advisor 进行扩展</span></span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 对需要代理的 Advisor 按照一定的规则进行排序</span></span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="extendAdvisors"><a href="#extendAdvisors" class="headerlink" title="extendAdvisors"></a>extendAdvisors</h4><blockquote>
<p> <strong>定位</strong>: <code>org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator#extendAdvisors</code></p>
</blockquote>
<p>将 ExposeInvocationInterceptor 添加到 advice 链的开头。使用AspectJ切入点表达式时需要此附加建议，以及在使用AspectJ风格的建议时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendAdvisors</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors)</span> &#123;</span><br><span class="line">	AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(candidateAdvisors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <strong>定位</strong>: <code>org.springframework.aop.aspectj.AspectJProxyUtils#makeAdvisorChainAspectJCapableIfNecessary</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">makeAdvisorChainAspectJCapableIfNecessary</span><span class="params">(List&lt;Advisor&gt; advisors)</span> &#123;</span><br><span class="line">	<span class="comment">// Don&#x27;t add advisors to an empty list; may indicate that proxying is just not required</span></span><br><span class="line">	<span class="keyword">if</span> (!advisors.isEmpty()) &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">foundAspectJAdvice</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">			<span class="comment">// Be careful not to get the Advice without a guard, as this might eagerly</span></span><br><span class="line">			<span class="comment">// instantiate a non-singleton AspectJ aspect...</span></span><br><span class="line">			<span class="keyword">if</span> (isAspectJAdvice(advisor)) &#123;</span><br><span class="line">				foundAspectJAdvice = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 存在 AspectJAdvice, 但是不存在 ExposeInvocationInterceptor </span></span><br><span class="line">		<span class="keyword">if</span> (foundAspectJAdvice &amp;&amp; !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) &#123;</span><br><span class="line">		    <span class="comment">// 添加  advice 链开头</span></span><br><span class="line">			advisors.add(<span class="number">0</span>, ExposeInvocationInterceptor.ADVISOR);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AopUtils-findAdvisorsThatCanApply"><a href="#AopUtils-findAdvisorsThatCanApply" class="headerlink" title="AopUtils#findAdvisorsThatCanApply"></a>AopUtils#findAdvisorsThatCanApply</h4><blockquote>
<p> <strong>定位</strong>: <code>org.springframework.aop.support.AopUtils#findAdvisorsThatCanApply</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title function_">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="comment">// 若候选的增强器集合为空 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个合适的增强器集合对象</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 循环我们候选的增强器对象</span></span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        <span class="comment">// 判断我们的增强器对象是不是实现了IntroductionAdvisor (很明显我们事务的没有实现 所以不会走下面的逻辑)</span></span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否有引介增强</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasIntroductions</span> <span class="operator">=</span> !eligibleAdvisors.isEmpty();</span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        <span class="comment">// 判断我们的增强器对象是不是实现了IntroductionAdvisor</span></span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">            <span class="comment">// already processed</span></span><br><span class="line">            <span class="comment">// 在上面已经处理过,不需要处理</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正的判断增强器是否合适当前类型</span></span><br><span class="line">        <span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 pointcut 表达式进行匹配</span></span><br><span class="line"><span class="comment">// 进行切点表达式的匹配最重要的就是 ClassFilter 和 MethodMatcher 这两个方法的实现。</span></span><br><span class="line"><span class="comment">// MethodMatcher 中有两个 matches 方法。一个参数是只有 Method 对象和 targetClass，另一个参数有</span></span><br><span class="line"><span class="comment">// Method 对象和 targetClass 对象还有一个 Method 的方法参数,他们两个的区别是：</span></span><br><span class="line"><span class="comment">// 两个参数的 matches 是用于静态的方法匹配 三个参数的 matches 是在运行期动态的进行方法匹配的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="type">boolean</span> hasIntroductions)</span> &#123;</span><br><span class="line">    Assert.notNull(pc, <span class="string">&quot;Pointcut must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">// 先进行 ClassFilter 的 matches 方法校验</span></span><br><span class="line">    <span class="comment">// 首先这个类要在所匹配的规则下</span></span><br><span class="line">    <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再进行 MethodMatcher 方法级别的校验</span></span><br><span class="line">    <span class="type">MethodMatcher</span> <span class="variable">methodMatcher</span> <span class="operator">=</span> pc.getMethodMatcher();</span><br><span class="line">    <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">        <span class="comment">// No need to iterate the methods if we&#x27;re matching any method anyway...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断匹配器是不是 IntroductionAwareMethodMatcher</span></span><br><span class="line">    <span class="type">IntroductionAwareMethodMatcher</span> <span class="variable">introductionAwareMethodMatcher</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个集合用于保存 targetClass 的 class 对象</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 判断当前 class 是不是代理的 class 对象</span></span><br><span class="line">    <span class="keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">        <span class="comment">// 加入到集合中去</span></span><br><span class="line">        classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取到 targetClass 所实现的接口的 class 对象，然后加入到集合中</span></span><br><span class="line">    classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环所有的 class 对象</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">        <span class="comment">// 通过 class 获取到所有的方法</span></span><br><span class="line">        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">        <span class="comment">// 循环我们的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 只要有一个方法能匹配到就返回 true</span></span><br><span class="line">            <span class="comment">// 这里就会有一个问题：因为在一个目标中可能会有多个方法存在，有的方法是满足这个切点的匹配规则的</span></span><br><span class="line">            <span class="comment">// 但是也可能有一些方法是不匹配切点规则的，这里检测的是只有一个 Method 满足切点规则就返回 true</span></span><br><span class="line">            <span class="comment">// 所以在运行时进行方法拦截的时候还会有一次运行时的方法切点规则匹配</span></span><br><span class="line">            <span class="keyword">if</span> (introductionAwareMethodMatcher != <span class="literal">null</span> ?</span><br><span class="line">                    introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">                    <span class="comment">// 通过方法匹配器进行匹配</span></span><br><span class="line">                    methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
        <tag>SpringAOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAOP 源码之创建代理对象及执行</title>
    <url>/2020/10/22/spring-aop/spring-aop03/</url>
    <content><![CDATA[<h2 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h2><h3 id="ProxyFactory-getProxy"><a href="#ProxyFactory-getProxy" class="headerlink" title="ProxyFactory#getProxy"></a>ProxyFactory#getProxy</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.framework.ProxyFactory#getProxy</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;  </span><br><span class="line">    <span class="comment">// createAopProxy() 用来创建我们的代理工厂</span></span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createAopProxy"><a href="#createAopProxy" class="headerlink" title="createAopProxy"></a>createAopProxy</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.framework.ProxyCreatorSupport#createAopProxy</code></p>
</blockquote>
<p>创建 AOP 代理，如果激活了，就需要有激活通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">this</span>.active) &#123;</span><br><span class="line">		<span class="comment">// 监听调用 AdvisedSupportListener 实现类的 activated 方法</span></span><br><span class="line">		activate();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过 AopProxyFactory 获得 AopProxy ，这个 AopProxyFactory 是在初始化函数中定义的，使用的是 DefaultAopProxyFactory</span></span><br><span class="line">	<span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">	<span class="comment">// 这段代码用来判断选择哪种创建代理对象的方式</span></span><br><span class="line">	<span class="comment">// config.isOptimize()   是否对代理类的生成使用策略优化 其作用是和 isProxyTargetClass 是一样的 默认为 false</span></span><br><span class="line">	<span class="comment">// config.isProxyTargetClass() 是否使用 Cglib 的方式创建代理对象 默认为 false</span></span><br><span class="line">	<span class="comment">// hasNoUserSuppliedProxyInterfaces 目标类是否有接口存在 且只有一个接口的时候接口类型不是SpringProxy 类型</span></span><br><span class="line">	<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">		<span class="comment">// 上面的三个方法有一个为true的话，则进入到这里</span></span><br><span class="line">		<span class="comment">// 从AdvisedSupport中获取目标类 类对象</span></span><br><span class="line">		Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">		<span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">					<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断目标类是否是接口 如果目标类是接口的话，则还是使用JDK的方式生成代理对象</span></span><br><span class="line">		<span class="comment">// 如果目标类是 Proxy 类型 则还是使用 JDK 的方式生成代理对象</span></span><br><span class="line">		<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 配置了使用 Cglib 进行动态代理或者目标类没有接口,那么使用 Cglib 的方式创建代理对象</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 使用 JDK 的提供的代理方式生成代理对象</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a>JdkDynamicAopProxy</h2><h3 id="JdkDynamicAopProxy-getProxy"><a href="#JdkDynamicAopProxy-getProxy" class="headerlink" title="JdkDynamicAopProxy#getProxy"></a>JdkDynamicAopProxy#getProxy</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.framework.JdkDynamicAopProxy#getProxy</code></p>
</blockquote>
<p>创建代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Creating JDK dynamic proxy: &quot;</span> + <span class="built_in">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取 AdvisedSupport 类型对象的所有接口</span></span><br><span class="line">	Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised, <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">// 接口是否定义了 equals 和 hashcode 方法 (正常是没有的)</span></span><br><span class="line">	findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">	<span class="comment">// 创建代理对象 this 是 JdkDynamicAopProxy</span></span><br><span class="line">	<span class="comment">// JdkDynamicAopProxy 同时实现了 InvocationHandler 接口</span></span><br><span class="line">	<span class="comment">// 这里我们生成的代理对象可以向上造型为任意 proxiedInterfaces 中的类型</span></span><br><span class="line">	<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.framework.AopProxyUtils#completeProxiedInterfaces</code></p>
</blockquote>
<p>获取目标类上的接口并且判断是否需要添加 SpringProxy Advised DecoratingProxy 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt;[] completeProxiedInterfaces(AdvisedSupport advised, <span class="type">boolean</span> decoratingProxy) &#123;</span><br><span class="line">	<span class="comment">// 获取AdvisedSupport类型中目标类的接口</span></span><br><span class="line">	Class&lt;?&gt;[] specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line">	<span class="comment">// 如果目标类没有实现接口的话</span></span><br><span class="line">	<span class="keyword">if</span> (specifiedInterfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// No user-specified interfaces: check whether target class is an interface.</span></span><br><span class="line">		<span class="comment">// 获取目标类</span></span><br><span class="line">		Class&lt;?&gt; targetClass = advised.getTargetClass();</span><br><span class="line">		<span class="keyword">if</span> (targetClass != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果目标类是接口,则把目标类添加到AdvisedSupport的接口集合中</span></span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line">				advised.setInterfaces(targetClass);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果是Proxy类型</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				advised.setInterfaces(targetClass.getInterfaces());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 重新获取接口</span></span><br><span class="line">			specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//接口中有没有 SpringProxy 类型的接口</span></span><br><span class="line">	<span class="comment">//是否需要添加 SpringProxy 接口</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">addSpringProxy</span> <span class="operator">=</span> !advised.isInterfaceProxied(SpringProxy.class);</span><br><span class="line">	<span class="comment">// isOpaque 代表生成的代理是否避免转化为 Advised 类型 默认为 false  如果目标类没有实现 Advised 接口</span></span><br><span class="line">	<span class="comment">// 是否需要添加 Advised 接口</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">addAdvised</span> <span class="operator">=</span> !advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised.class);</span><br><span class="line">	<span class="comment">// 是否需要添加 DecoratingProxy 接口</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">addDecoratingProxy</span> <span class="operator">=</span> (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy.class));</span><br><span class="line">	<span class="type">int</span> <span class="variable">nonUserIfcCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 需要添加 SpringProxy 接口</span></span><br><span class="line">	<span class="keyword">if</span> (addSpringProxy) &#123;</span><br><span class="line">		nonUserIfcCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 需要添加通知</span></span><br><span class="line">	<span class="keyword">if</span> (addAdvised) &#123;</span><br><span class="line">		nonUserIfcCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 需要添加 DecoratingProxy 接口</span></span><br><span class="line">	<span class="keyword">if</span> (addDecoratingProxy) &#123;</span><br><span class="line">		nonUserIfcCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	Class&lt;?&gt;[] proxiedInterfaces = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[specifiedInterfaces.length + nonUserIfcCount];</span><br><span class="line">	<span class="comment">// 扩展接口数组</span></span><br><span class="line">	System.arraycopy(specifiedInterfaces, <span class="number">0</span>, proxiedInterfaces, <span class="number">0</span>, specifiedInterfaces.length);</span><br><span class="line">	<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> specifiedInterfaces.length;</span><br><span class="line">	<span class="keyword">if</span> (addSpringProxy) &#123;</span><br><span class="line">		<span class="comment">// 为目标对象接口中添加 SpringProxy 接口</span></span><br><span class="line">		proxiedInterfaces[index] = SpringProxy.class;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (addAdvised) &#123;</span><br><span class="line">		<span class="comment">// 为目标对象接口中添加 Advised 接口</span></span><br><span class="line">		proxiedInterfaces[index] = Advised.class;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (addDecoratingProxy) &#123;</span><br><span class="line">		<span class="comment">// 为目标对象接口中添加 DecoratingProxy 接口</span></span><br><span class="line">		proxiedInterfaces[index] = DecoratingProxy.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> proxiedInterfaces;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="JdkDynamicAopProxy-invoke-执行入口"><a href="#JdkDynamicAopProxy-invoke-执行入口" class="headerlink" title="JdkDynamicAopProxy#invoke (执行入口)"></a>JdkDynamicAopProxy#invoke (执行入口)</h3><blockquote>
<p><strong>定位</strong>:  <code>org.springframework.aop.framework.JdkDynamicAopProxy#invoke</code></p>
</blockquote>
<p>被拦截的接口方法的入口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">oldProxy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">setProxyContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取到我们的目标对象</span></span><br><span class="line">	<span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.targetSource;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 若是 equals 方法不需要代理</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">			<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若是 hashCode 方法不需要代理</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">			<span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">			<span class="keyword">return</span> hashCode();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若是 DecoratingProxy 也不要拦截器执行</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">			<span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line">			<span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="built_in">this</span>.advised);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// isAssignableFrom 方法：如果调用这个方法的 class 或接口与参数 cls 表示的类或接口相同，或者是参数 cls 表示的类或接口的父类，则返回 true</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">				method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">			<span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">			<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="built_in">this</span>.advised, method, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这个配置是暴露我们的代理对象到线程变量中，需要搭配<span class="doctag">@EnableAspectJAutoProxy</span>(exposeProxy = true)一起使用</span></span><br><span class="line"><span class="comment">		 * 比如在目标对象方法中再次获取代理对象可以使用这个AopContext.currentProxy()</span></span><br><span class="line"><span class="comment">		 * 还有的就是事务方法调用事务方法的时候也是用到这个</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">			<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">			<span class="comment">// 把我们的代理对象暴露到线程变量中</span></span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target,</span></span><br><span class="line">		<span class="comment">// in case it comes from a pool.</span></span><br><span class="line">		<span class="comment">// 获取我们的目标对象</span></span><br><span class="line">		target = targetSource.getTarget();</span><br><span class="line">		<span class="comment">// 获取我们目标对象的 class</span></span><br><span class="line">		Class&lt;?&gt; targetClass = (target != <span class="literal">null</span> ? target.getClass() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">		<span class="comment">// 从 Advised 中根据方法名和目标类获取AOP拦截器执行链</span></span><br><span class="line">		List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span></span><br><span class="line">		<span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">		<span class="comment">// 如果拦截器链为空</span></span><br><span class="line">		<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">			<span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">			<span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">			<span class="comment">// 通过反射直接调用执行</span></span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">			<span class="comment">// 如果没有发现任何拦截器那么直接调用切点方法</span></span><br><span class="line">			retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">			<span class="comment">// 将拦截器封装在 ReflectiveMethodInvocation，以便于使用其 proceed 进行处理</span></span><br><span class="line">			<span class="type">MethodInvocation</span> <span class="variable">invocation</span> <span class="operator">=</span></span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);</span><br><span class="line">			<span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">			<span class="comment">// 执行拦截器链</span></span><br><span class="line">			retVal = invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Massage return value if necessary.</span></span><br><span class="line">		<span class="comment">// 获取返回类型</span></span><br><span class="line">		Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">		<span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">				returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">			<span class="comment">// Special case: it returned &quot;this&quot; and the return type of the method</span></span><br><span class="line">			<span class="comment">// is type-compatible. Note that we can&#x27;t help if the target sets</span></span><br><span class="line">			<span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">			retVal = proxy;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 返回值类型错误</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="literal">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopInvocationException</span>(</span><br><span class="line">					<span class="string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 如果目标对象不为空且目标对象是可变的,如prototype类型</span></span><br><span class="line">		<span class="comment">// 通常我们的目标对象都是单例的,即targetSource.isStatic为true</span></span><br><span class="line">		<span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">			<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">			<span class="comment">// 释放目标对象</span></span><br><span class="line">			targetSource.releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">			<span class="comment">// Restore old proxy.</span></span><br><span class="line">			<span class="comment">// 线程上下文复位</span></span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ObjenesisCglibAopProxy"><a href="#ObjenesisCglibAopProxy" class="headerlink" title="ObjenesisCglibAopProxy"></a>ObjenesisCglibAopProxy</h2><h3 id="CglibAopProxy-getProxy"><a href="#CglibAopProxy-getProxy" class="headerlink" title="CglibAopProxy#getProxy"></a>CglibAopProxy#getProxy</h3><blockquote>
<p><strong>定位</strong>:<code>org.springframework.aop.framework.CglibAopProxy#getProxy</code></p>
</blockquote>
<p>创建代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Creating CGLIB proxy: &quot;</span> + <span class="built_in">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 从advised中获取ioc容器中配置的target对象</span></span><br><span class="line">		Class&lt;?&gt; rootClass = <span class="built_in">this</span>.advised.getTargetClass();</span><br><span class="line">		Assert.state(rootClass != <span class="literal">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">		<span class="comment">//如果目标对象已经是CGLIB 生成代理对象（就是比较类名称中有 $$ 字符串），那么就取目标对象的父类作为目标对象的类</span></span><br><span class="line">		<span class="keyword">if</span> (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) &#123;</span><br><span class="line">			proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">			<span class="comment">// 获取原始父类的接口</span></span><br><span class="line">			Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">				<span class="built_in">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">		<span class="comment">// 打印出不能代理的方法名，CGLIB 是使用继承实现的，所以final , static 的方法不能被增强</span></span><br><span class="line">		validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">		<span class="comment">// 创建及配置Enhancer</span></span><br><span class="line">		<span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> createEnhancer();</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">			enhancer.setClassLoader(classLoader);</span><br><span class="line">			<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">					((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">				enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 配置超类，代理类实现的接口，回调方法等</span></span><br><span class="line">		enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">		enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised));</span><br><span class="line">		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">		enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">ClassLoaderAwareGeneratorStrategy</span>(classLoader));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取callbacks</span></span><br><span class="line">		Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">		Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[callbacks.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">			types[x] = callbacks[x].getClass();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">		enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="title class_">ProxyCallbackFilter</span>(</span><br><span class="line">				<span class="built_in">this</span>.advised.getConfigurationOnlyCopy(), <span class="built_in">this</span>.fixedInterceptorMap, <span class="built_in">this</span>.fixedInterceptorOffset));</span><br><span class="line">		enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">		<span class="comment">// 通过 Enhancer 生成代理对象，并设置回调</span></span><br><span class="line">		<span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="built_in">this</span>.advised.getTargetClass() +</span><br><span class="line">				<span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,</span><br><span class="line">				ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.framework.CglibAopProxy#createProxyClassAndInstance</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> &#123;</span><br><span class="line">	enhancer.setInterceptDuringConstruction(<span class="literal">false</span>);</span><br><span class="line">	enhancer.setCallbacks(callbacks);</span><br><span class="line">	<span class="comment">// 生成代理类以及创建代理</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">this</span>.constructorArgs != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.constructorArgTypes != <span class="literal">null</span> ?</span><br><span class="line">			enhancer.create(<span class="built_in">this</span>.constructorArgTypes, <span class="built_in">this</span>.constructorArgs) :</span><br><span class="line">			enhancer.create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CglibAopProxy-getCallbacks"><a href="#CglibAopProxy-getCallbacks" class="headerlink" title="CglibAopProxy#getCallbacks"></a>CglibAopProxy#getCallbacks</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.framework.CglibAopProxy#getCallbacks</code></p>
</blockquote>
<p>被代理方法的回调</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Callback[] getCallbacks(Class&lt;?&gt; rootClass) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// Parameters used for optimization choices...</span></span><br><span class="line">	<span class="comment">// 对于 expose-proxy 属性的处理,是否暴露当前对象为 ThreadLocal 模式，在当前上下文中能够进行引用</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">exposeProxy</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.isExposeProxy();</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">isFrozen</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.isFrozen();</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">isStatic</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.getTargetSource().isStatic();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Choose an &quot;aop&quot; interceptor (used for AOP calls).</span></span><br><span class="line">	<span class="comment">// 将拦截器封装在 DynamicAdvisedInterceptor 中</span></span><br><span class="line">	<span class="type">Callback</span> <span class="variable">aopInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicAdvisedInterceptor</span>(<span class="built_in">this</span>.advised);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Choose a &quot;straight to target&quot; interceptor. (used for calls that are</span></span><br><span class="line">	<span class="comment">// unadvised but can return this). May be required to expose the proxy.</span></span><br><span class="line">	Callback targetInterceptor;</span><br><span class="line">	<span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">		targetInterceptor = (isStatic ?</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">StaticUnadvisedExposedInterceptor</span>(<span class="built_in">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">DynamicUnadvisedExposedInterceptor</span>(<span class="built_in">this</span>.advised.getTargetSource()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		targetInterceptor = (isStatic ?</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">StaticUnadvisedInterceptor</span>(<span class="built_in">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">DynamicUnadvisedInterceptor</span>(<span class="built_in">this</span>.advised.getTargetSource()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Choose a &quot;direct to target&quot; dispatcher (used for</span></span><br><span class="line">	<span class="comment">// unadvised calls to static targets that cannot return this).</span></span><br><span class="line">	<span class="type">Callback</span> <span class="variable">targetDispatcher</span> <span class="operator">=</span> (isStatic ?</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">StaticDispatcher</span>(<span class="built_in">this</span>.advised.getTargetSource().getTarget()) : <span class="keyword">new</span> <span class="title class_">SerializableNoOp</span>());</span><br><span class="line"></span><br><span class="line">	Callback[] mainCallbacks = <span class="keyword">new</span> <span class="title class_">Callback</span>[] &#123;</span><br><span class="line">			<span class="comment">// 将拦截器链加入 Callback 中</span></span><br><span class="line">			aopInterceptor,  <span class="comment">// for normal advice</span></span><br><span class="line">			targetInterceptor,  <span class="comment">// invoke target without considering advice, if optimized</span></span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">SerializableNoOp</span>(),  <span class="comment">// no override for methods mapped to this</span></span><br><span class="line">			targetDispatcher, <span class="built_in">this</span>.advisedDispatcher,</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">EqualsInterceptor</span>(<span class="built_in">this</span>.advised),</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">HashCodeInterceptor</span>(<span class="built_in">this</span>.advised)</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	Callback[] callbacks;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the target is a static one and the advice chain is frozen,</span></span><br><span class="line">	<span class="comment">// then we can make some optimizations by sending the AOP calls</span></span><br><span class="line">	<span class="comment">// direct to the target using the fixed chain for that method.</span></span><br><span class="line">	<span class="keyword">if</span> (isStatic &amp;&amp; isFrozen) &#123;</span><br><span class="line">		Method[] methods = rootClass.getMethods();</span><br><span class="line">		Callback[] fixedCallbacks = <span class="keyword">new</span> <span class="title class_">Callback</span>[methods.length];</span><br><span class="line">		<span class="built_in">this</span>.fixedInterceptorMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(methods.length);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> small memory optimization here (can skip creation for methods with no advice)</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; methods.length; x++) &#123;</span><br><span class="line">			<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methods[x];</span><br><span class="line">			List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, rootClass);</span><br><span class="line">			fixedCallbacks[x] = <span class="keyword">new</span> <span class="title class_">FixedChainStaticTargetInterceptor</span>(</span><br><span class="line">					chain, <span class="built_in">this</span>.advised.getTargetSource().getTarget(), <span class="built_in">this</span>.advised.getTargetClass());</span><br><span class="line">			<span class="built_in">this</span>.fixedInterceptorMap.put(method, x);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now copy both the callbacks from mainCallbacks</span></span><br><span class="line">		<span class="comment">// and fixedCallbacks into the callbacks array.</span></span><br><span class="line">		callbacks = <span class="keyword">new</span> <span class="title class_">Callback</span>[mainCallbacks.length + fixedCallbacks.length];</span><br><span class="line">		System.arraycopy(mainCallbacks, <span class="number">0</span>, callbacks, <span class="number">0</span>, mainCallbacks.length);</span><br><span class="line">		System.arraycopy(fixedCallbacks, <span class="number">0</span>, callbacks, mainCallbacks.length, fixedCallbacks.length);</span><br><span class="line">		<span class="built_in">this</span>.fixedInterceptorOffset = mainCallbacks.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		callbacks = mainCallbacks;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="DynamicAdvisedInterceptor-intercept-执行入口"><a href="#DynamicAdvisedInterceptor-intercept-执行入口" class="headerlink" title="DynamicAdvisedInterceptor#intercept (执行入口)"></a>DynamicAdvisedInterceptor#intercept (执行入口)</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor#intercept</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">oldProxy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">setProxyContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.getTargetSource();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">			<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span></span><br><span class="line">		target = targetSource.getTarget();</span><br><span class="line">		Class&lt;?&gt; targetClass = (target != <span class="literal">null</span> ? target.getClass() : <span class="literal">null</span>);</span><br><span class="line">		<span class="comment">// 从advised中获取配置好的AOP通知</span></span><br><span class="line">		List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">		Object retVal;</span><br><span class="line">		<span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">		<span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">		<span class="comment">// 如果没有 aop 通知配置，那么直接调用 target 对象的调用方法</span></span><br><span class="line">		<span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">			<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">			<span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">			<span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">			<span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">			<span class="comment">// 如果拦截器链为空则直接激活原方法</span></span><br><span class="line">			retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">			<span class="comment">// 通过cglibMethodInvocation来启动advice通知</span></span><br><span class="line">			retVal = <span class="keyword">new</span> <span class="title class_">CglibMethodInvocation</span>(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">		&#125;</span><br><span class="line">		retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">			targetSource.releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">			<span class="comment">// Restore old proxy.</span></span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getInterceptorsAndDynamicInterceptionAdvice"><a href="#getInterceptorsAndDynamicInterceptionAdvice" class="headerlink" title="getInterceptorsAndDynamicInterceptionAdvice"></a>getInterceptorsAndDynamicInterceptionAdvice</h3><blockquote>
<p><strong>定位</strong>:  <code>org.springframework.aop.framework.AdvisedSupport#getInterceptorsAndDynamicInterceptionAdvice</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个 method 的缓存对象,在 MethodCacheKey 中实现了 equals 和 hashCode 方法同时还实现了compareTo 方法</span></span><br><span class="line">	<span class="type">MethodCacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodCacheKey</span>(method);</span><br><span class="line">	List&lt;Object&gt; cached = <span class="built_in">this</span>.methodCache.get(cacheKey);</span><br><span class="line">	<span class="comment">// 先从缓存中获取,如果缓存中获取不到,则再调用方法获取,获取之后放入到缓存中</span></span><br><span class="line">	<span class="keyword">if</span> (cached == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 调用的是 advisorChainFactory 的 getInterceptorsAndDynamicInterceptionAdvice方法</span></span><br><span class="line">		cached = <span class="built_in">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">				<span class="built_in">this</span>, method, targetClass);</span><br><span class="line">		<span class="built_in">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定位</strong>:  <code>org.springframework.aop.framework.DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span><br><span class="line"><span class="params">		Advised config, Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is somewhat tricky... We have to process introductions first,</span></span><br><span class="line">	<span class="comment">// but we need to preserve order in the ultimate list.</span></span><br><span class="line">	<span class="comment">// 这里用了一个单例模式 获取 DefaultAdvisorAdapterRegistry 实例</span></span><br><span class="line">	<span class="comment">// 在 Spring 中把每一个功能都分的很细，每个功能都会有相应的类去处理 符合单一职责原则的地方很多 这也是值得我们借鉴的一个地方</span></span><br><span class="line">	<span class="comment">// AdvisorAdapterRegistry 这个类的主要作用是将 Advice 适配为 Advisor 将 Advisor 适配为对应的 MethodInterceptor</span></span><br><span class="line">	<span class="type">AdvisorAdapterRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">	Advisor[] advisors = config.getAdvisors();</span><br><span class="line">	<span class="comment">// 创建一个初始大小为 之前获取到的 通知个数的集合</span></span><br><span class="line">	List&lt;Object&gt; interceptorList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(advisors.length);</span><br><span class="line">	<span class="comment">// 如果目标类为null的话，则从方法签名中获取目标类</span></span><br><span class="line">	Class&lt;?&gt; actualClass = (targetClass != <span class="literal">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">	<span class="comment">// 判断目标类是否存在引介增强,通常为 false</span></span><br><span class="line">	<span class="type">Boolean</span> <span class="variable">hasIntroductions</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环目标方法匹配的通知</span></span><br><span class="line">	<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">		<span class="comment">// 如果是 PointcutAdvisor 类型的实例</span></span><br><span class="line">		<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">			<span class="comment">// Add it conditionally.</span></span><br><span class="line">			<span class="type">PointcutAdvisor</span> <span class="variable">pointcutAdvisor</span> <span class="operator">=</span> (PointcutAdvisor) advisor;</span><br><span class="line">			<span class="comment">// 如果提前进行过切点的匹配了或者当前的 Advisor 适用于目标类</span></span><br><span class="line">			<span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">				<span class="type">MethodMatcher</span> <span class="variable">mm</span> <span class="operator">=</span> pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">				<span class="type">boolean</span> match;</span><br><span class="line">				<span class="comment">//检测Advisor是否适用于此目标方法</span></span><br><span class="line">				<span class="keyword">if</span> (mm <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">					<span class="keyword">if</span> (hasIntroductions == <span class="literal">null</span>) &#123;</span><br><span class="line">						hasIntroductions = hasMatchingIntroductions(advisors, actualClass);</span><br><span class="line">					&#125;</span><br><span class="line">					match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					match = mm.matches(method, actualClass);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (match) &#123;</span><br><span class="line">					<span class="comment">// 拦截器链是通过 AdvisorAdapterRegistry 来加入的，这个AdvisorAdapterRegistry 对 advice 织入具备很大的作用</span></span><br><span class="line">					MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					<span class="comment">// 使用 MethodMatchers 的 matches 方法进行匹配判断</span></span><br><span class="line">					<span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">						<span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line">						<span class="comment">// isn&#x27;t a problem as we normally cache created chains.</span></span><br><span class="line">						<span class="comment">// 动态切入点则会创建一个 InterceptorAndDynamicMethodMatcher 对象</span></span><br><span class="line">						<span class="comment">// 这个对象包含 MethodInterceptor 和 MethodMatcher 的实例</span></span><br><span class="line">						<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">							interceptorList.add(<span class="keyword">new</span> <span class="title class_">InterceptorAndDynamicMethodMatcher</span>(interceptor, mm));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 添加到列表中</span></span><br><span class="line">						interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是引介增强</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">			<span class="type">IntroductionAdvisor</span> <span class="variable">ia</span> <span class="operator">=</span> (IntroductionAdvisor) advisor;</span><br><span class="line">			<span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">				<span class="comment">// 将 Advisor 转换为 Interceptor</span></span><br><span class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 以上两种都不是</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 将 Advisor 转换为 Interceptor</span></span><br><span class="line">			Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">			interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
        <tag>SpringAOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAOP 源码之常用的 Advice</title>
    <url>/2020/10/22/spring-aop/spring-aop04/</url>
    <content><![CDATA[<p>介绍常用的 Advice</p>
<p><img src="/images/20201023/spring-aop04-1.png" alt="img"></p>
<p><code>AspectJMethodBeforeAdvice</code>, <code>AspectJAfterReturningAdvice</code>  没有实现 MethodInterceptor 接口, 在构造调用链时会通过 <code>MethodBeforeAdviceAdapter</code>, <code>AfterReturningAdviceAdapter</code> 这两个适配器转换成对应的接口，通过调用 MethodInterceptor#invoke 方法来实现对各个方法的处理</p>
<h2 id="AspectJMethodBeforeAdvice"><a href="#AspectJMethodBeforeAdvice" class="headerlink" title="AspectJMethodBeforeAdvice"></a>AspectJMethodBeforeAdvice</h2><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor#invoke</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// invoke 方法是拦截器的回调方法，会在代理对应的方法被调用时触发回调</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="comment">// 执行前置通知的方法</span></span><br><span class="line">	<span class="built_in">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">	<span class="comment">// 执行下一个通知/拦截器，如果该拦截器是最后一个了，将会调用目标方法</span></span><br><span class="line">	<span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.aspectj.AspectJMethodBeforeAdvice#before</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 这里传进来的目标对象、目标参数、目标方法都没有用到</span></span><br><span class="line">	invokeAdviceMethod(getJoinPointMatch(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AspectJAfterReturningAdvice"><a href="#AspectJAfterReturningAdvice" class="headerlink" title="AspectJAfterReturningAdvice"></a>AspectJAfterReturningAdvice</h2><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="comment">// 执行下一个通知/拦截器</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> mi.proceed();</span><br><span class="line">	<span class="comment">// 返回通知方法</span></span><br><span class="line">	<span class="built_in">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">	<span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.aspectj.AspectJAfterReturningAdvice#afterReturning</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="keyword">if</span> (shouldInvokeOnReturnValueOf(method, returnValue)) &#123;</span><br><span class="line">		invokeAdviceMethod(getJoinPointMatch(), returnValue, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AspectJAfterThrowingAdvice"><a href="#AspectJAfterThrowingAdvice" class="headerlink" title="AspectJAfterThrowingAdvice"></a>AspectJAfterThrowingAdvice</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 执行下一个通知/拦截器  methodInvocation</span></span><br><span class="line">		<span class="keyword">return</span> mi.proceed();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// 抛出异常</span></span><br><span class="line">		<span class="keyword">if</span> (shouldInvokeOnThrowing(ex)) &#123;</span><br><span class="line">			<span class="comment">// 执行异常通知</span></span><br><span class="line">			invokeAdviceMethod(getJoinPointMatch(), <span class="literal">null</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AspectJAfterAdvice"><a href="#AspectJAfterAdvice" class="headerlink" title="AspectJAfterAdvice"></a>AspectJAfterAdvice</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="comment">// 执行下一个通知/拦截器，如果该拦截器是最后一个了，将会调用目标方法</span></span><br><span class="line">		<span class="keyword">return</span> mi.proceed();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">	    <span class="comment">// 执行后置通知的方法</span></span><br><span class="line">		invokeAdviceMethod(getJoinPointMatch(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AspectJAroundAdvice"><a href="#AspectJAroundAdvice" class="headerlink" title="AspectJAroundAdvice"></a>AspectJAroundAdvice</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot;</span> + mi);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">ProxyMethodInvocation</span> <span class="variable">pmi</span> <span class="operator">=</span> (ProxyMethodInvocation) mi;</span><br><span class="line">	<span class="type">ProceedingJoinPoint</span> <span class="variable">pjp</span> <span class="operator">=</span> lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">	<span class="type">JoinPointMatch</span> <span class="variable">jpm</span> <span class="operator">=</span> getJoinPointMatch(pmi);</span><br><span class="line">	<span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AbstractAspectJAdvice"><a href="#AbstractAspectJAdvice" class="headerlink" title="AbstractAspectJAdvice"></a>AbstractAspectJAdvice</h2><h3 id="invokeAdviceMethod"><a href="#invokeAdviceMethod" class="headerlink" title="invokeAdviceMethod"></a>invokeAdviceMethod</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.aspectj.AbstractAspectJAdvice#invokeAdviceMethod</code></p>
</blockquote>
<p>调用 advice 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeAdviceMethod</span><span class="params">(JoinPoint jp, <span class="meta">@Nullable</span> JoinPointMatch jpMatch,</span></span><br><span class="line"><span class="params">		<span class="meta">@Nullable</span> Object returnValue, <span class="meta">@Nullable</span> Throwable t)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	Object[] actualArgs = args;</span><br><span class="line">	<span class="comment">// 判断通知方法是否有参数</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.aspectJAdviceMethod.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">		actualArgs = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ReflectionUtils.makeAccessible(<span class="built_in">this</span>.aspectJAdviceMethod);</span><br><span class="line">		<span class="comment">// TODO AopUtils.invokeJoinpointUsingReflection</span></span><br><span class="line">		<span class="comment">// 反射调用通知方法</span></span><br><span class="line">		<span class="comment">// this.aspectInstanceFactory.getAspectInstance() 获取的是切面的实例</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.aspectJAdviceMethod.invoke(<span class="built_in">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopInvocationException</span>(<span class="string">&quot;Mismatch on arguments to advice method [&quot;</span> +</span><br><span class="line">				<span class="built_in">this</span>.aspectJAdviceMethod + <span class="string">&quot;]; pointcut expression [&quot;</span> +</span><br><span class="line">				<span class="built_in">this</span>.pointcut.getPointcutExpression() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getJoinPointMatch"><a href="#getJoinPointMatch" class="headerlink" title="getJoinPointMatch"></a>getJoinPointMatch</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.aop.aspectj.AbstractAspectJAdvice#getJoinPointMatch</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> JoinPointMatch <span class="title function_">getJoinPointMatch</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 这里是怎么获取到 MethodInvocation 的对象的呢？</span></span><br><span class="line">	<span class="comment">// 我们在获取 Advisor 的时候，调用过方法 org.springframework.aop.aspectj.AspectJProxyUtils#makeAdvisorChainAspectJCapableIfNecessary</span></span><br><span class="line">	<span class="comment">// 在这个方法中会有这样的一段代码, 如果存在 AspectJAdvice, 则将 ExposeInvocationInterceptor.ADVISOR 放到 Advisor 链的第一个</span></span><br><span class="line">	<span class="comment">// 这样我们就不难理解了，在调用 ReflectiveMethodInvocation#proceed 的时候第一个调用的 MethodInterceptor 是 ExposeInvocationInterceptor</span></span><br><span class="line">	<span class="comment">// 会将 MethodInvocation 放到线程变量中</span></span><br><span class="line">	<span class="type">MethodInvocation</span> <span class="variable">mi</span> <span class="operator">=</span> ExposeInvocationInterceptor.currentInvocation();</span><br><span class="line">	<span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot;</span> + mi);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里主要是获取 JoinPointMatch</span></span><br><span class="line">	<span class="keyword">return</span> getJoinPointMatch((ProxyMethodInvocation) mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> JoinPointMatch <span class="title function_">getJoinPointMatch</span><span class="params">(ProxyMethodInvocation pmi)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="built_in">this</span>.pointcut.getExpression();</span><br><span class="line">	<span class="keyword">return</span> (expression != <span class="literal">null</span> ? (JoinPointMatch) pmi.getUserAttribute(expression) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
        <tag>SpringAOP</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAOP 源码之事务</title>
    <url>/2020/10/22/spring-aop/spring-aop05/</url>
    <content><![CDATA[<h2 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml  配置"></a>xml  配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 启用声明式事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="xml-解析"><a href="#xml-解析" class="headerlink" title="xml 解析"></a>xml 解析</h2><h3 id="TxNamespaceHandler"><a href="#TxNamespaceHandler" class="headerlink" title="TxNamespaceHandler"></a>TxNamespaceHandler</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.transaction.config.TxNamespaceHandler</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果事务注解没有配置事务管理器引用, 使用 Spring 容器中的 transactionManager 事务管理器</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">getTransactionManagerName</span><span class="params">(Element element)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (element.hasAttribute(TRANSACTION_MANAGER_ATTRIBUTE) ?</span><br><span class="line">			element.getAttribute(TRANSACTION_MANAGER_ATTRIBUTE) : DEFAULT_TRANSACTION_MANAGER_BEAN_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 注册不同的 xml 文件标签解析器</span></span><br><span class="line">	registerBeanDefinitionParser(<span class="string">&quot;advice&quot;</span>, <span class="keyword">new</span> <span class="title class_">TxAdviceBeanDefinitionParser</span>());</span><br><span class="line">	registerBeanDefinitionParser(<span class="string">&quot;annotation-driven&quot;</span>, <span class="keyword">new</span> <span class="title class_">AnnotationDrivenBeanDefinitionParser</span>());</span><br><span class="line">	registerBeanDefinitionParser(<span class="string">&quot;jta-transaction-manager&quot;</span>, <span class="keyword">new</span> <span class="title class_">JtaTransactionManagerBeanDefinitionParser</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="AnnotationDrivenBeanDefinitionParser"><a href="#AnnotationDrivenBeanDefinitionParser" class="headerlink" title="AnnotationDrivenBeanDefinitionParser"></a>AnnotationDrivenBeanDefinitionParser</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.transaction.config.AnnotationDrivenBeanDefinitionParser</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析 annotation-driven 标签</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">    <span class="comment">// 注册事务事件监听工厂</span></span><br><span class="line">	registerTransactionalEventListenerFactory(parserContext);</span><br><span class="line">	<span class="type">String</span> <span class="variable">mode</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;mode&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="string">&quot;aspectj&quot;</span>.equals(mode)) &#123;</span><br><span class="line">		<span class="comment">// mode=&quot;aspectj&quot;</span></span><br><span class="line">		registerTransactionAspect(element, parserContext);</span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;javax.transaction.Transactional&quot;</span>, getClass().getClassLoader())) &#123;</span><br><span class="line">			registerJtaTransactionAspect(element, parserContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// mode=&quot;proxy&quot;  // 默认配置</span></span><br><span class="line">		AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="AopAutoProxyConfigurer"><a href="#AopAutoProxyConfigurer" class="headerlink" title="AopAutoProxyConfigurer"></a>AopAutoProxyConfigurer</h4><blockquote>
<p><strong>定位</strong>: <code>org.springframework.transaction.config.AnnotationDrivenBeanDefinitionParser.AopAutoProxyConfigurer</code></p>
</blockquote>
<p><strong>作用</strong>: 依据 <code>AnnotationTransactionAttributeSource</code> 和 <code>TransactionInterceptor</code> 元信息构造出  <code>BeanFactoryTransactionAttributeSourceAdvisor</code> 的元信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AopAutoProxyConfigurer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">configureAutoProxyCreator</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">        <span class="comment">// aop 注册</span></span><br><span class="line">		AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">txAdvisorBeanName</span> <span class="operator">=</span> TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;</span><br><span class="line">		<span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">eleSource</span> <span class="operator">=</span> parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Create the TransactionAttributeSource definition.</span></span><br><span class="line">			<span class="comment">// 创建 TransactionAttributeSource 的 bean</span></span><br><span class="line">			<span class="type">RootBeanDefinition</span> <span class="variable">sourceDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(</span><br><span class="line">					<span class="string">&quot;org.springframework.transaction.annotation.AnnotationTransactionAttributeSource&quot;</span>);</span><br><span class="line">			sourceDef.setSource(eleSource);</span><br><span class="line">			sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">			<span class="comment">// 注册 bean，并使用Spring中的定义规则生成 beanName</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">sourceName</span> <span class="operator">=</span> parserContext.getReaderContext().registerWithGeneratedName(sourceDef);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Create the TransactionInterceptor definition.</span></span><br><span class="line">			<span class="comment">// 创建 TransactionInterceptor 的 bean</span></span><br><span class="line">			<span class="type">RootBeanDefinition</span> <span class="variable">interceptorDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(TransactionInterceptor.class);</span><br><span class="line">			interceptorDef.setSource(eleSource);</span><br><span class="line">			interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">            <span class="comment">// 设置事务管理器名称</span></span><br><span class="line">			registerTransactionManager(element, interceptorDef);</span><br><span class="line">			interceptorDef.getPropertyValues().add(<span class="string">&quot;transactionAttributeSource&quot;</span>, <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(sourceName));</span><br><span class="line">			<span class="type">String</span> <span class="variable">interceptorName</span> <span class="operator">=</span> parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Create the TransactionAttributeSourceAdvisor definition.</span></span><br><span class="line">			<span class="comment">// 创建 TransactionAttributeSourceAdvisor 的 bean</span></span><br><span class="line">			<span class="type">RootBeanDefinition</span> <span class="variable">advisorDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(BeanFactoryTransactionAttributeSourceAdvisor.class);</span><br><span class="line">			advisorDef.setSource(eleSource);</span><br><span class="line">			advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">			<span class="comment">// 将 sourceName 的 bean 注入 advisorDef 的 transactionAttributeSource 属性中</span></span><br><span class="line">			advisorDef.getPropertyValues().add(<span class="string">&quot;transactionAttributeSource&quot;</span>, <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(sourceName));</span><br><span class="line">			<span class="comment">// 将 interceptorName 的 bean 注入 advisorDef 的 adviceBeanName 属性中</span></span><br><span class="line">			advisorDef.getPropertyValues().add(<span class="string">&quot;adviceBeanName&quot;</span>, interceptorName);</span><br><span class="line">			<span class="comment">// 如果配置了 order 属性，则加入到 bean 中</span></span><br><span class="line">			<span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;order&quot;</span>)) &#123;</span><br><span class="line">				advisorDef.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, element.getAttribute(<span class="string">&quot;order&quot;</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);</span><br><span class="line"></span><br><span class="line">			<span class="type">CompositeComponentDefinition</span> <span class="variable">compositeDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositeComponentDefinition</span>(element.getTagName(), eleSource);</span><br><span class="line">			compositeDef.addNestedComponent(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(sourceDef, sourceName));</span><br><span class="line">			compositeDef.addNestedComponent(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(interceptorDef, interceptorName));</span><br><span class="line">			compositeDef.addNestedComponent(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(advisorDef, txAdvisorBeanName));</span><br><span class="line">			parserContext.registerComponent(compositeDef);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="TransactionAttributeSourceAdvisor"><a href="#TransactionAttributeSourceAdvisor" class="headerlink" title="TransactionAttributeSourceAdvisor"></a>TransactionAttributeSourceAdvisor</h2><blockquote>
<p><strong>定位</strong>: <code>org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor</code></p>
</blockquote>
<p>将 pointcut 和 advice 封装成 Advisor 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title class_">AbstractPointcutAdvisor</span> &#123;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> TransactionInterceptor transactionInterceptor;</span><br><span class="line">	<span class="comment">// pointcut 属性赋值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TransactionAttributeSourcePointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionAttributeSourcePointcut</span>() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="keyword">protected</span> TransactionAttributeSource <span class="title function_">getTransactionAttributeSource</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (transactionInterceptor != <span class="literal">null</span> ? transactionInterceptor.getTransactionAttributeSource() : <span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Advice <span class="title function_">getAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">		Assert.state(<span class="built_in">this</span>.transactionInterceptor != <span class="literal">null</span>, <span class="string">&quot;No TransactionInterceptor set&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.transactionInterceptor;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Pointcut <span class="title function_">getPointcut</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.pointcut;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="pointcut-匹配规则"><a href="#pointcut-匹配规则" class="headerlink" title="pointcut  匹配规则"></a>pointcut  匹配规则</h3><blockquote>
<p><strong>定位</strong>:<code>org.springframework.transaction.interceptor.TransactionAttributeSourcePointcut.TransactionAttributeSourceClassFilter#matches</code></p>
</blockquote>
<p>类匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TransactionAttributeSourceClassFilter</span> <span class="keyword">implements</span> <span class="title class_">ClassFilter</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (TransactionalProxy.class.isAssignableFrom(clazz) ||</span><br><span class="line">				TransactionManager.class.isAssignableFrom(clazz) ||</span><br><span class="line">				PersistenceExceptionTranslator.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">		<span class="keyword">return</span> (tas == <span class="literal">null</span> || tas.isCandidateClass(clazz));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定位</strong>: <code>org.springframework.transaction.interceptor.TransactionAttributeSourcePointcut#matches</code></p>
</blockquote>
<p>方法匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取我们<span class="doctag">@EnableTransactionManagement</span>注解为我们容器中导入的ProxyTransactionManagementConfiguration</span></span><br><span class="line"><span class="comment">	 * 配置类中的TransactionAttributeSource对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">	<span class="comment">// 若事务属性原为null或者解析出来的事务注解属性不为空，表示方法匹配</span></span><br><span class="line">	<span class="keyword">return</span> (tas == <span class="literal">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="advice-通知"><a href="#advice-通知" class="headerlink" title="advice 通知"></a>advice 通知</h3><h4 id="TransactionInterceptor"><a href="#TransactionInterceptor" class="headerlink" title="TransactionInterceptor"></a>TransactionInterceptor</h4><p>此类实现了 MethodInterceptor 接口，继承了 <code>TransactionAspectSupport</code> 类</p>
<blockquote>
<p><strong>定位</strong>: <code>org.springframework.transaction.interceptor.TransactionInterceptor#invoke</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">	<span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">	<span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">	<span class="comment">// 获取我们的代理对象的class属性</span></span><br><span class="line">	Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 以事务的方式调用目标方法</span></span><br><span class="line"><span class="comment">	 * 在这埋了一个钩子函数 用来回调目标方法的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TransactionAspectSupport"><a href="#TransactionAspectSupport" class="headerlink" title="TransactionAspectSupport"></a>TransactionAspectSupport</h2><h3 id="invokeWithinTransaction"><a href="#invokeWithinTransaction" class="headerlink" title="invokeWithinTransaction"></a>invokeWithinTransaction</h3><blockquote>
<p><strong>定位</strong>: <code>org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction</code></p>
</blockquote>
<p>事务开启, 回滚和提交</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params">		<span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">	<span class="comment">// 获取我们的事务属性源对象</span></span><br><span class="line">	<span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">	<span class="comment">// 通过事务属性源对象获取到当前方法的事务属性信息</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line">	<span class="comment">// 获取我们配置的事务管理器对象</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.reactiveAdapterRegistry != <span class="literal">null</span> &amp;&amp; tm <span class="keyword">instanceof</span> ReactiveTransactionManager) &#123;</span><br><span class="line">		<span class="type">ReactiveTransactionSupport</span> <span class="variable">txSupport</span> <span class="operator">=</span> <span class="built_in">this</span>.transactionSupportCache.computeIfAbsent(method, key -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span> (KotlinDetector.isKotlinType(method.getDeclaringClass()) &amp;&amp; KotlinDelegate.isSuspend(method)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionUsageException</span>(</span><br><span class="line">						<span class="string">&quot;Unsupported annotated transaction on suspending function detected: &quot;</span> + method +</span><br><span class="line">						<span class="string">&quot;. Use TransactionalOperator.transactional extensions instead.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">ReactiveAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="built_in">this</span>.reactiveAdapterRegistry.getAdapter(method.getReturnType());</span><br><span class="line">			<span class="keyword">if</span> (adapter == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot apply reactive transaction to non-reactive return type: &quot;</span> +</span><br><span class="line">						method.getReturnType());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReactiveTransactionSupport</span>(adapter);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> txSupport.invokeWithinTransaction(</span><br><span class="line">				method, targetClass, invocation, txAttr, (ReactiveTransactionManager) tm);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">PlatformTransactionManager</span> <span class="variable">ptm</span> <span class="operator">=</span> asPlatformTransactionManager(tm);</span><br><span class="line">	<span class="comment">// 获取连接点的唯一标识  类名+方法名</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明式事务处理</span></span><br><span class="line">	<span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		<span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">		<span class="comment">// 创建TransactionInfo</span></span><br><span class="line">		<span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">			<span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">			<span class="comment">// 执行被增强方法,调用具体的处理逻辑</span></span><br><span class="line">			retVal = invocation.proceedWithInvocation();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">// target invocation exception</span></span><br><span class="line">			<span class="comment">// 异常回滚</span></span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//清除事务信息，恢复线程私有的老的事务信息</span></span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">			<span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">			<span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> txInfo.getTransactionStatus();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (status != <span class="literal">null</span> &amp;&amp; txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">				retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//成功后提交，会进行资源储量，连接释放，恢复挂起事务等操作</span></span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 编程式事务处理</span></span><br><span class="line">		Object result;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">ThrowableHolder</span> <span class="variable">throwableHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThrowableHolder</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// It&#x27;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			result = ((CallbackPreferringPlatformTransactionManager) ptm).execute(txAttr, status -&gt; &#123;</span><br><span class="line">				<span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> invocation.proceedWithInvocation();</span><br><span class="line">					<span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">						<span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">						retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> retVal;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line">						<span class="comment">// A RuntimeException: will lead to a rollback.</span></span><br><span class="line">						<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">							<span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ThrowableHolderException</span>(ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// A normal return value: will lead to a commit.</span></span><br><span class="line">						throwableHolder.throwable = ex;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					cleanupTransactionInfo(txInfo);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex.getCause();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (throwableHolder.throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">				logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);</span><br><span class="line">				ex2.initApplicationException(throwableHolder.throwable);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (throwableHolder.throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">				logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex2;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check result state: It might indicate a Throwable to rethrow.</span></span><br><span class="line">		<span class="keyword">if</span> (throwableHolder.throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> throwableHolder.throwable;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="createTransactionIfNecessary"><a href="#createTransactionIfNecessary" class="headerlink" title="createTransactionIfNecessary"></a>createTransactionIfNecessary</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span><br><span class="line"><span class="params">		<span class="meta">@Nullable</span> TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">	<span class="comment">// 如果没有名称指定则使用方法唯一标识，并使用 DelegatingTransactionAttribute 封装 txAttr</span></span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; txAttr.getName() == <span class="literal">null</span>) &#123;</span><br><span class="line">		txAttr = <span class="keyword">new</span> <span class="title class_">DelegatingTransactionAttribute</span>(txAttr) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tm != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 获取 TransactionStatus 事务状态信息</span></span><br><span class="line">			status = tm.getTransaction(txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Skipping transactional joinpoint [&quot;</span> + joinpointIdentification +</span><br><span class="line">						<span class="string">&quot;] because no transaction manager has been configured&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据指定的属性与status准备一个TransactionInfo，</span></span><br><span class="line">	<span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="prepareTransactionInfo"><a href="#prepareTransactionInfo" class="headerlink" title="prepareTransactionInfo"></a>prepareTransactionInfo</h3><p>事务的准备工作, 开启事务/设置事务状态/事务信息绑定到当前线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionInfo <span class="title function_">prepareTransactionInfo</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span><br><span class="line"><span class="params">		<span class="meta">@Nullable</span> TransactionAttribute txAttr, String joinpointIdentification,</span></span><br><span class="line"><span class="params">		<span class="meta">@Nullable</span> TransactionStatus status)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建事务信息</span></span><br><span class="line">	<span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionInfo</span>(tm, txAttr, joinpointIdentification);</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// We need a transaction for this method...</span></span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Getting transaction for [&quot;</span> + txInfo.getJoinpointIdentification() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The transaction manager will flag an error if an incompatible tx already exists.</span></span><br><span class="line">		<span class="comment">// 设置新事务状态</span></span><br><span class="line">		txInfo.newTransactionStatus(status);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// The TransactionInfo.hasTransaction() method will return false. We created it only</span></span><br><span class="line">		<span class="comment">// to preserve the integrity of the ThreadLocal stack maintained in this class.</span></span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No need to create transaction for [&quot;</span> + joinpointIdentification +</span><br><span class="line">					<span class="string">&quot;]: This method is not transactional.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We always bind the TransactionInfo to the thread, even if we didn&#x27;t create</span></span><br><span class="line">	<span class="comment">// a new transaction here. This guarantees that the TransactionInfo stack</span></span><br><span class="line">	<span class="comment">// will be managed correctly even if no transaction was created by this aspect.</span></span><br><span class="line">	<span class="comment">// 事务信息绑定到当前线程</span></span><br><span class="line">	txInfo.bindToThread();</span><br><span class="line">	<span class="keyword">return</span> txInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DataSourceTransactionManager"><a href="#DataSourceTransactionManager" class="headerlink" title="DataSourceTransactionManager"></a>DataSourceTransactionManager</h2><p>jdbc 数据源是事务管理器，继承自 AbstractPlatformTransactionManager </p>
<h3 id="doBegin"><a href="#doBegin" class="headerlink" title="doBegin"></a>doBegin</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> &#123;</span><br><span class="line">	<span class="comment">// 强制转化事务对象</span></span><br><span class="line">	<span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) transaction;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 判断事务对象没有数据库连接持有器</span></span><br><span class="line">		<span class="keyword">if</span> (!txObject.hasConnectionHolder() ||</span><br><span class="line">				txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">			<span class="comment">// 通过数据源获取一个数据库连接对象</span></span><br><span class="line">			<span class="type">Connection</span> <span class="variable">newCon</span> <span class="operator">=</span> obtainDataSource().getConnection();</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Acquired Connection [&quot;</span> + newCon + <span class="string">&quot;] for JDBC transaction&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 把我们的数据库连接包装成一个ConnectionHolder 对象 然后设置到我们的 txObject 对象中去</span></span><br><span class="line">			txObject.setConnectionHolder(<span class="keyword">new</span> <span class="title class_">ConnectionHolder</span>(newCon), <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 标记当前的连接是一个同步事务</span></span><br><span class="line">		txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="literal">true</span>);</span><br><span class="line">		con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 数据连接的只读标识，设置当前的事务隔离级别</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">previousIsolationLevel</span> <span class="operator">=</span> DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">		<span class="comment">// 事务对象设置先前隔离级别</span></span><br><span class="line">		txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line">		<span class="comment">// 事务对象设置是否只读</span></span><br><span class="line">		txObject.setReadOnly(definition.isReadOnly());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,</span></span><br><span class="line">		<span class="comment">// so we don&#x27;t want to do it unnecessarily (for example if we&#x27;ve explicitly</span></span><br><span class="line">		<span class="comment">// configured the connection pool to set it already).</span></span><br><span class="line">		<span class="comment">// 关闭自动提交</span></span><br><span class="line">		<span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">			<span class="comment">//设置需要恢复自动提交</span></span><br><span class="line">			txObject.setMustRestoreAutoCommit(<span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Switching JDBC Connection [&quot;</span> + con + <span class="string">&quot;] to manual commit&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 关闭自动提交</span></span><br><span class="line">			con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断事务是否需要设置为只读事务</span></span><br><span class="line">		prepareTransactionalConnection(con, definition);</span><br><span class="line">		<span class="comment">// 标记激活事务</span></span><br><span class="line">		txObject.getConnectionHolder().setTransactionActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置事务超时时间</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> determineTimeout(definition);</span><br><span class="line">		<span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">			txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Bind the connection holder to the thread.</span></span><br><span class="line">		<span class="comment">// 绑定我们的数据源和连接到我们的同步管理器上，把数据源作为key,数据库连接作为value 设置到线程变量中</span></span><br><span class="line">		<span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">			<span class="comment">// 将当前获取到的连接绑定到当前线程</span></span><br><span class="line">			TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">			<span class="comment">// 释放数据库连接</span></span><br><span class="line">			DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">			txObject.setConnectionHolder(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CannotCreateTransactionException</span>(<span class="string">&quot;Could not open JDBC Connection for transaction&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareTransactionalConnection</span><span class="params">(Connection con, TransactionDefinition definition)</span></span><br><span class="line">		<span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">	<span class="keyword">if</span> (isEnforceReadOnly() &amp;&amp; definition.isReadOnly()) &#123;</span><br><span class="line">		<span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement()) &#123;</span><br><span class="line">            <span class="comment">// 设置当前会话事务只读</span></span><br><span class="line">			stmt.executeUpdate(<span class="string">&quot;SET TRANSACTION READ ONLY&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doGetTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个数据源事务对象</span></span><br><span class="line">	<span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionObject</span>();</span><br><span class="line">	<span class="comment">// 是否允许当前事务设置保持点</span></span><br><span class="line">	txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * TransactionSynchronizationManager 事务同步管理器对象(该类中都是局部线程变量)</span></span><br><span class="line"><span class="comment">	 * 用来保存当前事务的信息,我们第一次从这里去线程变量中获取 事务连接持有器对象 通过数据源为 key 去获取</span></span><br><span class="line"><span class="comment">	 * 由于第一次进来开始事务 我们的事务同步管理器中没有被存放.所以此时获取出来的 conHolder 为 null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">ConnectionHolder</span> <span class="variable">conHolder</span> <span class="operator">=</span></span><br><span class="line">			(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());</span><br><span class="line">	txObject.setConnectionHolder(conHolder, <span class="literal">false</span>);</span><br><span class="line">	<span class="comment">// 返回事务对象</span></span><br><span class="line">	<span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="doCleanupAfterCompletion"><a href="#doCleanupAfterCompletion" class="headerlink" title="doCleanupAfterCompletion"></a>doCleanupAfterCompletion</h3><p>此方法做清除连接相关操作，比如重置自动提交啊，只读属性啊，解绑数据源啊，释放连接啊，清除链接持有器属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doCleanupAfterCompletion</span><span class="params">(Object transaction)</span> &#123;</span><br><span class="line">	<span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) transaction;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remove the connection holder from the thread, if exposed.</span></span><br><span class="line">	<span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">		<span class="comment">// 将数据库连接从当前线程中解除绑定</span></span><br><span class="line">		TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reset connection.</span></span><br><span class="line">	<span class="comment">// 释放连接</span></span><br><span class="line">	<span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> txObject.getConnectionHolder().getConnection();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (txObject.isMustRestoreAutoCommit()) &#123;</span><br><span class="line">			<span class="comment">// 恢复数据库连接的自动提交属性</span></span><br><span class="line">			con.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 重置数据库连接</span></span><br><span class="line">		DataSourceUtils.resetConnectionAfterTransaction(</span><br><span class="line">				con, txObject.getPreviousIsolationLevel(), txObject.isReadOnly());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Could not reset JDBC Connection after transaction&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Releasing JDBC Connection [&quot;</span> + con + <span class="string">&quot;] after transaction&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果当前事务是独立的新创建的事务则在事务完成时释放数据库连接</span></span><br><span class="line">		DataSourceUtils.releaseConnection(con, <span class="built_in">this</span>.dataSource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接持有器属性清除</span></span><br><span class="line">	txObject.getConnectionHolder().clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="AbstractPlatformTransactionManager"><a href="#AbstractPlatformTransactionManager" class="headerlink" title="AbstractPlatformTransactionManager"></a>AbstractPlatformTransactionManager</h2><h3 id="getTransaction"><a href="#getTransaction" class="headerlink" title="getTransaction"></a>getTransaction</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span><br><span class="line">		<span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">	<span class="comment">// 如果没有事务定义信息则使用默认的事务管理器定义信息</span></span><br><span class="line">	<span class="type">TransactionDefinition</span> <span class="variable">def</span> <span class="operator">=</span> (definition != <span class="literal">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取事务</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断当前线程是否存在事务，判断依据为当前线程记录的连接不为空且连接中的 transactionActive 属性不为空</span></span><br><span class="line">	<span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">		<span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">		<span class="comment">// 当前线程已经存在事务</span></span><br><span class="line">		<span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check definition settings for new transaction.</span></span><br><span class="line">	<span class="comment">// 事务超时设置验证</span></span><br><span class="line">	<span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidTimeoutException</span>(<span class="string">&quot;Invalid transaction timeout&quot;</span>, def.getTimeout());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line">	<span class="comment">// 如果当前线程不存在事务，但是 PropagationBehavior 却被声明为 PROPAGATION_MANDATORY 抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line">				<span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// PROPAGATION_REQUIRED，PROPAGATION_REQUIRES_NEW，PROPAGATION_NESTED 都需要新建事务</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">			def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">			def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		<span class="comment">// 没有当前事务的话，REQUIRED，REQUIRES_NEW，NESTED 挂起的是空事务，然后创建一个新事务</span></span><br><span class="line">		<span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(<span class="literal">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + def.getName() + <span class="string">&quot;]: &quot;</span> + def);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			<span class="comment">// 恢复挂起的事务</span></span><br><span class="line">			resume(<span class="literal">null</span>, suspendedResources);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">		<span class="comment">// 创建一个空的事务</span></span><br><span class="line">		<span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">			logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line">					<span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + def);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		<span class="keyword">return</span> prepareTransactionStatus(def, <span class="literal">null</span>, <span class="literal">true</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开启新事务</span></span><br><span class="line"><span class="keyword">private</span> TransactionStatus <span class="title function_">startTransaction</span><span class="params">(TransactionDefinition definition, Object transaction,</span></span><br><span class="line"><span class="params">		<span class="type">boolean</span> debugEnabled, <span class="meta">@Nullable</span> SuspendedResourcesHolder suspendedResources)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否需要新同步</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">	<span class="comment">// 创建新的事务</span></span><br><span class="line">	<span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> newTransactionStatus(</span><br><span class="line">			definition, transaction, <span class="literal">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">	<span class="comment">// 开启事务和连接</span></span><br><span class="line">	doBegin(transaction, definition);</span><br><span class="line">	<span class="comment">// 对于新同步事务，设置事务信息到当前线程变量</span></span><br><span class="line">	prepareSynchronization(status, definition);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="handleExistingTransaction"><a href="#handleExistingTransaction" class="headerlink" title="handleExistingTransaction"></a>handleExistingTransaction</h4><p>在开始事务时，如果当前线程是否存在事务，则进行嵌套事务的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionStatus <span class="title function_">handleExistingTransaction</span><span class="params">(</span></span><br><span class="line"><span class="params">		TransactionDefinition definition, Object transaction, <span class="type">boolean</span> debugEnabled)</span></span><br><span class="line">		<span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断当前的事务行为是不是PROPAGATION_NEVER的</span></span><br><span class="line"><span class="comment">	 * 表示为不支持事务,但是当前又存在一个事务,所以抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line">				<span class="string">&quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断当前的事务属性不支持事务,PROPAGATION_NOT_SUPPORTED,所以需要先挂起已经存在的事务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Suspending current transaction&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 挂起当前事务</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(transaction);</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		<span class="comment">// 创建一个新的非事务状态(保存了上一个存在事务状态的属性)</span></span><br><span class="line">		<span class="keyword">return</span> prepareTransactionStatus(</span><br><span class="line">				definition, <span class="literal">null</span>, <span class="literal">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当前的事务属性状态是PROPAGATION_REQUIRES_NEW表示需要新开启一个事务状态</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Suspending current transaction, creating new transaction with name [&quot;</span> +</span><br><span class="line">					definition.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 挂起当前事务并返回挂起的资源持有器</span></span><br><span class="line">		<span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(transaction);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建一个新的非事务状态(保存了上一个存在事务状态的属性)</span></span><br><span class="line">			<span class="keyword">return</span> startTransaction(definition, transaction, debugEnabled, suspendedResources);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">			resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">			<span class="keyword">throw</span> beginEx;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 嵌套事务</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		<span class="comment">// 不允许就报异常</span></span><br><span class="line">		<span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedTransactionNotSupportedException</span>(</span><br><span class="line">					<span class="string">&quot;Transaction manager does not allow nested transactions by default - &quot;</span> +</span><br><span class="line">					<span class="string">&quot;specify &#x27;nestedTransactionAllowed&#x27; property with value &#x27;true&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Creating nested transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 嵌套事务的处理</span></span><br><span class="line">		<span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">			<span class="comment">// Create savepoint within existing Spring-managed transaction,</span></span><br><span class="line">			<span class="comment">// through the SavepointManager API implemented by TransactionStatus.</span></span><br><span class="line">			<span class="comment">// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span></span><br><span class="line">			<span class="comment">// 如果没有可以使用保存点的方式控制事务回滚，那么在嵌入式事务的建立初始简历保存点</span></span><br><span class="line">			<span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span></span><br><span class="line">					prepareTransactionStatus(definition, transaction, <span class="literal">false</span>, <span class="literal">false</span>, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">			<span class="comment">// 为事务设置一个回退点</span></span><br><span class="line">			status.createAndHoldSavepoint();</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Nested transaction through nested begin and commit/rollback calls.</span></span><br><span class="line">			<span class="comment">// Usually only for JTA: Spring synchronization might get activated here</span></span><br><span class="line">			<span class="comment">// in case of a pre-existing JTA transaction.</span></span><br><span class="line">			<span class="comment">// 有些情况是不能使用保存点操作</span></span><br><span class="line">			<span class="keyword">return</span> startTransaction(definition, transaction, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span></span><br><span class="line">	<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Participating in existing transaction&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isValidateExistingTransaction()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">			<span class="type">Integer</span> <span class="variable">currentIsolationLevel</span> <span class="operator">=</span> TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">			<span class="keyword">if</span> (currentIsolationLevel == <span class="literal">null</span> || currentIsolationLevel != definition.getIsolationLevel()) &#123;</span><br><span class="line">				<span class="type">Constants</span> <span class="variable">isoConstants</span> <span class="operator">=</span> DefaultTransactionDefinition.constants;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(<span class="string">&quot;Participating transaction with definition [&quot;</span> +</span><br><span class="line">						definition + <span class="string">&quot;] specifies isolation level which is incompatible with existing transaction: &quot;</span> +</span><br><span class="line">						(currentIsolationLevel != <span class="literal">null</span> ?</span><br><span class="line">								isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</span><br><span class="line">								<span class="string">&quot;(unknown)&quot;</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!definition.isReadOnly()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(<span class="string">&quot;Participating transaction with definition [&quot;</span> +</span><br><span class="line">						definition + <span class="string">&quot;] is not marked as read-only but existing transaction is&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">	<span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="literal">false</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="rollback"><a href="#rollback" class="headerlink" title="rollback"></a>rollback</h3><p>事务管理器根据事务状态来处理回滚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">	<span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line">				<span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">DefaultTransactionStatus</span> <span class="variable">defStatus</span> <span class="operator">=</span> (DefaultTransactionStatus) status;</span><br><span class="line">	processRollback(defStatus, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * unexpected 一般是 false，除非是设置 rollback-only=true，才是true，表示是全局的回滚标记。首先会进行回滚前回调，</span></span><br><span class="line"><span class="comment"> * 然后判断是否设置了保存点，比如 NESTED 会设置，要先回滚到保存点。如果状态是新的事务，那就进行回滚，如果不是新的，就设置一个回滚标记，</span></span><br><span class="line"><span class="comment"> * 内部是设置连接持有器回滚标记。然后回滚完成回调，根据事务状态信息，完成后数据清除,和线程的私有资源解绑，</span></span><br><span class="line"><span class="comment"> * 重置连接自动提交，隔离级别，是否只读，释放连接，恢复挂起事务等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="type">boolean</span> unexpected)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 意外的回滚</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">unexpectedRollback</span> <span class="operator">=</span> unexpected;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 回滚完成前回调</span></span><br><span class="line">			triggerBeforeCompletion(status);</span><br><span class="line">			<span class="comment">// 有保存点回滚到保存点</span></span><br><span class="line">			<span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Rolling back transaction to savepoint&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				status.rollbackToHeldSavepoint();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当前状态是一个新事务</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Initiating transaction rollback&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 进行回滚</span></span><br><span class="line">				doRollback(status);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Participating in larger transaction</span></span><br><span class="line">				<span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line">					<span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">						<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">							logger.debug(<span class="string">&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">//设置连接要回滚标记，也就是全局回滚</span></span><br><span class="line">						doSetRollbackOnly(status);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">							logger.debug(<span class="string">&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Should roll back transaction but cannot - no transaction available&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Unexpected rollback only matters here if we&#x27;re asked to fail early</span></span><br><span class="line">				<span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">					unexpectedRollback = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 回滚完成后回调</span></span><br><span class="line">		triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Raise UnexpectedRollbackException if we had a global rollback-only marker</span></span><br><span class="line">		<span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedRollbackException</span>(</span><br><span class="line">					<span class="string">&quot;Transaction rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 根据事务状态信息，完成后数据清除，和线程的私有资源解绑，重置连接自动提交，隔离级别，是否只读，释放连接，恢复挂起事务等</span></span><br><span class="line">		cleanupAfterCompletion(status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">	<span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line">				<span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">DefaultTransactionStatus</span> <span class="variable">defStatus</span> <span class="operator">=</span> (DefaultTransactionStatus) status;</span><br><span class="line">	<span class="comment">// 如果在事务链中已经被标记回滚，那么不会尝试提交事务，直接回滚</span></span><br><span class="line">	<span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Transactional code has requested rollback&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不可预期的回滚</span></span><br><span class="line">		processRollback(defStatus, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置了全局回滚</span></span><br><span class="line">	<span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 可预期的回滚，可能会报异常</span></span><br><span class="line">		processRollback(defStatus, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理事务提交</span></span><br><span class="line">	processCommit(defStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理提交，先处理保存点，然后处理新事务，如果不是新事务不会真正提交，要等外层是新事务的才提交，</span></span><br><span class="line"><span class="comment"> * 最后根据条件执行数据清除,线程的私有资源解绑，重置连接自动提交，隔离级别，是否只读，释放连接，恢复挂起事务等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">beforeCompletionInvoked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">unexpectedRollback</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="comment">// 预留</span></span><br><span class="line">			prepareForCommit(status);</span><br><span class="line">			<span class="comment">// 添加的 TransactionSynchronization 中的对应方法的调用</span></span><br><span class="line">			triggerBeforeCommit(status);</span><br><span class="line">			<span class="comment">// 提交完成前回调</span></span><br><span class="line">			triggerBeforeCompletion(status);</span><br><span class="line">			beforeCompletionInvoked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 有保存点</span></span><br><span class="line">			<span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Releasing transaction savepoint&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//是否有全局回滚标记</span></span><br><span class="line">				unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">				<span class="comment">// 如果存在保存点则清除保存点信息</span></span><br><span class="line">				status.releaseHeldSavepoint();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当前状态是新事务</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Initiating transaction commit&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">				<span class="comment">// 如果是独立的事务则直接提交</span></span><br><span class="line">				doCommit(status);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">				unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Throw UnexpectedRollbackException if we have a global rollback-only</span></span><br><span class="line">			<span class="comment">// marker but still didn&#x27;t get a corresponding exception from commit.</span></span><br><span class="line">			<span class="comment">// 有全局回滚标记就报异常</span></span><br><span class="line">			<span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedRollbackException</span>(</span><br><span class="line">						<span class="string">&quot;Transaction silently rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (UnexpectedRollbackException ex) &#123;</span><br><span class="line">			<span class="comment">// can only be caused by doCommit</span></span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (TransactionException ex) &#123;</span><br><span class="line">			<span class="comment">// can only be caused by doCommit</span></span><br><span class="line">			<span class="keyword">if</span> (isRollbackOnCommitFailure()) &#123;</span><br><span class="line">				doRollbackOnCommitException(status, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!beforeCompletionInvoked) &#123;</span><br><span class="line">				triggerBeforeCompletion(status);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 提交过程中出现异常则回滚</span></span><br><span class="line">			doRollbackOnCommitException(status, ex);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Trigger afterCommit callbacks, with an exception thrown there</span></span><br><span class="line">		<span class="comment">// propagated to callers but the transaction still considered as committed.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 提交后回调</span></span><br><span class="line">			triggerAfterCommit(status);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 提交后清除线程私有同步状态</span></span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">//根据条件，完成后数据清除,和线程的私有资源解绑，重置连接自动提交，隔离级别，是否只读，释放连接，恢复挂起事务等</span></span><br><span class="line">		cleanupAfterCompletion(status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
        <tag>SpringAOP</tag>
        <tag>SpringTX</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码之核心加载方法(13) finishRefresh</title>
    <url>/2020/10/25/spring/Spring14/</url>
    <content><![CDATA[<h2 id="13-AbstractApplicationContext-finishRefresh"><a href="#13-AbstractApplicationContext-finishRefresh" class="headerlink" title="13 AbstractApplicationContext#finishRefresh"></a>13 AbstractApplicationContext#finishRefresh</h2><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#finishRefresh</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">   <span class="comment">// 清除资源缓存</span></span><br><span class="line">   clearResourceCaches();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">   <span class="comment">// 将刷新完毕时间传播到生命周期处理器</span></span><br><span class="line">   initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">   <span class="comment">// 首先将刷新完毕事件传播到生命周期处理器（触发 isAutoStartup 方法返回 true 的 SmartLifecycle#start 方法）</span></span><br><span class="line">   getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish the final event.</span></span><br><span class="line">   <span class="comment">// 发布事件</span></span><br><span class="line">   publishEvent(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">   LiveBeansView.registerApplicationContext(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-1-AbstractApplicationContext-initLifecycleProcessor"><a href="#13-1-AbstractApplicationContext-initLifecycleProcessor" class="headerlink" title="13.1 AbstractApplicationContext#initLifecycleProcessor"></a>13.1 AbstractApplicationContext#initLifecycleProcessor</h3><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#finishRefresh</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initLifecycleProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">   <span class="comment">// 判断 beanFactory 是否已经存在生命周期处理器</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="comment">// 如果已经存在，则将该bean赋值给lifecycleProcessor</span></span><br><span class="line">      <span class="built_in">this</span>.lifecycleProcessor =</span><br><span class="line">            beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Using LifecycleProcessor [&quot;</span> + <span class="built_in">this</span>.lifecycleProcessor + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不存在，则使用 DefaultLifecycleProcessor</span></span><br><span class="line">      <span class="type">DefaultLifecycleProcessor</span> <span class="variable">defaultProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultLifecycleProcessor</span>();</span><br><span class="line">      defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line">      <span class="built_in">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line">      <span class="comment">// 将 DefaultLifecycleProcessor 作为默认的生命周期处理器，注册到 beanFactory 中</span></span><br><span class="line">      beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="built_in">this</span>.lifecycleProcessor);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + LIFECYCLE_PROCESSOR_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">               <span class="string">&quot;[&quot;</span> + <span class="built_in">this</span>.lifecycleProcessor.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-2-DefaultLifecycleProcessor-onRefresh"><a href="#13-2-DefaultLifecycleProcessor-onRefresh" class="headerlink" title="13.2 DefaultLifecycleProcessor#onRefresh"></a>13.2 DefaultLifecycleProcessor#onRefresh</h3><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.DefaultLifecycleProcessor#onRefresh</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.context.support.DefaultLifecycleProcessor#onRefresh</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    startBeans(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">this</span>.running = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startBeans</span><span class="params">(<span class="type">boolean</span> autoStartupOnly)</span> &#123;</span><br><span class="line">   <span class="comment">// 检索所有适用的生命周期Bean：所有已经创建的单例Bean，以及所有 SmartLifeCycle Bean(即使它们被标记未延迟初始化)</span></span><br><span class="line">   Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">   <span class="comment">// 各 phases 所对应的 LifecycleGroup Map</span></span><br><span class="line">   Map&lt;Integer, LifecycleGroup&gt; phases = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 遍历所有 lifecycle bean,按阶段值分组</span></span><br><span class="line">   lifecycleBeans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">      <span class="comment">// SmartLifecycle : 生命周期接口的扩展,用于那些需要在 ApplicationContext 刷新 和/或 特定顺序关闭时 启动的对象。</span></span><br><span class="line">      <span class="comment">// 如果不是 autoStartupOnly || (bean 是 SmartLifecycle 的实例) &amp;&amp; bean指定在包含ApplicationContext的刷新时由容器自动启动</span></span><br><span class="line">      <span class="keyword">if</span> (!autoStartupOnly || (bean <span class="keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line">         <span class="comment">// 获取 bean 的生命周期阶段(相位值)</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">phase</span> <span class="operator">=</span> getPhase(bean);</span><br><span class="line">         <span class="comment">// 获取 phase 对应的 LifecycleGroup</span></span><br><span class="line">         <span class="type">LifecycleGroup</span> <span class="variable">group</span> <span class="operator">=</span> phases.get(phase);</span><br><span class="line">         <span class="comment">// 如果 group 不为 null</span></span><br><span class="line">         <span class="keyword">if</span> (group == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 新建一个 LifecycleGroup 的实例</span></span><br><span class="line">            group = <span class="keyword">new</span> <span class="title class_">LifecycleGroup</span>(phase, <span class="built_in">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span><br><span class="line">            <span class="comment">//将 phase，group 绑定到 phases 中</span></span><br><span class="line">            phases.put(phase, group);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 将beanName，bean绑定到 group 中</span></span><br><span class="line">         group.add(beanName, bean);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">// 如果 phases 不是空集</span></span><br><span class="line">   <span class="keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 存放生命周期阶段(相位值)</span></span><br><span class="line">      List&lt;Integer&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(phases.keySet());</span><br><span class="line">      <span class="comment">// 按阶段值进行排序</span></span><br><span class="line">      Collections.sort(keys);</span><br><span class="line">      <span class="comment">// 调用 lifecycleGroup 中的所有 lifecycle#start 方法</span></span><br><span class="line">      <span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">         <span class="comment">// 启动 key 对应的 LifecycleGroup</span></span><br><span class="line">         phases.get(key).start();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-3-AbstractApplicationContext-publishEvent"><a href="#13-3-AbstractApplicationContext-publishEvent" class="headerlink" title="13.3 AbstractApplicationContext#publishEvent"></a>13.3 AbstractApplicationContext#publishEvent</h3><blockquote>
<p><strong>定位</strong>: org.springframework.context.support.AbstractApplicationContext#publishEvent</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">   Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">   <span class="comment">// 如果有必要，将事件装饰为 applicationEvent</span></span><br><span class="line">   ApplicationEvent applicationEvent;</span><br><span class="line">   <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">      applicationEvent = (ApplicationEvent) event;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是事件类型就转为事件类型</span></span><br><span class="line">      applicationEvent = <span class="keyword">new</span> <span class="title class_">PayloadApplicationEvent</span>&lt;&gt;(<span class="built_in">this</span>, event);</span><br><span class="line">      <span class="keyword">if</span> (eventType == <span class="literal">null</span>) &#123;</span><br><span class="line">         eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">   <span class="comment">// 如果可能，立即进行多播或者一旦初始化多播器就进入懒惰状态</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationEvents != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 获取事件广播器，发布事件</span></span><br><span class="line">      getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line">   <span class="comment">// 如果存在父容器，那么父容器也发布事件</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">         ((AbstractApplicationContext) <span class="built_in">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.parent.publishEvent(event);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-3-1-SimpleApplicationEventMulticaster-multicastEvent"><a href="#13-3-1-SimpleApplicationEventMulticaster-multicastEvent" class="headerlink" title="13.3.1 SimpleApplicationEventMulticaster#multicastEvent"></a>13.3.1 SimpleApplicationEventMulticaster#multicastEvent</h4><blockquote>
<p><strong>定位</strong>: org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">   <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">   <span class="comment">// 返回此广播器的当前任务执行程序</span></span><br><span class="line">   <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">   <span class="comment">// getApplicationListeners方法是返回与给定事件类型匹配的应用监听器集合</span></span><br><span class="line">   <span class="comment">// 遍历所有的监听器</span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 如果executor不为空，则使用executor调用监听器</span></span><br><span class="line">         executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 否则直接调用监听器</span></span><br><span class="line">         invokeListener(listener, event);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> &#123;</span><br><span class="line">	<span class="comment">// 返回此广播器的当前错误处理程序</span></span><br><span class="line">	<span class="type">ErrorHandler</span> <span class="variable">errorHandler</span> <span class="operator">=</span> getErrorHandler();</span><br><span class="line">	<span class="keyword">if</span> (errorHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 如果errorHandler不为null，则使用带错误处理的方式调用给定的监听器</span></span><br><span class="line">			doInvokeListener(listener, event);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">			errorHandler.handleError(err);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 否则直接调用给定的监听器</span></span><br><span class="line">		doInvokeListener(listener, event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 触发监听器的onApplicationEvent方法，参数为给定的事件</span></span><br><span class="line">        listener.onApplicationEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span> || matchesClassCastMessage(msg, event.getClass())) &#123;</span><br><span class="line">            <span class="comment">// Possibly a lambda-defined listener which we could not resolve the generic event type for</span></span><br><span class="line">            <span class="comment">// -&gt; let&#x27;s suppress the exception and just log a debug message.</span></span><br><span class="line">            <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Non-matching event type for listener: &quot;</span> + listener, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
